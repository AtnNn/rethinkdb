IssueComment
  { issueCommentUpdatedAt = 2013 (-05) (-09) 15 : 56 : 13 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/17672234"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/771#issuecomment-17672234"
  , issueCommentCreatedAt = 2013 (-05) (-09) 15 : 56 : 13 UTC
  , issueCommentBody =
      "The main issue is that we have less of a type hierarchy than a type DAG, and some of the edges only exist inside of certain functions.  We also squish some types together for some functions but not others.\r\n\r\nFor example, inside `insert` we handle arrays and sequences in the same code-path.  In `slice`, though, they take separate code-paths because we allow different operations on arrays.\r\n\r\nCurrently the way we handle this is that each overloaded function is responsible for checking its own arguments and branching.  These chunks of logic are very eclectic, and I kept running into edge cases when I tried to unify them into a single `val_t` function (which we'd need to do if we wanted to have a single source of errors for them).\r\n\r\nThere are also some functions which accept a strange mix of things, like `filter`.  `filter` accepts an object as shortcut syntax, but if someone puts `r.row` into the object the drivers turn it into a function instead.  (That is, if someone writes `...filter([1])`, we get an array, but if they write `...filter([r.row])`, we get a function.)  `filter` also only works if the function you pass it returns a boolean, but we currently don't have a place in our type hierarchy for function return types.  So this is an example of something we couldn't check in a generic way without a lot of work.  We currently get around this by just hardcoding a sane error message for filter (\"FILTER must be passed either an OBJECT or a predicate\").\r\n\r\nAnother example is `funcall`.  `funcall` takes either a function or any RQL datum.  (I'm actually not sure why we restrict it to datums instead of vals; that's arguably a bug.)  So you can write `r(1).do{|x| x+1}` or `r(1).do{2}` or `r(1).do(2)` and get the same result (2).  It would reall suck if the error message for funcall said `FUNCALL expects type [FUNCTION, OBJECT, ARRAY, NUMBER, ...] but ...` if you tried to use a database instead of a function.  It currently says \"RqlRuntimeError: Expected type FUNCTION but found DATABASE:\".\r\n\r\nThere are also implementation problems, because our types are currently split between `val_t` types and `datum_t` types.  This isn't a theoretical problem, but we'd probably have to promote our notion of composite types that we currently use for type coercion to be a full-blown feature of `val_t`, which is sort of irritating to do.\r\n\r\n---\r\n\r\nIn brief, there are a few functions with eclectic polymorphic interfaces where the generic argument-checking code (not designed with polymorphic functions in mind) produces confusing errors.  We've previously simply hard-coded errors for those functions, which makes sense because each one has different error reporting needs.  (We want `insert` to report 2 of the 3 types it accepts, since it converts arrays to sequences even though they're of type DATUM, we want `filter` to report a type that isn't even in our type system (predicate), and we want `funcall` to report only one of its types.)  We could try to unify these, but I'm not sure it would actually result in better code.\r\n\r\nOf course, it's a continuum here -- I could probably come up with more general code than I submitted to the code-review by thinking about it for a while (the solution I uploaded, for those who haven't checked, basically just passes the error message we want down into `as_seq`).  If you think this is important, I'll think a little harder about it and see what I can come up with."
  , issueCommentId = 17672234
  }