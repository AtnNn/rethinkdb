IssueComment
  { issueCommentUpdatedAt = 2013 (-10) (-30) 03 : 38 : 00 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/27363123"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1010#issuecomment-27363123"
  , issueCommentCreatedAt = 2013 (-10) (-30) 03 : 38 : 00 UTC
  , issueCommentBody =
      "Err, sorry I missed that. Here are some reasons why in-place migration and rolling migration would significantly slow down development.\r\n\r\nInternally RethinkDB doesn't have a monolithic versioned serialization format -- there are a number of components, each with their own format that has to be written to disk or network. These includes the log-structured serializer format (basically a mini-filesystem that allows us to efficiently lay out blocks on disk), the B-Tree format (this is the format of every block and contains links to other blocks, timestamps for efficient replication, etc.), the document serialization format (how JSON documents are laid out on disk), and the secondary index format (this is how we store secondary index functions on disk when the user creates a secondary index). Additionally, here are the network formats that would have to be maintained to do rolling upgrades: the cluster semilattice format (this is cluster metadata that gets exchanged between nodes), the intracluster write format (this is the lower-level message sending component that allows exchanging the semilattices) and the client driver protocol.\r\n\r\nAll these formats have mostly stabilized, but since we're still doing a lot of optimizations, every release tends to change 2-4 formats out of the list above. So the in-place migration and rolling update aren't actually one (or two) problems, it's about half a dozen problems wrapped into one. There are roughly two ways to offer in-place migration:\r\n\r\n* Every time there is a change to any of the formats, ensure that there is code in the server that can read the old format and do on-demand migration (i.e. allow reading old formats, but write only in the latest one).\r\n* Ship an LTS release and only do bug-fixes on the release that do not require format changes. If there is a serious bug that can't wait for the next LTS release that requires a format change, include code that can read the old format for that change.\r\n\r\nThe reason why the first option would put significant burden on development is that *every* format change would require carefully thinking through backwards compatibility, writing and testing code that can read *both* formats, and ensuring that any format change can easily be upgraded to the new format without user intervention. This is *really* time consuming, and since there are 2 - 4 changes per release as of now, most of the time would be spend thinking through backwards compatibility and testing the relevant code. It can also be a significant source of bugs.\r\n\r\nOn the other hand the second option sidesteps these issues entirely. We'd only have to resort to backwards compatibility code if there is a critical bug that requires a format change, which is extremely rare. Picking this options allows for a good balance of maintaining backwards compatibility (once you have an LTS release you have a guarantee that the format won't change for that branch), and development speed (once 2.0 is out, we can continue developing 2.x without worrying about backwards compatibility in the unstable branch, until we ship 3.0). This really is the best option, but it has the downside of inconveniencing existing users until the LTS release. Given that it's coming pretty soon, we decided to go with option 2. It's the best long-term decision, and as painful as it is, we don't want to sacrifice long term development speed and stability for a short term gain.\r\n"
  , issueCommentId = 27363123
  }