IssueComment
  { issueCommentUpdatedAt = 2014 (-07) (-04) 00 : 19 : 08 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47997915"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2647#issuecomment-47997915"
  , issueCommentCreatedAt = 2014 (-07) (-04) 00 : 19 : 08 UTC
  , issueCommentBody =
      "Alright, here's my proposal:\r\n\r\n* We have a special `metadata` and `chunks` table.\r\n  - Option 1: We have a special `system` (or `$system$`) database, and you can access these tables to shard them or whatever by writing `r.db('system').table('chunks')`.  (I prefer this one.)\r\n  - Option 2: We don't expose these as normal tables, and you can write `r.file_metadata()` to get the metadata table or `r.file_chunks()` to get the chunks table.\r\n* We treat files as first-class objects.  We offer the following commands:\r\n  * `r.file_create(File.open(...))` # creates a file with the same name as the local file\r\n  * `r.file_create(File.open(...), name: ...)`\r\n  * `r.file_list()`\r\n  * `r.file_status(file_name)`\r\n  * `r.file_drop(file_name)`\r\n  * `r.file(file_name)` -- produces a file pseudotype referencing `file_name`\r\n  * `r.file(file_name).metadata()` -- gets the metadata for a file.\r\n    - OPTIONAL: We can make this return a single row selection on the metadata if we want to let users update it here.\r\n* `file_create` takes two optargs `metadata_table` and `chunks_table`, defaulting to the system metadata table and the system chunks table.  All the other file commands take an optarg `metadata_table` defaulting to the system metadata table (the metadata says which chunks table to use).\r\n  - Note that this is **our** metadata, not user metadata.\r\n* OPTIONAL: Optionally, we can support `r.table('test').insert({name: ..., data: File.open(...)})`\r\n  - This will create the file with a UUID as its name.\r\n  - If the user is interrupted while uploading it (see below), they can get the uuid out of the metadata to resume the upload.\r\n* **Resuming uploads** -- we will support resuming uploads by just calling `file_create` again with the same name and file.  (If the state of the metadata is INCOMPLETE, we will just resume uploading chunks.  We can also optionally include a hash of the file in the metadata to make sure people don't resume with the wrong one).\r\n* **Deletes** -- deletes will be handled the way I specified in #137, including the ability to resume deleting.\r\n* **Cleanup** -- to account for loss of consistency in certain cluster scenarios (once again, see #137), we will offer a command `r.file_cleanup` which takes two optargs `metadata_tables` and `chunks_tables`.  It will remove any rows in the chunks tables that do not correspond to valid file chunk based on the information in the metadata tables.  (This is a *tiny* bit tricky, but we can be conservative here.)\r\n* **Lost file chunks** -- if some chunks of a file are lost, we have a state in the metadata for that, and the user has to resume uploading to replace the lost chunks.\r\n* **File pseudotype** -- the file pseudotype will turn into a native type in the clients that supports seeking and reading like a normal file.  Optionally, we can also support writing.\r\n\r\n---\r\n\r\nPossible Simplifications:\r\n* We can drop all the optional components.\r\n* We can skip the part where we let users specify different metadata and chunks tables for the first version.  (Or we can just drop the metadata table: specifying a custom chunks table is pretty easy.  Dropping custom metadata tables also makes cleanup way easier.)\r\n* We can skip resumable deletes -- if a delete fails in the middle, you have to call `cleanup`.\r\n\r\n---\r\n\r\nWhen talking with @coffeemug, he suggested we use a name other than `.file` to make it clear it's a reference to a file (like maybe `.file_handle` or something)."
  , issueCommentId = 47997915
  }