IssueComment
  { issueCommentUpdatedAt = 2014 (-07) (-07) 18 : 38 : 36 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 258437
        , simpleUserLogin = N "srh"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/258437?v=3"
        , simpleUserUrl = "https://api.github.com/users/srh"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/48221532"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2647#issuecomment-48221532"
  , issueCommentCreatedAt = 2014 (-07) (-07) 18 : 38 : 36 UTC
  , issueCommentBody =
      "This is completely underspecified.\r\n\r\n> We have a special metadata and chunks table.\r\n\r\nWhat does the metadata table contain and what does the chunks table contain?\r\n\r\nHow big can a chunk be?  How small can a chunk be?  Are the chunks of fixed size?  (We don't want chunks to be too big, and we don't want there to be too many chunks for a big file, because then the metadata will be too big.)\r\n\r\nWhat is the actual algorithm for uploading a file chunk and updating\r\nthe metadata?\r\n\r\nWhat alternative choices for representing files (in chunks) have you\r\nconsidered?\r\n\r\n> Option 1: We have a special system (or $system$) database, and you can access these tables to shard them or whatever by writing r.db('system').table('chunks'). (I prefer this one.)\r\n\r\nDo you know why tables are put in databases?  Why would files be outside them?\r\n\r\n> r.file_create(File.open(...)) # creates a file with the same name as the local file\r\n\r\nWhy would we want to use the same name as the local file?  Why do we want filenames in the first place?  How are we even going to access the file name?  (This is completely ridiculous.)\r\n\r\nWho is going to be creating a file from some local system file anyway?\r\n\r\nHTTP file uploads can come with browser-supplied names.  We certainly don't want to blindly pull the filename from the browser-supplied name.\r\n\r\n> r.file_list()\r\n\r\nWell, what does this return?\r\n\r\n> r.file_status(file_name)\r\n\r\nWhat does this return?\r\n\r\n> r.file_drop(file_name)\r\n\r\nWhat does this return?\r\n\r\n> r.file(file_name) -- produces a file pseudotype referencing file_name\r\n\r\nWhat is the filename?  For what table of files?  What is the format of a file name?\r\n\r\n> r.file(file_name).metadata() -- gets the metadata for a file.\r\n\r\nThis is backwards.  This is like saying\r\nr.expr(key).get_from_table(table_name).  You can't get the metadata\r\nfrom a file reference.  That's a query.\r\n\r\n> file_create takes two optargs metadata_table and chunks_table, defaulting to the system metadata table and the system chunks table. All the other file commands take an optarg metadata_table defaulting to the system metadata table (the metadata says which chunks table to use).\r\n\r\n>    Note that this is our metadata, not user metadata.\r\n\r\nWhat is \"our\" metadata?\r\n\r\n> OPTIONAL: Optionally, we can support r.table('test').insert({name: ..., data: File.open(...)})\r\n\r\nThen this is spec bloat, let's not waste our time thinking about this right now.\r\n\r\n> Resuming uploads -- we will support resuming uploads by just calling file_create again with the same name and file. (If the state of the metadata is INCOMPLETE, we will just resume uploading chunks. We can also optionally include a hash of the file in the metadata to make sure people don't resume with the wrong one).\r\n\r\nSo... uploads are resumed from the beginning?\r\n\r\nWe let users silently overwrite files with the same name?\r\n\r\n>  Deletes -- deletes will be handled the way I specified in #137, including the ability to resume deleting.\r\n\r\nI don't feel like reading the whole issue to find where you specified it so copy that specification here.\r\n\r\n> Cleanup -- to account for loss of consistency in certain cluster scenarios (once again, see #137), we will offer a command r.file_cleanup which takes two optargs metadata_tables and chunks_tables. It will remove any rows in the chunks tables that do not correspond to valid file chunk based on the information in the metadata tables. (This is a tiny bit tricky, but we can be conservative here.)\r\n\r\nWhat if a different metadata table refers to the chunk in the chunks table?  Specify why that's not a problem.\r\n\r\nWhat if somebody's in the process of uploading a file to these tables?  What prevents us from messing that up?\r\n\r\n> Lost file chunks -- if some chunks of a file are lost, we have a state in the metadata for that, and the user has to resume uploading to replace the lost chunks.\r\n\r\nHow would the metadata know about lost file chunks?\r\n\r\n> File pseudotype -- the file pseudotype will turn into a native type in the clients that supports seeking and reading like a normal file. Optionally, we can also support writing.\r\n\r\nWhat do you mean, \"writing\"?\r\n\r\n"
  , issueCommentId = 48221532
  }