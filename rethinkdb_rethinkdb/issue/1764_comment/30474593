IssueComment
  { issueCommentUpdatedAt = 2013 (-12) (-12) 23 : 56 : 57 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 371348
        , simpleUserLogin = N "jakcharlton"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/371348?v=3"
        , simpleUserUrl = "https://api.github.com/users/jakcharlton"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/30474593"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1764#issuecomment-30474593"
  , issueCommentCreatedAt = 2013 (-12) (-12) 23 : 56 : 57 UTC
  , issueCommentBody =
      "An eqJoin will throw with a null key? That would be even more unexpected for me ... I would presume eqJoin would be the equivalent of an INNER JOIN in a SQL DB\r\n\r\nThis would create an odd situation where a user wanted to remove a link ... but instead of setting the join key to NULL, you would have to actually remove the join key ... this would again trigger my principle of least surprise reaction and I would end up having to code all queries with guard clauses to ensure I wasn't having to deal with exceptions in my application\r\n\r\nAs a general rule, I don't believe databases should be returning exceptions unless I have violated their syntax, constraints, or schemas - in this case what I would consider a perfectly reasonable situation could cause exceptions.\r\n\r\nWhile the exceptions may be 'technically' the right solution, they would cause all sorts of application layer 'hacks' to get around these things to avoid giving a poor end user experience\r\n\r\n\r\nI am guessing innerJoin does what I would expect? Or does it work this way too?\r\n"
  , issueCommentId = 30474593
  }