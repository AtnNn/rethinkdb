IssueComment
  { issueCommentUpdatedAt = 2015 (-11) (-09) 09 : 22 : 53 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1266041
        , simpleUserLogin = N "mattias800"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1266041?v=3"
        , simpleUserUrl = "https://api.github.com/users/mattias800"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/155005409"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3930#issuecomment-155005409"
  , issueCommentCreatedAt = 2015 (-11) (-09) 09 : 22 : 53 UTC
  , issueCommentBody =
      "I'm curious as well.\r\n\r\nI could see it automatically populating (and returning) data objects given a class as a parameter (like GSON does with deserialization). But I'm not sure how you would add typing to the communications API?\r\n\r\nHaving it return instances of your own classes would be a great feature though.\r\nSee rxjava-jdbc for an example: https://github.com/davidmoten/rxjava-jdbc\r\n\r\n```\r\nObservable<Person> persons = db\r\n                 .select(\"select name, score from person order by name\")\r\n                 .autoMap(Person.class);\r\n```\r\n\r\nAnd you could use (preferably standard) annotations for mapping properties to class members.\r\n\r\n```\r\npublic interface Person {\r\n\r\n    @Column(\"name\")\r\n    String name();\r\n\r\n    @Column(\"score\")\r\n    int score();\r\n}\r\n```\r\n"
  , issueCommentId = 155005409
  }