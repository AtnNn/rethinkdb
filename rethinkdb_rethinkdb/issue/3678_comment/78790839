IssueComment
  { issueCommentUpdatedAt = 2015 (-03) (-23) 20 : 36 : 03 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/78790839"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3678#issuecomment-78790839"
  , issueCommentCreatedAt = 2015 (-03) (-13) 04 : 18 : 42 UTC
  , issueCommentBody =
      "# Accessing RethinkDB with EventMachine\r\n\r\n## Basic Usage\r\n\r\nThe simplest way to access RethinkDB with EventMachine is to call\r\n`em_run` with a block.  If RethinkDB returns a sequence (an array or a\r\nstream), the block will be called with each element of that sequence.\r\nIf RethinkDB returns anything else, the block will be called once with\r\nthat value.\r\n\r\n#### Example 1: iterating over a stream\r\n\r\n```rb\r\n# Insert some data.\r\nr.table('test').insert([{id: 0}, {id: 1}, {id: 2}]).run($conn)\r\nEM.run {\r\n  # Print every row in the table.\r\n  r.table('test').order_by(index: 'id').em_run($conn) {|row|\r\n    p row\r\n  }\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```rb\r\n{\"id\"=>0}\r\n{\"id\"=>1}\r\n{\"id\"=>2}\r\n```\r\n\r\n#### Example 2: iterating over an array\r\n\r\n```rb\r\nEM.run {\r\n  # Print an array.\r\n  r.expr([1, 2, 3]).em_run($conn) {|n|\r\n    p n\r\n  }\r\n}\r\n``\r\n\r\nWill print:\r\n\r\n```rb\r\n1\r\n2\r\n3\r\n```\r\n\r\n#### Example 3: accessing a single row\r\n\r\n```rb\r\n# Insert some data.\r\nr.table('test').insert([{id: 0}, {id: 1}, {id: 2}]).run($conn)\r\nEM.run {\r\n  # Print a single row.\r\n  r.table('test').get(0).em_run($conn) {|row|\r\n    p row\r\n  }\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```rb\r\n{\"id\"=>0}\r\n```\r\n\r\n## Basic Error Handling\r\n\r\nIf you pass `em_run` a block that only accepts a single argument,\r\nRethinkDB's EM adapter will handle errors by re-throwing them.  You\r\ncan also handle errors in the block by passing `em_run` a block that\r\naccepts two arguments.  If you do so, then the block will either be\r\ncalled with `nil` as its first argument and data as its second\r\nargument, or with an error as its first argument and `nil` as its\r\nsecond argument.\r\n\r\nNote that it's possible for the block to be passed data many times,\r\nand then be passed an error.  For example, this can happen if you lose\r\navailability in the middle of a long read.\r\n\r\n#### Example 1: re-thrown errors\r\n\r\n```rb\r\nEM.run {\r\n  r.table('non_existent').em_run($conn) {|row|\r\n    p row\r\n  }\r\n}\r\n```\r\n\r\nWill produce an error:\r\n\r\n```rb\r\nRethinkDB::RqlRuntimeError: Table `test.non_existent` does not exist.\r\nBacktrace:\r\nr.table(\"non_existent\")\r\n^^^^^^^^^^^^^^^^^^^^^^^\r\n```\r\n\r\n#### Example 2: handling errors in the block\r\n\r\n```rb\r\nEM.run {\r\n  r.table('non_existent').em_run($conn) {|err, row|\r\n    if err\r\n      p [:err, err.to_s]\r\n    else\r\n      p [:row, row]\r\n    end\r\n  }\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```rb\r\n[:err, \"Table `test.non_existent` does not exist.\\nBacktrace:\\nr.table(\\\"non_existent\\\")\\n^^^^^^^^^^^^^^^^^^^^^^^\"]\r\n```\r\n\r\nAnd\r\n\r\n```rb\r\n# Insert some data.\r\nr.table('test').insert([{id: 0}, {id: 1}, {id: 2}]).run($conn)\r\nEM.run {\r\n  # Print every row in the table.\r\n  r.table('test').order_by(index: 'id').em_run($conn) {|err, row|\r\n    if err\r\n      p [:err, err.to_s]\r\n    else\r\n      p [:row, row]\r\n    end\r\n  }\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```rb\r\n[:row, {\"id\"=>0}]\r\n[:row, {\"id\"=>1}]\r\n[:row, {\"id\"=>2}]\r\n```\r\n\r\n## Advanced Usage\r\n\r\nMore precise control is provided by a superclass `RethinkDB::Handler`.\r\nYou can write a class that inherits from `RethinkDB::Handler` and\r\noverrides certain methods, then pass an instance of that class to\r\n`em_run`.  (If you instead pass the name of the class, the RethinkDB\r\nevent machine adapter will instantiatie it for you with no arguments\r\nand use that.)\r\n\r\nHere's a simple example of a handler that prints things:\r\n\r\n```rb\r\nclass Printer < RethinkDB::Handler\r\n  def on_open\r\n    p :open\r\n  end\r\n  def on_close\r\n    p :closed\r\n  end\r\n  def on_error(err)\r\n    p [:err, err.to_s]\r\n  end\r\n  def on_val(val)\r\n    p [:val, val]\r\n  end\r\nend\r\n```\r\n\r\n#### Example 1: handling a stream\r\n\r\n\r\n```rb\r\n# Insert some data.\r\nr.table('test').insert([{id: 0}, {id: 1}, {id: 2}]).run($conn)\r\nEM.run {\r\n  # Print every row in the table.\r\n  r.table('test').order_by(index: 'id').em_run($conn, Printer)\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```rb\r\n:open\r\n[:val, {\"id\"=>0}]\r\n[:val, {\"id\"=>1}]\r\n[:val, {\"id\"=>2}]\r\n:closed\r\n```\r\n\r\n## Granular Advanced Usage\r\n\r\nSometimes you want to treat atoms differently from sequences, or to\r\ndistinguish streams from arrays.  You can do that by defining\r\n`on_array`, `on_atom`, and `on_stream_val`.  (If `on_array` isn't\r\ndefined but `on_atom` is, then arrays will be passed to `on_atom`.  If\r\nneither `on_array` nor `on_atom` is defined, each element of the array\r\nwill be passed to `on_stream_val` (or `on_val` if `on_stream_val`\r\nisn't defined).\r\n\r\n```rb\r\nclass Printer < RethinkDB::Handler\r\n  def on_open\r\n    p :open\r\n  end\r\n  def on_close\r\n    p :closed\r\n  end\r\n  def on_error(err)\r\n    p [:err, err.to_s]\r\n  end\r\n  def on_atom(atom)\r\n    p [:atom, atom]\r\n  end\r\n  def on_array(array)\r\n    p [:array, array]\r\n  end\r\n  def on_stream_val(val)\r\n    p [:stream_val, val]\r\n  end\r\nend\r\n```\r\n\r\n#### Example 1: handling granular results\r\n\r\n```\r\n# Insert some data.\r\nr.table('test').insert([{id: 0}, {id: 1}, {id: 2}]).run($conn)\r\nEM.run {\r\n  # Print every row in the table.\r\n  r.table('test').order_by(index: 'id').em_run($conn, Printer)\r\n  # Print an array.\r\n  r.expr([1, 2, 3]).em_run($conn, Printer)\r\n  # Print a single row.\r\n  r.table('test').get(0).em_run($conn, Printer)\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```\r\n:open\r\n[:stream_val, {\"id\"=>0}]\r\n[:stream_val, {\"id\"=>1}]\r\n[:stream_val, {\"id\"=>2}]\r\n:closed\r\n:open\r\n[:array, [1, 2, 3]]\r\n:closed\r\n:open\r\n[:atom, {\"id\"=>0}]\r\n:closed\r\n```\r\n\r\n(Note that when you register multiple callbacks, the order they're\r\ncalled in isn't guaranteed -- it would be perfectly legal for this to\r\nhave printed the result of `r.expr([1, 2, 3])` first.)\r\n\r\n## Changefeeds\r\n\r\nChangefeeds can be treated like normal streams.  If you pass a block\r\nto `em_run`, that block will be called with each document in the\r\nchange stream.  If you pass a `Handler` that defines `on_val` or\r\n`on_stream_val`, that function will be called with each document in\r\nthe change stream.\r\n\r\nIf you want more granular control, there are also several changefeed\r\nspecific functions that can be defined:\r\n\r\n* `on_initial_val` -- if you're subscribed to a changefeed that\r\n  returns initial values (`.get.changes` and `.order_by.limit.changes`\r\n  right now), those initial values will be passed to this function.\r\n* `on_change` -- changes will be passed to this function.\r\n* `on_change_error` -- sometimes the change stream includes documents\r\n  specifying errors that don't abort the feed (e.g. if the client is\r\n  reading too slowly and the server was forced to discard changes).\r\n  Those will be passed to this function if it's defined.\r\n* `on_state` -- sometimes the change stream includes documents\r\n  specifying the state of the stream.  Those will be passed to this\r\n  function if it's defined.\r\n\r\nHere's our printer class with these functions defined:\r\n\r\n```rb\r\nclass Printer < RethinkDB::Handler\r\n  def on_open\r\n    p :open\r\n  end\r\n  def on_close\r\n    p :closed\r\n  end\r\n  def on_error(err)\r\n    p [:err, err.to_s]\r\n  end\r\n\r\n  def on_change_error(err_str)\r\n    p [:change_error, err_str]\r\n  end\r\n  def on_initial_val(val)\r\n    p [:initial_val, val]\r\n  end\r\n  def on_state(state)\r\n    p [:state, state]\r\n  end\r\n  def on_change(old_val, new_val)\r\n    p [:change, old_val, new_val]\r\n  end\r\nend\r\n```\r\n\r\n#### Example 1: `.order_by.limit.changes`\r\n\r\n```rb\r\n# Insert some data.\r\nr.table('test').insert([{id: 0}, {id: 1}, {id: 2}]).run($conn)\r\nEM.run {\r\n  # Subscribe to changes on the two smallest elements.\r\n  r.table('test').order_by(index: 'id').limit(2).changes.em_run($conn, Printer)\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```rb\r\n:open\r\n[:state, \"initializing\"]\r\n[:initial_val, {\"id\"=>1}]\r\n[:initial_val, {\"id\"=>0}]\r\n[:state, \"ready\"]\r\n```\r\n\r\nIf you then insert a new row with an `id` of 0.5:\r\n\r\n```rb\r\nr.table('test').insert({id: 0.5}).run($conn)\r\n```\r\n\r\nIt will replace `{id: 1}` in the set with `{id: 0.5}`:\r\n\r\n```rb\r\n[:change, {\"id\"=>1}, {\"id\"=>0.5}]\r\n```\r\n\r\nIf the table is then dropped:\r\n\r\n```rb\r\nr.table_drop('test').run($conn)\r\n```\r\n\r\nThe changefeed will receive an error and be closed:\r\n```rb\r\n[:err, \"Changefeed aborted (table unavailable).\\nBacktrace:\\nr.table(\\\"test\\\").changes\\n^^^^^^^^^^^^^^^^^^^^^^^\"]\r\n:closed\r\n```\r\n\r\n## Stopping a Handler\r\n\r\nIf you call `Handler::stop`, that handler will stop processing\r\nchanges, and any open streams which try to use that handler will close\r\nthemselves.  (Note that queries registered to the handler *will not*\r\nbe interrupted.  See **Closing a QueryHandle** below if you want to\r\ninterrupt a query.)\r\n\r\n#### Example 1: printing the first 5 changes\r\n\r\n```rb\r\nclass Printer < RethinkDB::Handler\r\n  def initialize(max)\r\n    @counter = max\r\n    stop if @counter <= 0\r\n  end\r\n  def on_open\r\n    # Once the changefeed is open, insert 10 rows.\r\n    r.table('test').insert([{}]*10).run($conn, noreply: true)\r\n  end\r\n  def on_val(val)\r\n    # Every time we print a change, decrement `@counter` and stop if we hit 0.\r\n    p val\r\n    @counter -= 1\r\n    stop if @counter <= 0\r\n  end\r\nend\r\n\r\nEM.run {\r\n  r.table('test').changes.em_run($conn, Printer.new(5))\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```\r\n{\"old_val\"=>nil, \"new_val\"=>{\"id\"=>\"07cb420f-905b-4cbf-bd82-b4885babe1e1\"}}\r\n{\"old_val\"=>nil, \"new_val\"=>{\"id\"=>\"4517ba6d-5511-405d-8991-682ca0a375fd\"}}\r\n{\"old_val\"=>nil, \"new_val\"=>{\"id\"=>\"c5f1074e-7a72-403c-bfe9-9d7d7de4a2e9\"}}\r\n{\"old_val\"=>nil, \"new_val\"=>{\"id\"=>\"f41daf81-fa00-40be-97e8-bba02fedd9ae\"}}\r\n{\"old_val\"=>nil, \"new_val\"=>{\"id\"=>\"1975449c-9cd7-4a3b-b027-1b9bdabf1299\"}}\r\n```\r\n\r\n#### Example 2: stopping a changefeed based on another changefeed\r\n\r\n```rb\r\nclass Printer < RethinkDB::Handler\r\n  def on_val(val)\r\n    p val\r\n  end\r\nend\r\n\r\nEM.run {\r\n  printer = Printer.new\r\n  r.table('test').changes.em_run($conn, Printer)\r\n  r.table('commands').changes['new_val']['stop'].em_run($conn) {|should_stop|\r\n    printer.stop if should_stop\r\n  }\r\n}\r\n```\r\n\r\nWill print changes to the table `test` until you run\r\n`r.table('commands').insert({stop: true})`.\r\n\r\n## Closing a QueryHandle\r\n\r\n`em_run` returns a `QueryHandle`.  Calling `close` on that\r\n`QueryHandle` will close it and interrupt any outstanding queries\r\nassociated with the `QueryHandle`.\r\n\r\n#### Example 1: Printing the first 3 elements of a table\r\n\r\n```rb\r\nr.table('test').insert((0...10).map{|i| {id: i}}).run\r\nEM.run {\r\n  printed = 0\r\n  handle = r.table('test').order_by(index: 'id').em_run($conn) {|res|\r\n    printed += 1\r\n    if printed > 3\r\n      handle.close\r\n    else\r\n      p res\r\n    end\r\n  }\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```rb\r\n{\"id\"=>0}\r\n{\"id\"=>1}\r\n{\"id\"=>2}\r\n```\r\n\r\n#### Example 2: Aborting a long-running query\r\n\r\n```rb\r\nr.table('test').insert({id: 0}).run($conn)\r\np r.table('test').get(0).run($conn)\r\nsleep = \"x = (new Date()).getTime(); while ((new Date()).getTime() < x + 1000) { }\"\r\nslow1 = r.js(sleep).do(1)\r\nEM.run {\r\n  h = r.table('test').get(0).update({a: slow1}, non_atomic: true).em_run($conn) { }\r\n  h.close\r\n  EM.stop\r\n}\r\np r.table('test').get(0).run($conn)\r\n```\r\n\r\nWill print:\r\n\r\n```rb\r\n{\"id\"=>0}\r\n{\"id\"=>0}\r\n```\r\n\r\n## Multiple Queries with One Handler\r\n\r\nIt's possible to register multiple queries with one `Hanlder`.  If you\r\ndo this and you want to know which query is calling a method on your\r\nhandler, you can define that method to take an addition argument,\r\nwhich will be set to the appropriate `QueryHandle`.\r\n\r\n#### Example 1: Printing changes to multiple tables\r\n\r\n```rb\r\nclass Printer < RethinkDB::Handler\r\n  def on_open(handle)\r\n    p [:open, $names[handle]]\r\n  end\r\n  def on_close(handle)\r\n    @closed = @closed.to_i + 1\r\n    p [:close, $names[handle]]\r\n    EM.stop if @closed == 2\r\n  end\r\n  def on_val(val, handle)\r\n    p [:val, val, $names[handle]]\r\n  end\r\nend\r\n\r\nEM.run {\r\n  printer = Printer.new\r\n  h1 = r.expr(1).em_run($conn, printer)\r\n  h2 = r.expr(2).em_run($conn, printer)\r\n  $names = {h1 => \"h1\", h2 => \"h2\"}\r\n}\r\n```\r\n\r\nWill print:\r\n\r\n```\r\n[:open, \"h1\"]\r\n[:val, 1, \"h1\"]\r\n[:close, \"h1\"]\r\n[:open, \"h2\"]\r\n[:val, 2, \"h2\"]\r\n[:close, \"h2\"]\r\n```\r\n"
  , issueCommentId = 78790839
  }