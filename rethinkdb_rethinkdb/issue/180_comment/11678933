IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-25) 23 : 42 : 25 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 43867
        , simpleUserLogin = N "jdoliner"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/43867?v=3"
        , simpleUserUrl = "https://api.github.com/users/jdoliner"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11678933"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/180#issuecomment-11678933"
  , issueCommentCreatedAt = 2012 (-12) (-25) 23 : 42 : 25 UTC
  , issueCommentBody =
      "Ahh, so this actually has nothing to do with the CAP theorem. Availability isn't lost because of the distributed nature of the system but rather due to races that occurring between modification of the semilattices and accessing from different threads (which happens due to rapidly creating new connections). Here's a concrete ordering that could lead to this. \r\n\r\n(I need some line numbers to reference.)\r\n\r\n    1: loop do\r\n    2:  r.connect\r\n    3:  try { r.table('test').insert(:field1 => 'world', :field2 => nil) }\r\n    4:  try { r.db_drop('test') }\r\n    5:  try { r.table('test').count }\r\n    6:end\r\n\r\nIn the first run through the loop it creates a table from the call to `try` originating at line 3. It then deletes the table, from line 4 and recreates it from line 5. The loop then completes. We now loop through and create a new connections on line 2. This connection is for performance reasons placed on a different thread than the previous one. Because semilattice changes are propagated to threads in a lazy way this connection could get to the new thread and send traffic before news of the deletion and recreation of the table has reached it. Thus this query attempts to access the masters for the old table which have been taken down due to the deletion.\r\n\r\nSo the practical answer to your question is that since this code basically depends on successive meta queries being able to see each others modifications you should use one connection for it. Using a single connection is the only way to guarantee that you can read your own write.\r\n\r\nWe could in theory fix this problem for the single node case by doing a synchronization between threads on changes like this. To me that seems a bit unnecessary since it complicates things code wise, and is a performance hit, although creating/deleting a table is a somewhat heavyweight operation so it's not a huge addition.\r\nHowever I also think there is some cost to adding complexity to the atomicity rules about connections, we can't fix this problem in general, 2 connections to different nodes basically have to exhibit this problem. So I think our current policy that if you use the same connection you can read your own write (including admin \"writes\") and if you use multiple ones we don't offer that guarantee is good because of its simplicity. Also as @nviennot points out we probably do have bigger fish to fry."
  , issueCommentId = 11678933
  }