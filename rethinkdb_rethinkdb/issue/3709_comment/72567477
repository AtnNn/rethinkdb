IssueComment
  { issueCommentUpdatedAt = 2015 (-02) (-03) 00 : 18 : 19 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 265071
        , simpleUserLogin = N "kofalt"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/265071?v=3"
        , simpleUserUrl = "https://api.github.com/users/kofalt"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/72567477"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3709#issuecomment-72567477"
  , issueCommentCreatedAt = 2015 (-02) (-03) 00 : 18 : 19 UTC
  , issueCommentBody =
      "That seems reasonable. To be clear, its sounds like the resultant usage would be:\r\n\r\n1. Set an optarg, `mark_ready` or something, on a query with `.changes()`\r\n1. Handle documents lacking a `ready` key as a query result (extracting from `new_val` key)\r\n1. Read a document with a `ready` key, discard\r\n1. Handle all future documents as a changefeed event (with `new_val` and `old_val` keys).\r\n\r\nWhich does not require the database know which is the final document in a query result, does not block on change events for a client to know the full result set, and also handles the case of no results.\r\n\r\nAs a bonus, aside from extracting the `new_val` key in step 2, you can pretty much use identical code to process query results with or without changefeeds."
  , issueCommentId = 72567477
  }