IssueComment
  { issueCommentUpdatedAt = 2015 (-02) (-10) 19 : 40 : 37 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 552910
        , simpleUserLogin = N "Tryneus"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/552910?v=3"
        , simpleUserUrl = "https://api.github.com/users/Tryneus"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/73768567"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2705#issuecomment-73768567"
  , issueCommentCreatedAt = 2015 (-02) (-10) 19 : 40 : 37 UTC
  , issueCommentBody =
      "So, I just ran into this while trying some very stupid queries like:\r\n\r\n```\r\nr.expr([]).run(array_limit=r.table('fake').count())\r\n```\r\n - Results in a sanity check failure: `[dbv.has()]` (rdb_protocol/terms/db_table.cc:587)\r\n```\r\nr.expr([]).run(array_limit=r.db('test').table('exists').count())\r\n```\r\n - Results in an assert failure on each shard contacted: `[rget.optargs.size() != 0]` (rdb_protocol/store.cc:475)\r\n\r\nI think these could be easily solved by preprocessing global optargs similar to the main term tree, and disallowing write and meta ops (which is probably what we want in the first place).  For the moment I'm OK with leaving the optargs as functions, there are some reasons users might want that."
  , issueCommentId = 73768567
  }