IssueComment
  { issueCommentUpdatedAt = 2016 (-04) (-21) 12 : 04 : 39 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 26637
        , simpleUserLogin = N "soplakanets"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/26637?v=3"
        , simpleUserUrl = "https://api.github.com/users/soplakanets"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/212884842"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5548#issuecomment-212884842"
  , issueCommentCreatedAt = 2016 (-04) (-21) 12 : 04 : 22 UTC
  , issueCommentBody =
      "Hi, I'm having an issue with sorting by random also. The stacktrace:\r\n\r\n```\r\n2016-04-21T08:01:10.678165622 43.918828s error: Error in src/rdb_protocol/datum.cc at line 1475:\r\n2016-04-21T08:01:10.678263985 43.918923s error: Unreachable code:\r\n2016-04-21T08:01:10.678282800 43.918941s error: Backtrace:\r\n2016-04-21T08:01:10.894402209 44.135066s error: Thu Apr 21 08:01:10 2016\\n\\n1 [0xa5ce10]: backtrace_t::backtrace_t() at ??:?\\n2 [0xa5d1a3]: format_backtrace(bool) at ??:?\\n3 [0xc9f6b5]: report_fatal_error(char const*, int, char const*, ...) at ??:?\\n4 [0x8db1d6]: void ql::datum_t::write_json_unchecked_stack<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::RAllocator> >(rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::RAllocator>*) const at ??:?\\n5 [0x8dc1fa]: void ql::datum_t::write_json<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::RAllocator> >(rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::RAllocator>*) const at ??:?\\n6 [0x8dae43]: void ql::datum_t::write_json_unchecked_stack<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::RAllocator> >(rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::RAllocator>*) const at ??:?\\n7 [0x8dc1fa]: void ql::datum_t::write_json<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::RAllocator> >(rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::RAllocator>*) const at ??:?\\n8 [0xa52750]: write_response_internal(ql::response_t*, rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::RAllocator>*, bool) at ??:?\\n9 [0xa574a8]: query_server_t::handle(http_req_t const&, http_res_t*, signal_t*) at ??:?\\n10 [0x9c627d]: routing_http_app_t::handle(http_req_t const&, http_res_t*, signal_t*) at ??:?\\n11 [0x9c627d]: routing_http_app_t::handle(http_req_t const&, http_res_t*, signal_t*) at ??:?\\n12 [0x9cff34]: http_server_t::handle_conn(scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t) at ??:?\\n13 [0x9d34e4]: std::_Function_handler<void (scoped_ptr_t<linux_tcp_conn_descriptor_t>&), boost::_bi::bind_t<void, boost::_mfi::mf2<void, http_server_t, scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t>, boost::_bi::list3<boost::_bi::value<http_server_t*>, boost::arg<1>, boost::_bi::value<auto_drainer_t::lock_t> > > >::_M_invoke(std::_Any_data const&, scoped_ptr_t<linux_tcp_conn_descriptor_t>&) at ??:?\\n14 [0x969b6c]: linux_nonthrowing_tcp_listener_t::handle(int) at ??:?\\n15 [0x9819f8]: coro_t::run() at ??:?\r\n2016-04-21T08:01:10.894879411 44.135538s error: Exiting.\r\n```\r\n\r\nThe query is quite complicated, used it while sifting through data, don't think any sane person should do this in production, but still... \r\n\r\n\r\n```\r\nvar startDate = new Date(2016, 8, 1);\r\nvar endDate = new Date(2016,9,31);\r\nvar start = r.time(startDate.getUTCFullYear(), startDate.getUTCMonth() + 1, startDate.getUTCDate(), 0, 0, 0, 'Z');\r\nvar end = r.time(endDate.getUTCFullYear(), endDate.getUTCMonth() + 1, endDate.getUTCDate(), 23, 59, 59, 'Z');\r\nr.db('dbName').table(\"tableName\").concatMap(function(D) {\r\n          return D('schedule').merge({\r\n            id: D('id'),\r\n            realWishlistedCount: D('realWishlistedCount').default(0),\r\n            destinationId: D('destinationId')\r\n          })\r\n        })\r\n        .filter(r.row('realWishlistedCount').gt(0)) // only show those at least 2 users have wishlisted\r\n        .filter(function(D) {\r\n           return r.or(\r\n             // case 1: date range is smaller than reason's range\r\n             r.expr(start).during(D('start'), D('end'), {leftBound: 'open', rightBound: 'open'})\r\n                .or(r.expr(end).during(D('start'), D('end'), {leftBound: 'open', rightBound: 'open'}))\r\n             // case 2: reason's range is smaller than date range\r\n           , D('start').during(start, end, {leftBound: 'open', rightBound: 'open'})\r\n                .or(D('end').during(start, end, {leftBound: 'open', rightBound: 'open'}))\r\n            );\r\n        })\r\n        .group('id')\r\n        .max('realWishlistedCount')\r\n        .ungroup()\r\n        .map(function(D) {\r\n          return {\r\n            reasonId: D('group'),\r\n            destinationId: D('reduction')('destinationId'),\r\n            score: D('reduction')('realWishlistedCount')\r\n          }\r\n        })\r\n.orderBy(function () { return r.random(); })\r\n```"
  , issueCommentId = 212884842
  }