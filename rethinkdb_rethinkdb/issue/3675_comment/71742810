IssueComment
  { issueCommentUpdatedAt = 2015 (-01) (-27) 22 : 43 : 20 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1366
        , simpleUserLogin = N "deontologician"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1366?v=3"
        , simpleUserUrl = "https://api.github.com/users/deontologician"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/71742810"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3675#issuecomment-71742810"
  , issueCommentCreatedAt = 2015 (-01) (-27) 22 : 34 : 44 UTC
  , issueCommentBody =
      "In the #2032 issue I see mostly discussion about the fact that grouped data converted to json looks the same as ungrouped data converted to json. This is a separate issue, though. We could still maintain a different representation between grouped and ungrouped data.\r\n\r\nThe other issue that @Tryneus brought up in that thread is that without it being a key, you lose random access to groups. That's a downside of the javascript representation, but I think it's an ok tradeoff to make. Generally if you're grouping something, you're going to want to touch more than one group anyway. If not you'd be doing a filter.\r\n\r\nAnother way to look at it is that javascript isn't the exception here in having problems with this representation, all static languages will have the same problems javascript is having. So really, it's *just* python and ruby that can accommodate this (and I'd argue that python really doesn't accommodate it well, and even though Ruby allows mutable objects as keys [it's a bad idea](http://jafrog.com/2012/10/07/mutable-objects-as-hash-keys-in-ruby.html))"
  , issueCommentId = 71742810
  }