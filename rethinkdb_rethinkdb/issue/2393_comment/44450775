IssueComment
  { issueCommentUpdatedAt = 2014 (-05) (-28) 19 : 05 : 05 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/44450775"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2393#issuecomment-44450775"
  , issueCommentCreatedAt = 2014 (-05) (-28) 19 : 05 : 05 UTC
  , issueCommentBody =
      "Let me first describe more precisely what we are talking about here:\r\n\r\nAt the beginning of a backfill operation, the backfiller sends a list of all secondary indexes that exist on the backfilled table to the backfillee.\r\n\r\nThe backfillee compares that list to the secondary indexes that already exist on its side, drops the ones that are not in the list, and creates the ones that are in the list but don't exist on its side yet. This initiates secondary index post construction for the new indexes.\r\n\r\nAt the same time, the backfiller also starts sending data over to the backfillee.\r\n\r\nThere are two cases that can be distinguished:\r\n1. The backfillee already was a replica for a shard of that table. In that case, it will already have the right set of secondary indexes, unless the secondary indexes have been changed recently and it hasn't heard about it yet. A common case where this will happen is if the backfillee is a secondary that has been down. When the user creates a secondary index on the primary while the secondary is down, and the secondary comes back up, it will have to create the index as part of the backfill process.\r\n2. The backfillee didn't have any responsibility for the table. In that case, all secondary indexes will be created. However they will be created on an empty table, so the post construction should be fast.\r\n\r\nThe scenario that I tested was the second one. The node didn't have any prior responsibility for the table. The problem therefore appeared to be that it started postconstructing on an empty table, but before it could finish, data started to come in from the backfiller and it never caught up.\r\n\r\nIn the second case, it definitely would make sense to wait for postconstruction to complete before starting to backfill. It will only take something like a second.\r\nIn the first case it probably still makes sense. If the backfill finishes but the index isn't there yet, the replica will not be fully usable for all queries since the secondary index on it is not ready. That will lead to inconsistent query results for outdated queries that try to use the index (sometimes it will work, other times it won't). If the primary fails while the secondary is still constructing the index, the index will become completely inaccessible, which might come as a surprise for the user (after all the user sees that they have an otherwise working replica).\r\n\r\n@coffeemug If a user creates a new secondary index *while* a backfill is in progress, that will indeed lead to the same performance problem again.\r\n\r\n\r\nHere's an alternative way to fix this and some other related problems:\r\nWe can try to scale the relative priority of secondary index post construction based on the growth rate of the secondary index queue.\r\nIf new writes are added to the secondary index queue, faster than post construction is processing existing data (either from the primary tree or from the other end of the queue), we can start throttling writes to the secondary index queue and give secondary index post construction a higher priority (in terms of yielding less often).\r\nOf course there should be some leeway there. We would have to come up with a robust scheme of how to do this.\r\n\r\nAs a third (and best, but maybe difficult) solution, we should implement https://github.com/rethinkdb/rethinkdb/issues/2134 to get rid of the overhead that secondary index post construction incurs altogether."
  , issueCommentId = 44450775
  }