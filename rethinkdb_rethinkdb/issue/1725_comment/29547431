IssueComment
  { issueCommentUpdatedAt = 2013 (-11) (-30) 07 : 19 : 26 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/29547431"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1725#issuecomment-29547431"
  , issueCommentCreatedAt = 2013 (-11) (-30) 07 : 19 : 26 UTC
  , issueCommentBody =
      "I was thinking of `split` having semantics where the only legal operations on the value in the variable are reductions (`sum` etc. count as reductions for this).  This constraint will let us have an efficient implementation because we won't have to deal with cases like `table.do{|t| t.map{|row| row.merge({count: t.count})}`.  Handling that case correctly would require loading the entire table into memory, or else using different values for `t` both times it's referenced.  By contrast, if we have a term `split` and only allow reductions on the bound \"stream\", we only have to load a single batch into memory at once to feed all the reductions.\r\n\r\nThis is in subsequent, though, so let's avoid getting too deep into it right now."
  , issueCommentId = 29547431
  }