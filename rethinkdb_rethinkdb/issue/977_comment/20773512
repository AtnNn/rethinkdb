IssueComment
  { issueCommentUpdatedAt = 2013 (-07) (-10) 21 : 09 : 37 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 258437
        , simpleUserLogin = N "srh"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/258437?v=3"
        , simpleUserUrl = "https://api.github.com/users/srh"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/20773512"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/977#issuecomment-20773512"
  , issueCommentCreatedAt = 2013 (-07) (-10) 21 : 09 : 37 UTC
  , issueCommentBody =
      "> (Note that epoch time is in UTC.  We will use negative numbers for\r\n> sufficiently ancient dates.)\r\n\r\nCan the epoch_time have a fractional part?  It's just a double, right?\r\n\r\n* Durations will be a pseudo-type of the form:\r\n```ruby\r\n{:$__reql_type__ => 'duration', :iso8601 => 'P0003-06-04T12:30:05'}\r\n```\r\n(If we can get our ISO 8601 library to 0-pad, which will make sorting\r\neasier.  Otherwise they will be not zero-padded.)\r\n\r\n> We will implement the following functions:\r\n> * Arithmetic\r\n>   - `time + duration => time`\r\n>   - `duration + duration => duration`\r\n>   - `time - time => duration`\r\n>   - `time - duration => time`\r\n>   - `duration - duration => duration`\r\n\r\nHow does the arithmetic work?  If you add 1 year to\r\n2003-05-01T00:00:00, do you get 2004-05-01T00:00:00 (meaning we\r\nadded 366 days because we added one year which crossed over a leap\r\nday -- we merely incremented the year field).  If you add 1 year to\r\n2004-02-29T00:00:00, what happens?  Do you get 2005-03-01T00:00:00?\r\nIf you subtract 1 year from 2005-03-01T00:00:00, what happens?  Do\r\nyou get 2004-03-01T00:00:00?\r\n\r\nDo we support negative durations?  What happens if you subtract a\r\nlater time from an earlier time?\r\n\r\nIf you subtract 2004-05-01T00:00:00 - 2003-05-01T00:00:00, what do\r\nyou get?  Do you get P1Y, do you get P366D, or what?\r\n\r\nIf you add a duration of P6M to 2005-06-01T00:00:00 -07:00, will you\r\nget 2005-12-01T00:00:00 -07:00?  What if you're in California?  The\r\ntimezone component is now wrong because you're in standard time.  So\r\nif you convert it to standard time, you suddenly have\r\n2005-11-30T23:00:00 -08:00.\r\n\r\nYou should note that C# has its TimeSpan type only refer to time in\r\ndays, hours, minutes, seconds, and a fractional part -- really the\r\ntime is specified in 100-millisecond units.  This is eliminates the\r\nheadaches above.  What are the arguments against merely specifying\r\nduration in a floating point number of seconds?\r\n\r\n> * Predicates\r\n>   - `time.during(start_time, end_time) => bool`\r\n>   - `time.during(start_time, duration) => bool`\r\n>   - `time.during(duration, end_time) => bool`\r\n\r\nThe behavior of this needs to be more precisely defined.  Are the\r\ntime intervals here half-open?  (They should be, generally speaking\r\ntime is half-open, e.g. midnight is part of the subsequent day, and\r\ndoes not belong to two days.)\r\n\r\n> * Portion Retrieval\r\n>  - `time.timezone() => {string/null}`\r\n\r\nWhat string does timezone() return?  \"-06:00\", \"+01:00\", and the like?  Those are not time zones.  They are time offsets.  If we're going to use time offsets we shouldn't use the word \"time zone\" (or \"zone\") anywhere in the interface.\r\n\r\n> * Construction\r\n>  - `r.time(year, month, day, hour, minute, second, timezone) => time`\r\n>   - `r.time(year, month, day, hour, minute, second) => time`\r\n>   - `r.time(year, month, day) => time`\r\n>   - I expect 99% of users to use native time types, and 99% of drivers\r\n>   to send native time types to the server with `r.iso8601`, so I'm not\r\n>   sure how important these are.\r\n\r\nYou can't construct a native date mid-query.  Many languages don't have native date types.\r\n\r\n> * Convenience\r\n>   - `r.monday ... r.sunday`\r\n>   - `r.january ... r.december`\r\n>   - `r.now => time` (current time with client's time zone)\r\n>   - `r.now(:timezone => timezone) => time` (current time with\r\n>   arbitrary time zone)\r\n>   - `r.now(:timezone => nil) => time` (current time with no time zone)\r\n>   - Clients will also be responsible for converting native time\r\n>   objects to the most appropriate time type.\r\n\r\nWhat does `r.monday` do?\r\n\r\nWhat does `r.january` do?\r\n\r\n`r.now` should not default to the client's timezone.  Why should the\r\nbehavior of this function depend on where in the world the client\r\nEC2 node (or whatever) is?  Nobody writing a sane application is\r\ngoing to want this behavior.  r.now should return the UTC time with\r\nUTC timezone.\r\n\r\nWhat does \"Clients will also be responsible for converting native\r\ntime objects to the most appropriate time type.\" mean?  Are you\r\ntalking about the driver implementer being responsible for doing\r\nthis right?\r\n\r\n> * Notes on ISO 8601.\r\n>   - We will treat dates ending with 60 seconds as one second after 59\r\n>   seconds, despite the drawbacks.\r\n\r\nI don't know what this means.  Are we supporting leap seconds?  Not?\r\nOur epoch time is \"in UTC\" according to the beginning of the proposal.\r\nWhat does that mean?  (Is our epoch_time really in Unix or POSIX time, with respect to the unix\r\nepoch, and it does not know or care about leap seconds?  Does this correspond with other time-since-epoch values that users are likely to use?)  So there is no epoch time that\r\nconverts to a time with :60 at the end?\r\n\r\nWhat if there are two leap seconds in a minute?  How should :61 be treated?\r\n\r\n>  - We should try to 0-pad when we print, especially for durations.\r\n\r\nPrint?  What is printing, where does this happen, and what is its behavior defined to be?"
  , issueCommentId = 20773512
  }