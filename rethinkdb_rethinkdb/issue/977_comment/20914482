IssueComment
  { issueCommentUpdatedAt = 2013 (-07) (-13) 04 : 21 : 33 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/20914482"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/977#issuecomment-20914482"
  , issueCommentCreatedAt = 2013 (-07) (-13) 04 : 21 : 33 UTC
  , issueCommentBody =
      "Alright, here's an updated proposal, with some notes to address Sam's questions.  Note that I slimmed down some -- after talking with people and looking at the amount of work to be done, I think that we should do the bare minimum to produce a time library that is usable and won't screw people.  For instance, I cut the iso8601 durations; we'll use a double representation of seconds for durations right now, and if we later want to support things like \"add one calendar year to this\", we can add either a new pseudotype or a new function to support that.\r\n\r\nSome answers that aren't answered in the new proposal:\r\n* I think we should use the name \"timezone\" because ISO 8601 talks about \"Time zone designators\".  Even if we currently only support time offsets from UTC, we may want to add support for e.g. EST (as @spiffytech noted) at some point in the future.\r\n* We are basically ignoring leap seconds for the moment, because fuck 'em.  We need to support seconds [0,60] for ISO 8601 parsing, but not second 61 because ISO 8601 says \"[ss] refers to a zero-padded second between 00 and 60 (where 60 is only used to notate an added leap second)\".  If we later really need to support them, we can add another field to the pseudotype or something.\r\n* I think it only makes sense for `r.now` to use the client's timezone.  Why would you change the timezone to UTC on them?\r\n\r\n* Times will be a pseudo-type of the form:\r\n```ruby\r\n{:$__reql_type__ => 'time', :epoch_time => 1908201939.234, :timezone => '-06:00'}\r\n```\r\n(Note that epoch time is in UTC, and fractional seconds are allowed.  We will use negative numbers for\r\nsufficiently ancient dates.)\r\n\r\n* Durations will be just be doubles representing the number of seconds.  Fractional seconds are allowed.\r\n\r\nWe will implement the following functions:\r\n* Arithmetic\r\n  - `time + duration => time`\r\n  - `time - time => duration`\r\n  - `time - duration => time`\r\n\r\n* Comparisons\r\n  - `time {</<=/>/>=/==/!=} time => bool`  Times are a pseudotype.  They compare to other types as if they had the type \"PSEUDO_TYPE(TIME)\" (i.e. they fall between Object and String in our type ordering).  They compare to each other with proper temporal ordering.\r\n\r\n* Predicates\r\n  - `time.during(start_time, end_time) => bool`  People who want `time.during(start_time, duration)` can write `time.during(start_time, start_time + duration)`.  Note that this is half-open (just as `slice` and `between` will be for this release).\r\n\r\n* Time Zone Manipulation\r\n  - `time.in_timezone(iso8601_timezone) => time` (The same actual\r\n  time, just in a different time zone.  Does not change the\r\n  `epoch_time` field.)\r\n  - `time.in_timezone(nil) => time` (strips the time zone)\r\n  - All operations involving more than one time are valid if all times\r\n  have a time zone, or if no time has a time zone.  If some but not all\r\n  times have a time zone, we return an error to the user recommending\r\n  that they use `in_timezone`.\r\n\r\n* Portion Retrieval\r\n  - `time.date() => time`\r\n  - `time.time_of_day() => duration`\r\n  - `time.timezone() => {string/null}`\r\n  - `time.year => number`\r\n  - `time.month => number` (1-12)\r\n  - `time.day => number` (1-366)\r\n  - `time.weekday => number` (1-7, starting on Monday per. ISO 8601)\r\n  - `time.hour => number` (0-23)\r\n  - `time.minute => number` (0-59)\r\n  - `time.second => number` (0-59.999, double)\r\n\r\n* Construction\r\n  - `r.time(year, month, day, hour, minute, second, timezone) => time`\r\n  - `r.time(year, month, day, hour, minute, second) => time`\r\n  - `r.time(year, month, day, timezone) => time`\r\n  - `r.time(year, month, day) => time`\r\n  - I expect 99% of users to use native time types, and 99% of drivers\r\n  to send native time types to the server with `r.iso8601` or `r.epoch_time`, so I'm not\r\n  sure how important these are.  Note that our three main drivers all have native time types that you can construct mid-query.\r\n\r\n* Convenience\r\n  - `r.monday ... r.sunday` (these return 1..7)\r\n  - `r.january ... r.december` (these return 1..12)\r\n  - `r.now => time` (current time with client's time zone)\r\n  - `r.now(:timezone => timezone) => time` (current time with\r\n  arbitrary time zone)\r\n  - `r.now(:timezone => nil) => time` (current time with no time zone)\r\n  - Clients will also be responsible for converting native time\r\n  objects to the most appropriate time type (e.g. if the language always stores times in UTC, it should produce a time in the UTC timezone).\r\n\r\n* Conversion\r\n  - `time.to_iso8601() => string`\r\n  - `duration.to_iso8601() => string`\r\n  - `time.to_epoch_time() => number`\r\n  - `r.iso8601(string) => {time/duration}` (modeled after `r.json`)\r\n  - `r.epoch_time(number) => time`\r\n\r\n* Notes on ISO 8601.\r\n  - We will treat dates ending with 60 seconds as one second after 59\r\n  seconds, despite the drawbacks.\r\n  - We will try to be as liberal as the parser we find allows, except\r\n  where this results in ambiguity."
  , issueCommentId = 20914482
  }