IssueComment
  { issueCommentUpdatedAt = 2014 (-08) (-04) 23 : 07 : 47 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 258437
        , simpleUserLogin = N "srh"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/258437?v=3"
        , simpleUserUrl = "https://api.github.com/users/srh"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/51130076"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2797#issuecomment-51130076"
  , issueCommentCreatedAt = 2014 (-08) (-04) 23 : 07 : 47 UTC
  , issueCommentBody =
      "> we have to worry about backwards compatibility. So this might actually be an advantage of option 2.\r\n\r\nIt wouldn't be.  The reason is, if we duplicate an older index on a newer version of RethinkDB (which is the point of this command), we would still have that problem in all the same places.\r\n\r\n> Currently export/import has the shortcoming that secondary indexes are lost, and if we're going to implement this fix, I'd like the solution to allow us to fix this behavior.\r\n\r\nWe can do this by serializing the cluster_version_t for the serialization format and the reql_version_t (which you'll see in an upcoming code review for sam_2789_disk_structure) to describe the reql evaluation behavior (which is *not* what the reql version would be in the new secondary index -- the value only means the secondary index creation will balk if there are intentional semantic differences in the behavior if reql.  I think this might never happen because this is the sort of thing we'd use a new TermType number for.)"
  , issueCommentId = 51130076
  }