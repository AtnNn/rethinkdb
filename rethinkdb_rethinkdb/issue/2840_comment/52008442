IssueComment
  { issueCommentUpdatedAt = 2014 (-08) (-13) 04 : 26 : 06 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/52008442"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2840#issuecomment-52008442"
  , issueCommentCreatedAt = 2014 (-08) (-13) 04 : 24 : 00 UTC
  , issueCommentBody =
      "Valgrind provided a couple of these:\r\n```\r\n==25808== Thread 13:\r\n==25808== Invalid read of size 8\r\n==25808==    at 0x175EBF7: blob::region_tree_filler_t::operator()(int) const (blob.cc:391)\r\n==25808==    by 0x17620C1: pmap_runner_one_arg_t<blob::region_tree_filler_t, int>::operator()() (pmap.hpp:22)\r\n==25808==    by 0x1760CF4: void throttled_pmap<blob::region_tree_filler_t>(int, int, blob::region_tree_filler_t const&, long) (pmap.hpp:97)\r\n==25808==    by 0x175F4F3: void throttled_pmap<blob::region_tree_filler_t>(int, blob::region_tree_filler_t const&, long) (pmap.hpp:103)\r\n==25808==    by 0x175CE32: blob::make_tree_from_block_ids(buf_parent_t, access_t, int, long, long, unsigned long const*) (blob.cc:425)\r\n==25808==    by 0x175CC2B: blob_t::expose_region(buf_parent_t, access_t, long, long, buffer_group_t*, blob_acq_t*) (blob.cc:343)\r\n==25808==    by 0x175CCF7: blob_t::expose_all(buf_parent_t, access_t, buffer_group_t*, blob_acq_t*) (blob.cc:360)\r\n==25808==    by 0x1B50300: rdb_blob_wrapper_t::expose_all(buf_parent_t, access_t, buffer_group_t*, blob_acq_t*) (blob_wrapper.cc:40)\r\n==25808==    by 0x19DF35C: get_data(rdb_value_t const*, buf_parent_t) (lazy_json.cc:18)\r\n==25808==    by 0x19DF525: lazy_json_t::get() const (lazy_json.cc:30)\r\n==25808==    by 0x18F897B: rget_cb_t::handle_pair(scoped_key_value_t&&, concurrent_traversal_fifo_enforcer_signal_t) (btree.cc:910)\r\n==25808==    by 0x2013CE0: concurrent_traversal_adapter_t::handle_pair_coro(scoped_key_value_t*, semaphore_acq_t*, fifo_enforcer_write_token_t, auto_drainer_t::lock_t) (concurrent_traversal.cc:62)\r\n==25808==  Address 0x21117871 is 2,673 bytes inside a block of size 4,096 free'd\r\n==25808==    at 0x4C2A82E: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==25808==    by 0x1767CB6: scoped_malloc_t<ser_buffer_t>::~scoped_malloc_t() (scoped.hpp:253)\r\n==25808==    by 0x1767D26: scoped_malloc_t<ser_buffer_t>::reset() (scoped.hpp:277)\r\n==25808==    by 0x176763F: buf_ptr_t::reset() (buf_ptr.hpp:44)\r\n==25808==    by 0x1766976: alt::page_t::evict_self(alt::page_cache_t*) (page.cc:533)\r\n==25808==    by 0x17757FE: alt::evicter_t::evict_if_necessary() (evicter.cc:218)\r\n==25808==    by 0x177554B: alt::evicter_t::change_to_correct_eviction_bag(alt::eviction_bag_t*, alt::page_t*) (evicter.cc:163)\r\n==25808==    by 0x1765F6D: alt::page_t::add_waiter(alt::page_acq_t*, cache_account_t*) (page.cc:404)\r\n==25808==    by 0x1766C7E: alt::page_acq_t::init(alt::page_t*, alt::page_cache_t*, cache_account_t*) (page.cc:571)\r\n==25808==    by 0x176E20E: buf_read_t::get_data_read(unsigned int*) (alt.cc:766)\r\n==25808==    by 0x175D072: blob::expose_tree_from_block_ids(buf_parent_t, access_t, int, long, long, temporary_acq_tree_node_t*, blob::touches_end_t, buffer_group_t*, blob_acq_t*) (blob.cc:464)\r\n==25808==    by 0x175CC89: blob_t::expose_region(buf_parent_t, access_t, long, long, buffer_group_t*, blob_acq_t*) (blob.cc:353)\r\n```\r\n\r\nAs you can see we evicted a buffer before reading the blob it contains. The code uses `scoped_key_value_t`. That class looks like this:\r\n```\r\nclass scoped_key_value_t {\r\npublic:\r\n  ...\r\nprivate:\r\n    const btree_key_t *key_;\r\n    const void *value_;\r\n    movable_t<counted_buf_lock_t> buf_;\r\n};\r\n```\r\n\r\nIn this case the `value_` pointer points to some value inside of the buf_. As you can see further, `scoped_key_value_t` has a `counted_buf_lock_t` on the buffer. However that is not enough. We only guarantee keeping buffers in memory while either a `buf_read_t` or a `buf_write_t` exists on the buffer. Just holding the lock is not enough to keep the buffer from being evicted.\r\n\r\nI will change scoped_key_value_t to also contain the buf_read_t that was used to get the `value_` pointer in the first place."
  , issueCommentId = 52008442
  }