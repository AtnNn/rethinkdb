IssueComment
  { issueCommentUpdatedAt = 2014 (-12) (-16) 03 : 27 : 53 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1366
        , simpleUserLogin = N "deontologician"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1366?v=3"
        , simpleUserUrl = "https://api.github.com/users/deontologician"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/67107113"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3439#issuecomment-67107113"
  , issueCommentCreatedAt = 2014 (-12) (-16) 03 : 23 : 40 UTC
  , issueCommentBody =
      "So, is there a use-case as a belt-and-suspenders kind of mitigation? Say someone does in fact use an insecure deserializer like pickle or yaml, is there a role for such a term so that query writers can find surprises?\r\n\r\nSay an ORM writer is the one really writing the ReQL terms, and a completely different developer is the one using the ORM, and does something insecure, not knowing the limitations. If we had an `r.const` term, it could act like an assertion that \"this is user data\" vs. \"this is a literal that was constructed by the query writer\""
  , issueCommentId = 67107113
  }