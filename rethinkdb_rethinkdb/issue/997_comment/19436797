IssueComment
  { issueCommentUpdatedAt = 2013 (-06) (-14) 02 : 47 : 54 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/19436797"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/997#issuecomment-19436797"
  , issueCommentCreatedAt = 2013 (-06) (-14) 02 : 47 : 54 UTC
  , issueCommentBody =
      "The 'yuck' comment was not about the idea of using JS actions within the server but about the hoops you'd have to jump through to get something meaningful out of a triggered JS action. This is what I was imagining when I first read the proposal:\r\n\r\n```python\r\nimport BaseHttpServer\r\n\r\nclass NewUserHandler(BaseHttpServer.BaseHttpRequestHandler):\r\n   def do_GET(request):\r\n      process_request(request)\r\n\r\nr.table('users').create_trigger('inserted', lambda row: True, r.js(\"\"\"function(newUser) {\r\nvar http = require('http');\r\nvar options = {\r\n  host: \"my_app_server.com\",\r\n  path: \"/new_user_event/?user=\"+JSON.stringify(newUser)\r\n};\r\n\r\nhttp.request(options);\r\n}\"\"\").run()\r\n\r\nBaseHttpServer.HttpServer((\"my_app_server.com\", 80), NewUserHandler).server_forever()\r\n```\r\n\r\nThis example assumes that what you really want to do is transfer control after an event back to the application server. Since this is where the application is running, I assume that this is where the user wants to get events. In order to produce an event, at least one client has to be running and interacting with the database so I would assume it's not any more difficult to have a second application process or thread waiting on these events.\r\n\r\nEven so, I appreciate that for some kinds of event handlers you might want to trigger an action within the database server. I'm imagining, in particular, the out of the box experience you might have playing with events in the data explorer. To play with triggers users shouldn't have to spin up a client process and have it listen for events.\r\n\r\nWe could build something into the web UI for events, similar to how we currently support a simplified UI for creating secondary indexes. We'd could then define a simple API for common actions so that you can easily script it and not have to go through all the steps I showed above just to send an HTTP request:\r\n\r\n```\r\n+----------------+\r\n| on insert   \\/ |\r\n+----------------+\r\n+----------------------------------------------------------+\r\n| function(new_doc) {                                         |\r\n|    var doc_string = JSON.stringify(new_doc);   |\r\n|    http.get(\"http://my_app/?doc=\"+doc_string); |\r\n|    fs.log(\"Inserted: \"+doc_string);                      |\r\n| }                                                                        |\r\n+----------------------------------------------------------+\r\n```\r\n\r\nFor more complex event handlers in larger and more complex systems that are already using multiple client processes and servers though, I think users would appreciate the the greater flexibility of an API that allowed them to easily transfer control back to a client server running one of the drivers.\r\n\r\nAlso, there's no reason why we can't support both kinds of event handlers. With the API I outlined, the body of the event handler (inside the for_each) can use a JS term to run some action. There are two open questions though with this approach that I can think of.\r\n\r\nFirst, we'd probably need a way for a client to create this persistent event handler and disconnect. This is not possible with the API as I first outlined it. We could get away with this though if we build support for this into the web ui. Alternatively, we could add a run option for a persistent query that continues running on the server for its side effects even after the client disconnects. Still, we'd need a way to cancel these events. Maybe such a query would return a query id which could later be used to cancel the query.\r\n\r\nThe second is how we move from embedded v8 to node. Without node we don't get file system API's etc. However we do this it will require mucking around in a pretty fragile part of the code base. We could, however, support the web UI based JS events I outlined with a separate external node process running the JS driver rather than supporting node within the embedded JS engine backing `r.js`.\r\n\r\nHonestly, if we don't bother yet trying to integrate node in place of embedded v8, this doesn't sound like it would be that hard to implement for 1.8 or 1.9 since most of the code is in the QL layer. At least one potential user I've talked to has indicated that this is the only missing feature he's waiting on. If this is really that doable in the near term, I think this would make a really killer feature (so please excuse my enthusiasm)."
  , issueCommentId = 19436797
  }