IssueComment
  { issueCommentUpdatedAt = 2014 (-04) (-04) 23 : 51 : 18 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 258437
        , simpleUserLogin = N "srh"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/258437?v=3"
        , simpleUserUrl = "https://api.github.com/users/srh"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/39622214"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/997#issuecomment-39622214"
  , issueCommentCreatedAt = 2014 (-04) (-04) 23 : 51 : 18 UTC
  , issueCommentBody =
      "> There's no guarantee that a stream is finite. \r\n\r\nThat's a bug in the implementation.\r\n\r\n> changes is no different than order_by in this respect; they both produce ordered streams.\r\n\r\nNo.  order_by returns a finite result set with a partial ordering, and changes returns an infinite result set with a partial ordering.\r\n\r\n>  if you're talking about what the client can do with the results of the stream,\r\n\r\nI'm not.  The difference is that changes intrinsically arrive in order and should be processed in order -- there's no way you could conceivably want to process them out of order.  With a result of an order_by, the ReQL command map does not have to process them in any particular order.\r\n\r\n> What part of the type system disallows it?\r\n\r\nAll the parts designed for finite result sets, any part not designed for processing a big hose of incoming writes that were splayed out to shards on different servers.\r\n"
  , issueCommentId = 39622214
  }