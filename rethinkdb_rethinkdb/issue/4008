Issue
  { issueClosedAt = Nothing
  , issueUpdatedAt = 2016 (-02) (-09) 07 : 20 : 20 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/4008/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/4008"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "0052cc"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:ReQL_proposal"
          , labelName = "tp:ReQL_proposal"
          }
      ]
  , issueNumber = 4008
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 519940
        , simpleUserLogin = N "elifarley"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/519940?v=3"
        , simpleUserUrl = "https://api.github.com/users/elifarley"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "TTL syntax suggestions"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/4008"
  , issueCreatedAt = 2015 (-04) (-02) 19 : 21 : 27 UTC
  , issueBody =
      Just
        "\r\nHere are some examples on how TTL can be used.\r\n\r\n\r\nDefines a default value of 1000 ms for TTL (but each document can have its own 'ttl' attribute),\r\ncreates a read-only attribute 'date-created' for every document and creates an index called 'date-created':\r\n```Javascript\r\ndb.tableCreate(\"foo\", {ttl: 1000} )\r\n\r\n// Uses an alternate index name:\r\ndb.tableCreate(\"foo\", {ttl: {'my-timestamp': 1000}} ) // ttl based on a user-created index named 'my-timestamp'\r\n```\r\n\r\n```Javascript\r\n// checks table-defined TTL (if there is one, like the above example) and returns a NOT-FOUND error if doc is too old\r\nr.table(\"foo\").get(1)\r\n\r\n// checks table-defined TTL (if there is one, like the above example) and returns only those documents that are not too old\r\nr.table(\"foo\").getAll('man_of_steel', {index:'code_name'})\r\n\r\noverriding a document's TTL:\r\n\r\n// If the doc doesn't have a column named 'date-created', returns it. Otherwise, checks doc age according to the TTL passed as argument and returns a NOT-FOUND error if doc is too old\r\nr.table(\"foo\").get(1, {ttl: 500})\r\n\r\n// Omits only docs that have an attr named 'date-created' AND are too old, according to the TTL passed as argument\r\nr.table(\"foo\").getAll('man_of_steel', {index:'code_name', ttl: 500})\r\n\r\n// Omits only docs that have an attr named 'my-timestamp' AND are too old, according to the TTL passed as argument\r\nr.table(\"foo\").getAll('man_of_steel', {index:'code_name', ttl: {'my-timestamp': 500}})\r\n```\r\n\r\nIf a table is creaetd with a 'ttl' option, then the TTL garbage collector will take care of it. But this garbage collector doesn't have to be coded first - we can have passive TTL functionality for now (as suggested on a comment on #746).\r\n\r\nOr there could also be a command that asks the cluster to purge old entries, like:\r\n\180\180\180Javascript\r\nr.db('test').purge({sync: *boolean*})\r\ndb.table('foo').purge({sync: *boolean*})\r\n\180\180\180\r\nWhen *sync* is true, the command only returns after all changes have been committed to storage.\r\nWhen it's false (the default), the return is immediate, much like the way indexCreate works.\r\n\r\nThe **purge** command can be used to get a changefeed, like this:\r\n\r\n```Javascript\r\n// shows documents as soon as they are purged either by the GC or by a get\r\nr.db('test').purge().changes()\r\ndb.table('foo').purge().changes()\r\n```\r\nAnd here's an alternate way to purge old entries which gives more flexibility:\r\n\r\n```Javascript\r\n// delete all entries that have already expired but haven't been collected by the GC\r\nr.db('test').expired().delete()\r\ndb.table('foo').expired().delete()\r\n\r\n// As soon as an entry expires (but before it's deleted), it'll be seen on these changefeeds:\r\n// (this one will be expensive)\r\nr.db('test').expired().changes()\r\ndb.table('foo').expired().changes()\r\n```\r\n"
  , issueState = "open"
  , issueId = Id 65993924
  , issueComments = 7
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 48436
                , simpleUserLogin = N "coffeemug"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/48436?v=3"
                , simpleUserUrl = "https://api.github.com/users/coffeemug"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 268
          , milestoneNumber = 41
          , milestoneClosedIssues = 0
          , milestoneDescription =
              Just
                "Issues in this milestone will be revisited after each major release during the planning stage for the major release after it. They will be moved to a specific release milestone if chosen for that release."
          , milestoneTitle = "subsequent"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/41"
          , milestoneCreatedAt = 2013 (-06) (-30) 07 : 32 : 52 UTC
          , milestoneState = "open"
          }
  }