IssueComment
  { issueCommentUpdatedAt = 2012 (-11) (-13) 22 : 00 : 35 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/10345768"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/51#issuecomment-10345768"
  , issueCommentCreatedAt = 2012 (-11) (-13) 22 : 00 : 35 UTC
  , issueCommentBody =
      "FYI. The server is designed to perform out-of-date reads on a per-table basis. That is, if I have a query that contains an inner query, I can have outer reads be performed out-of-date and inner reads by performed normally, or vice versa. It was easier to do on the server, and strictly more powerful.\r\n\r\nHowever, to the user this isn't really useful because typically you'll either run something out-of-date or you won't. For example, you might be doing an analytics query that you'll run out-of-date, or a realtime query that you'll run properly, but you're very unlikely to ever want to mix the two.\r\n\r\nSo in the clients, we decided to do it as a flag to run. If you call run with the out-of-date flag, the whole thing will be run out of date, otherwise it will be run up to date. You aren't supposed to pass the flag on each table (though some clients may or may not support it, that's purely an accident).\r\n\r\nI'll update the api docs for each client, and @wmrowan will check the js implementation soon."
  , issueCommentId = 10345768
  }