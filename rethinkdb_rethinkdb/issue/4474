Issue
  { issueClosedAt = Just 2015 (-08) (-05) 18 : 32 : 17 UTC
  , issueUpdatedAt = 2015 (-08) (-05) 18 : 32 : 17 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/4474/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/4474"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "fbda04"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/st:review"
          , labelName = "st:review"
          }
      ]
  , issueNumber = 4474
  , issueAssignee =
      Just
        SimpleUser
          { simpleUserId = Id 505365
          , simpleUserLogin = N "danielmewes"
          , simpleUserAvatarUrl =
              "https://avatars.githubusercontent.com/u/505365?v=3"
          , simpleUserUrl = "https://api.github.com/users/danielmewes"
          , simpleUserType = OwnerUser
          }
  , issueUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueTitle =
      "Limit backfill memory usage when loading large values"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/4474"
  , issueCreatedAt = 2015 (-06) (-30) 03 : 48 : 17 UTC
  , issueBody =
      Just
        "The new backfilling algorithm loads up to 16 leaf nodes at a time from disk. With 16MB values, that would be multiple tens of gigabytes of RAM usage per backfill. The solution is twofold:\r\n\r\n1. Apply the item chunk size limit as we load values from disk. That probably means that `backfill_item_consumer_t` should have a separate method like `acquire_semaphore()` that gets called before `on_item()`. Before loading each value, the B-tree traversal code would try `acquire_semaphore()`.\r\n\r\n2. If `acquire_semaphore()` returns `false` while we're loading a multi-key backfill item, then we should stop loading the item at that point and set its right bound to just before the key we were about to load, then pass on the incomplete item normally. This allows us to break large items into smaller chunks.\r\n\r\nIf this is done right, the memory usage per-backfill should be limited to approximately the value of `item_queue_mem_size` plus the size of the largest value in the B-tree."
  , issueState = "closed"
  , issueId = Id 91970009
  , issueComments = 2
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 316661
                , simpleUserLogin = N "timmaxw"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/316661?v=3"
                , simpleUserUrl = "https://api.github.com/users/timmaxw"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 0
          , milestoneNumber = 95
          , milestoneClosedIssues = 217
          , milestoneDescription =
              Just "To-do list before shipping auto-failover"
          , milestoneTitle = "2.1"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/95"
          , milestoneCreatedAt = 2015 (-03) (-04) 21 : 09 : 42 UTC
          , milestoneState = "closed"
          }
  }