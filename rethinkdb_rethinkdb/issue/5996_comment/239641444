IssueComment
  { issueCommentUpdatedAt = 2016 (-08) (-13) 21 : 03 : 30 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1824859
        , simpleUserLogin = N "venantius"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1824859?v=3"
        , simpleUserUrl = "https://api.github.com/users/venantius"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/239641444"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5996#issuecomment-239641444"
  , issueCommentCreatedAt = 2016 (-08) (-13) 21 : 03 : 30 UTC
  , issueCommentBody =
      "> The return value of sendQuery is Future<Response>. Here's the problem I see with placing your code in sendQuery. Since sendQuery returns a Future<T>; there's really no place for you inside sendQuery to \"obtain\" the actual response in sendQuery unless you want to do something with the totality of the Future<Response> object as an instance of Future<T>. To obtain the response in sendQuery you would have to forcefully Future<Response>.get() in order to obtain the actual response which arrives at some point, at a later time, in the future. By that time, you no longer are dealing with Future<Response> but the actual Response in sendQuery. Handling and blocking in sendQuery for the actual response, IMHO, is bad karma and breaks the current contract with everyone else who is expecting Future<Response>, not Response.\r\n\r\nThe reason I'm asking for `sendQuery` to be public isn't so that I can override it, but so that I can access its return value. \r\n\r\n> Serialization round trips? You mean de-serialization round trips? Actually, though, this brings up another important question... When passing native Clojure types into the underlying Java AST r.query.term(clojure_thing) does clojure_thing derive from Java types like Map, List, Integer, Number?\r\n\r\nWhoops, I did mean de-serialization, yes. \r\n\r\nRe: serialization - Clojure data structures do implement core interfaces (i.e. vector implements list, map implements map, etc.). At the moment I've got some logic that maps from term-type to initializer and then passes in a created Arguments and Optargs object (which are created when the application calls `run` in my code; these code paths could be memoized to reduce computational overhead). I'll try to get you a preview of what I've currently got so you can see what's going on there; it's not the prettiest logic but it works fine for right now. \r\n\r\n> Coo... so, you want to wrap the cursor implementation. Just so we're on the same page with the inner workings of a cursor, when an initial response to a query arrives over the wire, the Response is checked for .isPartial || .isSequence. If either is true, then the Response is used to build a Cursor. If the first Response is a complete response, all the data items from the Response are placed into a cursor's buffer. If the first Response is a partial response, the initial response data items are loaded into the Cursor's buffer, while firing off a CONTINUE message to the server (for eventually more items).\r\n> \r\n> As a consumer iterates over the cursor, a buffered item is pulled off the internal Cursor buffer. When, and only when, the buffer is zero, an attempt is made to read from a pending CONTINUE response. Here the consuming thread will either 1) block on Future<Response> because the CONTINUE response hasn't arrived yet, or 2) immediately process the Future<Response> because of its arrival. When the Response is consumed, the internal buffer is refilled, and subsequently another CONTINUE is fired off to the server. And the process repeats.\r\n> \r\n> So, core.async would have to be okay with this underlying functionality/operation when wrapping Cursor<T>.\r\n\r\nI've actually started taking a different approach with this for now by using `iterator-seq` on the Cursor object since it implements Iterable; this means that the application can lazily pull from it in a way that'll map well to idiomatic Clojure data structures. The downside to this approach is that it doesn't provide the application with a way to call `.close()` on the Cursor in a preliminary fashion - I might end up writing a simple class that implements `ISeq` in Clojure while still supporting `.close` as necessary, but it seemed like overkill for now while I'm still working on the overall driver architecture. \r\n\r\nIf the object isn't a cursor, I just convert it to native Clojure data types immediately and return those. \r\n\r\n> Well, the threading architecture is mostly responsible for picking up JSON strings off the wire and turning the JSON strings into real Response types for Future<Response> awaiters. This is Step 1 of the deserialization process.\r\n\r\n> Step 2 deserialization comes about after the decision has been made either to return an object or a cursor for a given Response. As alluded to in my previous response, > Converter.convertPseudotypes takes Response.Data and internally fixes up $reql_type$ pseudo types and transforms them into Java types. IE: $reql_type$: BINARY -> byte[]. Finally, after the $reql_type$ psuedo types are fixed up, Step 3.\r\n\r\n> Step 3 takes whatever is left from the convertPseudotypes process and turns it into a POJO like type of thing.\r\n\r\n> So yea... hm. You probably need to decide which place you want to hook into (or all of them).\r\n\r\nRight. For the moment I'm just working on taking what I get from step 3 and running with that since that doesn't require changes to the existing Java driver. But if I look forward to what the future Java driver could be in terms of providing better support for Clojure, I think we'd probably want to move a little earlier in the stack and provide flexibility for Clojure drivers to access the response at an earlier part of the process to avoid having to do un-necessary conversions (to-POJO/from-POJO). \r\n\r\n> So if I'm understanding this correctly, you want to stub out this whole section of code here and replace it with some kind of Clojure callback?\r\n> \r\n> https://github.com/rethinkdb/rethinkdb/blob/next/drivers/java/src/main/java/com/rethinkdb/net/Connection.java#L274-L289\r\n\r\nYep, that's exactly what I had in mind. \r\n\r\n> Alternatively, if the .NET Clojure CLR is an option for you... I'd be willing to refactor the C# driver's architecture a little more to accommodate your Clojure callbacks. As I mentioned earlier, the C# driver has IConnection and #5380 and the ability to hook Util.ToReqlAst... so the C# driver is a bit further along the trail for these kinds of changes. At the very least, it could help with experimentation of what you'll ultimately need.\r\n\r\nI'm afraid it's not - I know the Clojure CLR does get some use, but not by most Clojure folks. "
  , issueCommentId = 239641444
  }