IssueComment
  { issueCommentUpdatedAt = 2016 (-07) (-30) 18 : 56 : 56 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1824859
        , simpleUserLogin = N "venantius"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1824859?v=3"
        , simpleUserUrl = "https://api.github.com/users/venantius"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/236383214"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5996#issuecomment-236383214"
  , issueCommentCreatedAt = 2016 (-07) (-30) 18 : 56 : 56 UTC
  , issueCommentBody =
      "Whew, that's quite a response! Let me do my best to respond:\r\n\r\n> 1. So I think you want a way to process responses \10004\65039\r\n> 2. So I think you want a way to send queries \10067\r\n\r\nI do not need a way to send queries necessarily; I was just noticing that the return value of `sendQuery` seems to be the first place in which I'm able to obtain the `Response` object before it's been re-serialized into basic Java data structures. My thinking was that if I wanted to avoid multiple serialization trips, that'd be the place to put my efforts. I could very well have just misunderstood the code, however. \r\n\r\n> 1. Handling responses and 2. sending queries are two distinct operations, and both currently happen on different threads (and you mention things like core.async so I don't know exactly where that fits in). \r\n\r\n`core.async` would most likely come into play if the query returned a cursor; rather than leave it as a cursor and have to wrangle the Java interop we'd probably wrap it in a `core.async` channel in the driver and let people pull values from the `core.async` channel as values became available to the underlying cursor. \r\n\r\n> The problem with the way the current Java implementation (motivation for #5380), is that both of these (send/receive) 1. and 2. implementations currently co-exist in Connection, that is, in the same strata along with Response / Cursor logic. The Cursor logic is still important enough to live on its own strata separate from the underlying threading architecture IMHO (ie motivation for #5380).\r\n\r\nRight. \r\n\r\n> So, given the current state of Java things. Maybe, your best bet, is to implement an abstraction like IConnection, but unfortunately, this means you'll need to re-implement 1) some kind of threading architecture thing for sending / receiving stuff and 2) have some reasonable Cursor management stuff. Handling IConnection will most definitely get you both 1 and 2 but also adds some additional responsibility like handling Cursor management. I hope that kinda makes sense in a weird way??\r\n\r\nIn an ideal world we wouldn't have to re-implement the threading architecture and could leverage the existing Java driver (or generalize the Java driver's logic in such a way that consuming it from Clojure doesn't require jumping through any special hoops). I would, however, expect that we'd need to do some cursor management, per my section on `core.async` above. \r\n\r\n> So, #5380 (sorry repeating myself) would push the threading stuff down lower to SocketWrapper so that you could still use Connection's Cursor management stuff up above, but gives you 1 and 2 with your own response mechanism assuming Future<T> works for you.\r\n\r\nI *think* `Future<T>` should work fine. Though, again, I suspect that a proper Clojure driver would probably want to do a fair amount of its own Cursor management. \r\n\r\n> Or, maybe just simply overriding SocketWrapper:write() and Response SocketWrapper:read() would work? That gets you both 1 and 2 very simply. I don't know. \175 \\ _ (\12484) _ /\175 \128575\r\n\r\nBeing able to override `SocketWrapper.read()` could work, but I couldn't see a way with the current driver architecture to do that. I'm not sure how I'd integrate that into the rest of the `Connection.run` call stack; would I just be allowed to pass in my own `SocketWrapper` instance as part of the `run` invocation? \r\n\r\n> The immediate problem I see with \"handling it however it wanted\" is the Java callstack. For example, query.run(conn) would look something like this, IIRC:\r\n> \r\n> -> conn.sendQuery(query) \r\n> -> conn.runQuery(query) & wait for Response type\r\n> -> conn.run(query)\r\n> -> ReqlAst.run(Connection conn)\r\n> \r\n> How does your Clojure callback plan on backing out / unwinding the callstack cleanly after your \"Clojure [callback] handles it\"? What do we do with the response check here? if (res.isAtom()) It kinda effects cursor management. Or are you looking to completely bypass these if (res.isAtom()) response checks in conn.runQuery and have runQuery blindly return whatever your callback returns?\r\n\r\nYes. We'd create an interface for all of the functions in the call stack that just return `Object`, and call `.Invoke` on the Clojure function that's passed in and return that. The callback itself would be responsible for handling, e.g., the case for when `res.isAtom()`. \r\n\r\n> By the time your callback is executed, the wire-JSON is already deserialized into a Java Response type. But the Response.Data is still a JSONArray and is that okay for your Clojure callback?\r\n\r\nIdeally we're avoiding the multiple deserializations, as noted above. Now, it's worth noting of course that I could just be making a bunch of fuss about nothing and this could be a totally unimportant optimization. I haven't measured anything, after all. \r\n\r\n> Or, are you looking at just deserialization at this level? Hooking semantic occurrences of Lines 277 and 278 so you can return a POCO instead of a POJO?\10067\r\n> \r\n> Object value = ((List) Converter.convertPseudotypes(res.data, fmt)).get(0);\r\n> return Util.convertToPojo(value, pojoClass);\r\n\r\nYes. This is, in my mind, the ideal solution. However, this solution only really works fluidly when we're talking about straightforward responses (i.e. non-Cursor objects). I don't know what happens in this logical branch when the response is a Cursor. \r\n\r\n> Sorry for all the scatter mindedness, this is sort of the things I'm having difficulty with understanding your situation in my mind just cuz there's a lot of stuff going on. =(\r\n\r\nNo worries! Thanks for the detailed response in the first place :)"
  , issueCommentId = 236383214
  }