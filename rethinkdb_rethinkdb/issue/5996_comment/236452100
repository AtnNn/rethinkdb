IssueComment
  { issueCommentUpdatedAt = 2016 (-08) (-02) 00 : 05 : 15 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 478118
        , simpleUserLogin = N "bchavez"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/478118?v=3"
        , simpleUserUrl = "https://api.github.com/users/bchavez"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/236452100"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5996#issuecomment-236452100"
  , issueCommentCreatedAt = 2016 (-07) (-31) 19 : 41 : 23 UTC
  , issueCommentBody =
      "Okay, so after reading your response a few times, I'm starting to slowly see what things you'll need to implement your changes. But there are still some things that need to be worked out.\r\n\r\n> I was just noticing that the return value of `sendQuery` seems to be the first place in which I'm able to obtain the Response object before it's been re-serialized into basic Java data structures.\r\n\r\nThe return value of `sendQuery` is `Future<Response>`. Here's the problem I see with placing your code in `sendQuery`. Since `sendQuery` returns a `Future<T>`; there's really no place for you inside `sendQuery` to \"obtain\" the actual response in `sendQuery` unless you want to do something with the totality of the `Future<Response>` object as an instance of `Future<T>`. To obtain the response in `sendQuery` you would have to forcefully `Future<Response>.get()` in order to obtain the actual response which arrives at some point, at a later time, in the future. By that time, you no longer are dealing with `Future<Response>` but the actual `Response` in `sendQuery`. Handling and *blocking* in `sendQuery` for the actual response, IMHO, is bad karma and breaks the current contract with everyone else who is expecting `Future<Response>`, not `Response`.\r\n\r\n-----\r\n\r\n> My thinking was that if I wanted to avoid multiple serialization trips, that'd be the place to put my efforts. I could very well have just misunderstood the code, however.\r\n\r\nSerialization round trips? You mean de-serialization round trips? Actually, though, this brings up another important question... When passing native Clojure types into the underlying Java AST `r.query.term(clojure_thing)` does `clojure_thing` derive from Java types like `Map`, `List`, `Integer`, `Number`?\r\n\r\nIf Clojure native types don't directly inherit from Java base types (or if Java doesn't understand what `clojure_thing` is really composed of) then you're going to need a way to convert `clojure_thing` and decompose it into AST datums when they are passed as arguments into the AST. Specifically, you're going to need a way to hook into `Util.java:toReqlAst(Object val)` where `val` would be your `clojure_thing` that you'd need to deconstruct into datums.\r\n\r\n-----\r\n\r\n>`core.async` would most likely come into play if the query returned a cursor; rather than leave it as a cursor and have to wrangle the Java interop we'd probably wrap it in a `core.async` channel in the driver and let people pull values from the `core.async` channel as values became available to the underlying cursor.\r\n\r\nCoo... so, you want to wrap the cursor implementation. Just so we're on the same page with the inner workings of a cursor, when an initial response to a query arrives over the wire, the `Response` is checked for `.isPartial || .isSequence`. If either is true, then the `Response` is used to build a `Cursor`. If the first `Response` is a complete response, all the data items from the `Response` are placed into a cursor's buffer. If the first `Response` is a partial response, the initial response data items are loaded into the `Cursor`'s buffer, while firing off a `CONTINUE` message to the server (for eventually more items). \r\n\r\nAs a consumer iterates over the cursor, a buffered item is pulled off the internal `Cursor` buffer. When, and only when, the buffer is zero, an attempt is made to read from a pending `CONTINUE` response. Here the consuming thread will either 1) block on `Future<Response>` because the `CONTINUE` response hasn't arrived yet, or 2) immediately process the `Future<Response>` because of its arrival. When the `Response` is consumed, the internal buffer is refilled, and subsequently another `CONTINUE` is fired off to the server. And the process repeats.\r\n\r\nSo, `core.async` would have to be okay with this underlying functionality/operation when wrapping `Cursor<T>`.\r\n\r\n-----\r\n\r\n> Ideally we're avoiding the multiple deserializations, as noted above. Now, it's worth noting of course that I could just be making a bunch of fuss about nothing and this could be a totally unimportant optimization. I haven't measured anything, after all.\r\n\r\nWell, the threading architecture is mostly responsible for picking up JSON strings off the wire and turning the JSON strings into real `Response` types for `Future<Response>` awaiters. This is Step 1 of the deserialization process.\r\n\r\nStep 2 deserialization comes about after the decision has been made either to return an object or a cursor for a given `Response`. As alluded to in my previous response, `Converter.convertPseudotypes` takes `Response.Data` and internally fixes up `$reql_type$` pseudo types and transforms them into Java types. IE: `$reql_type$: BINARY -> byte[]`.  Finally, after the `$reql_type$` psuedo types are fixed up, Step 3.\r\n\r\nStep 3 takes whatever is left from the `convertPseudotypes` process and turns it into a POJO like type of thing.\r\n\r\nSo yea... hm. You probably need to decide which place you want to hook into (or all of them).\r\n\r\n------\r\n\r\n> Yes. We'd create an interface for all of the functions in the call stack that just return Object, and call .Invoke on the Clojure function that's passed in and return that. The callback itself would be responsible for handling, e.g., the case for when `res.isAtom()`.\r\n\r\nSo if I'm understanding this correctly, you want to stub out this whole section of code here and replace it with some kind of Clojure callback?  \r\n\r\nhttps://github.com/rethinkdb/rethinkdb/blob/next/drivers/java/src/main/java/com/rethinkdb/net/Connection.java#L274-L289\r\n\r\nTBH, this is probably the most appropriate place to hook the response processing mechanism from `Response` to -> `something` conversion. By the time your Clojure callback occurs, we'd have a `Response` available for you, not a `Future<Response>` as with `sendQuery`.\r\n\r\n----\r\n\r\nSo judging by what I'm understanding so far, I think it would take a mediumish effort to push the Java driver to a place where you could do this.\r\n\r\nAlternatively, if the .NET Clojure CLR is an option for you... I'd be willing to refactor the C# driver's architecture a little more to accommodate your Clojure callbacks. As I mentioned earlier, the C# driver has [`IConnection`](https://github.com/bchavez/RethinkDb.Driver/blob/master/Source/RethinkDb.Driver/Net/IConnection.cs#L13) and #5380 and the ability to hook [`Util.ToReqlAst`](https://github.com/bchavez/RethinkDb.Driver/blob/master/Source/RethinkDb.Driver/Ast/Util.cs#L15)... so the C# driver is a bit further along the trail for these kinds of changes. At the very least, it could help with experimentation of what you'll ultimately need.\r\n\r\nHope that helps,\r\nBrian\r\n\r\n:tropical_drink: :wine_glass: [***\"Some people drink Pepsi... Some people drink Coke...\"***](https://www.youtube.com/watch?v=p99a6K81zqM)"
  , issueCommentId = 236452100
  }