IssueComment
  { issueCommentUpdatedAt = 2016 (-04) (-13) 06 : 43 : 56 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 478118
        , simpleUserLogin = N "bchavez"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/478118?v=3"
        , simpleUserUrl = "https://api.github.com/users/bchavez"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/209225741"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/pull/5649#issuecomment-209225741"
  , issueCommentCreatedAt = 2016 (-04) (-13) 04 : 43 : 58 UTC
  , issueCommentBody =
      "Hey there Peter...\r\n\r\nIIRC, the driver can throw an exception based on a number of error responses the driver receives from the server [`ErrorBuilder.java`](https://github.com/rethinkdb/rethinkdb/blob/next/drivers/java/src/main/java/com/rethinkdb/ErrorBuilder.java#L44) [`Connection.java`](https://github.com/rethinkdb/rethinkdb/blob/next/drivers/java/src/main/java/com/rethinkdb/net/Connection.java#L260). If the driver throws one of these server response exceptions, the underlying TCP connection and `Connection` can be re-used for a subsequent query (in this sense, I guess I see the `Connection` itself in a recoverable state after throwing a server response exception client-side). As you've pointed out, perhaps maybe `RuntimeException` isn't the best base class for the exception hierarchy. I don't know since I'm not a Java expert.\r\n\r\nBut I think the main concern I see is:\r\n\r\n```\r\n// use it\r\nRethinkDB.r.db(\"test\").table(\"pooltest\").run(pool);  // provide ConnectionPool instead of Connection\r\n```\r\nand the implementation:\r\n```\r\npublic <T> T run(ConnectionPool pool) {\r\n    Connection conn = pool.leaseConnection();\r\n    T res = this.run(conn);\r\n    pool.returnConnection(conn);\r\n    return res;\r\n}\r\n```\r\n`conn` is leased, a `ReqlError` server response exception is thrown inside `this.run(conn)`, `conn` never gets `pool.returnConnection(conn)` returned. There's no way from the `use it` perspective to \"put `conn` back\" in the `pool`. `conn` doesn't necessarily need to be closed because a previous query by a different thread could potentially be holding a reference to a `Cursor`. IIRC, a `Cursor` itself holds a reference to the underlying `Connection` in which it was created from.\r\n\r\nThis is why I have some reservations about the lease-use-return pattern here because a 'lease' in the pool isn't an exclusive connection lease due to a foreign thread possession of a `Cursor` object (and thus underlying `Connection` which could be used at any time in a request for more `Cursor` items).\r\n\r\nAdditionally, closing `conn` immediately upon an exception, would probably not be the right thing since it would interrupt other threads holding `Cursor` objects associated with the same connection, but \"putting it back\" (less TCP connectivity issues) would be. Also, I'm thinking simply abandoning a `conn` reference like this and waiting for GC to collect lost references might lead to regressions similar to #5448.\r\n\r\nAlso `Connection`s are kind of expensive to create and bring online. In the event of an exhausted `pool` a query could take as much time to boot up a new connection when `Connection` reuse could offer better performance.\r\n\r\n-------\r\n\r\nI was thinking about the `leaseConnection` algorithm and I think there's an edge case that could possibly lead to a lopsided connection pool. I'm not sure if it's that important but.... \r\n\r\nLet's consider,\r\n\r\n```\r\n// define conneciton builders \r\nConnection.Builder connBuilderA = Connection.build().hostname(\"ServerA\").port(28015);\r\nConnection.Builder connBuilderB = Connection.build().hostname(\"ServerB\").port(28016);\r\n\r\n// create a conneciton pool\r\nConnectionPool pool = new FixedConnectionPool(connBuilderA, connBuilderB);\r\n```\r\n\r\nInitially, **ServerA** is offline. `leaseConnection()` is called multiple times. Some calls are against an exhausted `pool`, the `pool` accumulates several `Connection`s to **ServerB**. **ServerA** comes online. The next chance for **ServerA** to process a request is the next time the pool is exhausted? In the worst case, could be never? This kinda goes with my the unboundedness thoughts I had earlier. \r\n\r\n-----\r\n\r\nI hope I don't discourage your PR. Your PR is a great step forward for Java. I just wanted to share with you my personal experience implementing a connection pool for RethinkDB.\r\n\r\nThanks,\r\nBrian"
  , issueCommentId = 209225741
  }