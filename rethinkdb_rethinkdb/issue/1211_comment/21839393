IssueComment
  { issueCommentUpdatedAt = 2013 (-07) (-31) 04 : 25 : 34 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 34433
        , simpleUserLogin = N "fuwaneko"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/34433?v=3"
        , simpleUserUrl = "https://api.github.com/users/fuwaneko"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/21839393"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1211#issuecomment-21839393"
  , issueCommentCreatedAt = 2013 (-07) (-31) 04 : 25 : 34 UTC
  , issueCommentBody =
      "@wmrowan I'm sorry, but you've got the wrong idea. I meant that I fixed the pulled code to work. Your version is the same as ```instanceof``` version, even worse probably. Comparing constructor to Object is essentially similar to calling instanceof. If it's another context, than Object could be different and you get same error. Anytime you compare anything to one of built-in Objects/constructors you get unexpected results under certain circumstances. That's why the only correct way to check object type is either ```typeof``` which is rather unselective and returns ```object``` for most cases and then you can use duck-typing to check for certain properties. Or you can use ```Object.prototype.toString.call(obj)``` which will return value of internal [[Class]] field which is constant for all built-in types regardless of context and also shows difference between Array and Object. Unless someone redefines ```Object.prototype.toString``` which is entirely possible, but highly unlikely :)"
  , issueCommentId = 21839393
  }