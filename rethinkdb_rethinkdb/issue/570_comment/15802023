IssueComment
  { issueCommentUpdatedAt = 2013 (-04) (-02) 20 : 56 : 59 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 290841
        , simpleUserLogin = N "al3xandru"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/290841?v=3"
        , simpleUserUrl = "https://api.github.com/users/al3xandru"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/15802023"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/570#issuecomment-15802023"
  , issueCommentCreatedAt = 2013 (-04) (-02) 20 : 56 : 59 UTC
  , issueCommentBody =
      "1. `pluck` not throwing: **a must**\r\n\r\n2. the proposed semantic of `default` looks ok\r\n\r\n3. the proposed semantics of `default` (and `with_fields`) don't address the use case of extended variability in the row structure.\r\n\r\n    For cases where rows show big variability in their structure the query will be littered with defaults. The only option would be to have the users write multiple queries and `union` them or every other function in the query to be a `default`.\r\n\r\n4. For addressing the above I suggest a change of `with_fields` semantics that would allow specifying default values for the fields:\r\n\r\n    ```ruby\r\n    r.table('stats').with_fields({ :a => 20, :b => { :n => 32, :m => 70})...\r\n    ```\r\n\r\n5. If `NULL` values do compare to all other types we support, then having separate functions for `has_fields` and `has_something_else` doesn't make sense. I'd suggest `has_fields` to just to the check of presence and `has_fields(not_null=true)` to check for presence and not `NULL` .\r\n\r\n    Keeping the number of functions we expose low will make the query language feel powerful and simple. The learning curve is important. The more API functions added, the more complicated things are perceived."
  , issueCommentId = 15802023
  }