IssueComment
  { issueCommentUpdatedAt = 2013 (-06) (-19) 07 : 52 : 25 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/19668028"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1032#issuecomment-19668028"
  , issueCommentCreatedAt = 2013 (-06) (-19) 07 : 52 : 25 UTC
  , issueCommentBody =
      "I see what you mean. I have to think about it a bit more, but a few things immediately jump out at me.\r\n\r\n1. I don't see how we could efficiently implement `get_all(null)` as \"everything not in the index\" without actually indexing nulls (and missing attributes). I know we're talking semantics, but when there is no clear implementation path, I think it's important to discuss this too.\r\n2. I think it would be very confusing for users to say `get_all(null)` and actually get non-existent rows. I think it's ok to *filter out* nulls and missing attrs in the same way (e.g. via `has_fields`), but not ok to *select* them in the same way. The former seems desirable, the latter seems confusing.\r\n3. Intuitively, I would very much prefer RethinkDB to solve user A's problem but not user B's in this case. I'm not sure why, but that feels righter to me. I'll try to think of a way to explain/formalize it."
  , issueCommentId = 19668028
  }