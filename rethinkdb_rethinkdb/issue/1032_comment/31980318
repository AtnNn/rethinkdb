IssueComment
  { issueCommentUpdatedAt = 2014 (-01) (-09) 22 : 24 : 19 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 297060
        , simpleUserLogin = N "nviennot"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/297060?v=3"
        , simpleUserUrl = "https://api.github.com/users/nviennot"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/31980318"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1032#issuecomment-31980318"
  , issueCommentCreatedAt = 2014 (-01) (-09) 21 : 47 : 54 UTC
  , issueCommentBody =
      "The fact that the undefined values are not in the index is really sad when it comes to `order_by`, especially when building higher level frameworks that compile down to RQL queries with automatic usage of indexes.\r\n\r\nSuppose a `users` table with an index on `stuff`.\r\n\r\n---\r\n\r\n```ruby\r\n> User.create;\r\n# [14.3ms] r.table(\"users\").insert(r.json(\"{\\\"id\\\":\\\"52cf0fb79fc87e25e5000002\\\"}\"))\r\n> User.without_index.order_by(:stuff).count\r\n# [13.0ms] r.table(\"users\").orderby(r.asc(\"stuff\")).count\r\n=> 1\r\n> User.order_by(:stuff).count\r\n# [10.7ms] r.table(\"users\").orderby({:index => r.asc(\"stuff\")}).count\r\n=> 0\r\n```\r\n\r\nUsing an index or not should not change the result of the operation. Either the index behavior should be fixed, or the vanilla orderby() operation should throw away documents that don't have the required fields. I would argue for the former.\r\n\r\n---\r\n\r\nAnother weird behavior:\r\n\r\n```ruby\r\n> User.without_index.where(:stuff => nil).count\r\n# [42.4ms] r.table(\"users\").filter {|var_1| var_1.get_field(\"stuff\").eq(nil)}.orderby( r.asc(\"id\")).count\r\n=> 0\r\n> User.where(:stuff => nil).count\r\n# r.table(\"users\").get_all(nil, {:index => \"stuff\"}).orderby(r.asc(\"id\")).count\r\n# RethinkDB::RqlRuntimeError: Secondary keys must be a number, string, bool, or array (got null of type NULL).\r\n```\r\n\r\nIt's not clear judging by the discussion that this feature should be supported, but I'd like it to be supported :)\r\n\r\n--- \r\n\r\nAlso, in Ruby `nil` and `undefined` is basically the same thing:\r\n\r\n```ruby\r\nsome_hash = {:x => nil}\r\nsome_hash[:blah] # returns nil\r\nsome_hash[:x] # returns nil\r\n```\r\n\r\nIt gets a bit hard to provide some good semantics for a Ruby ORM because the database treats nil and undefined differently. I would be happy to have a special type for undefined values if that helped. We could have a special value like `r.undefined` which means undefined.\r\n\r\nSuppose I want to be able to retrieve quickly (quickly meaning with an index) documents that do not have a field defined, or equal to nil. But I do not want to create an additional index with the `contains()` trick.\r\nI'd rather use something like:\r\n\r\n```\r\n # if nil and undefined are treated the same\r\nr.table(\"users\").get_all(nil, {:index => \"stuff\"}).count\r\n\r\n# if nil and undefined are not treated the same way\r\nr.table(\"users\").get_all(nil, r.undefined, {:index => \"stuff\"}).count\r\n```\r\n\r\nThese sort of query is very useful when managing an application in production. For example, I want to be able to quickly count the documents that are missing a field. I cannot use `contains()` because my table in production is extra large and that would take forever. I cannot create a new `contains()` index just for that because that would also take forever. I already have an index on that field and I want to use it.\r\n\r\nBy saying that you don't want to provide query capabilities on undefined fields in secondary indexes is like saying that you don't want to deal with the issue. Yes, you will have wonderful semantics and all that, but you are just pushing the issue one layer up. At the end of the day, someone will have to deal with that problem, and you are saying that it's the developer's problem, not yours. That's not very courteous, so we have to fix this. I really want to build a Ruby ORM that is super easy to use (e.g. automatic index usage), and dummy proof (it's hard)."
  , issueCommentId = 31980318
  }