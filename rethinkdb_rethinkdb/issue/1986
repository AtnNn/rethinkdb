Issue
  { issueClosedAt = Nothing
  , issueUpdatedAt = 2014 (-02) (-24) 10 : 46 : 17 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/1986/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/1986"
  , issueClosedBy = Nothing
  , issueLabels = []
  , issueNumber = 1986
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 139396
        , simpleUserLogin = N "wojons"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/139396?v=3"
        , simpleUserUrl = "https://api.github.com/users/wojons"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "perposle r.return() and r.tunnel()"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/1986"
  , issueCreatedAt = 2014 (-02) (-21) 21 : 56 : 58 UTC
  , issueBody =
      Just
        "This is simular to #1653 the idea behind this is that i may have some very busy database nodes and dont wanna put any more storess on them but the current machine issueing the query is totally fine. So i issue the query and then the results. maybe some super light filter and then return the results back to calling node. And it can do some crazy stuff from there maybe there is a complex r.match().\n\nThe way this works normally would be like.\n\n```\nr.table().filter().return().filter(r.match())\n```\n\neverything after the return takes place locally assuming the data was on another node and not this one. \n\nThere can also be a few other good uses like.\n\n```\nr.tunnel('lax.*').table().filter().return().filter(r.match())\n```\n\ndepending on how this should be done it will pick any node in the dc lax have it run the query and then have it retuned to its self it would process the data and then the results of that would automatically be sent back to the local machine. \n\nthe other option is that it would try to parallelize the query in lax so if there are a few nodes there they all get the different docs back and run the finally filter yes this is a pretty crazy idea but also pretty powerful\n\nthe return function should have a few options maybe you wanna return one step up or all the way back to the original machine depends.\n"
  , issueState = "open"
  , issueId = Id 28076200
  , issueComments = 6
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 48436
                , simpleUserLogin = N "coffeemug"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/48436?v=3"
                , simpleUserUrl = "https://api.github.com/users/coffeemug"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 882
          , milestoneNumber = 2
          , milestoneClosedIssues = 0
          , milestoneDescription =
              Just
                "Issues in this milestone are not an immediate priority, and will be periodically revisited. When we decide to work on an issue in backlog, we'll move it to next."
          , milestoneTitle = "backlog"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/2"
          , milestoneCreatedAt = 2012 (-11) (-11) 14 : 16 : 11 UTC
          , milestoneState = "open"
          }
  }