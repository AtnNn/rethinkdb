IssueComment
  { issueCommentUpdatedAt = 2014 (-10) (-07) 17 : 57 : 04 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/58229140"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2998#issuecomment-58229140"
  , issueCommentCreatedAt = 2014 (-10) (-07) 17 : 57 : 04 UTC
  , issueCommentBody =
      "> bubbling up the original error means that the user needs to track down in our code where the `socket.timeout` is occurring\r\n\r\nI disagree. If there is a socket timeout they don't need to know where in our code it's happening, they'll just see a socket timeout (which suggests that the server is inaccessible). The thing is, when I connect to things, I'm used to catching socket timeout exceptions, but not used to catching magical rethrown RethinkDB exceptions. So I think we shouldn't rethrow as our own exceptions unless there is a very strong reason to do it.\r\n\r\n> If we are going to use this logic then we should probably unwrap at least the \"Could not connect to HOST:PORT. Error: ERROR\" message, since that is similar.\r\n\r\nI agree. We were going to, but never did as far as I remember. If you look at the Ruby driver, it throws native exceptions, and I think the Python driver should follow the same conventions."
  , issueCommentId = 58229140
  }