Issue
  { issueClosedAt = Nothing
  , issueUpdatedAt = 2015 (-03) (-23) 18 : 51 : 35 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/3554/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/3554"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "ededed"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:hygiene"
          , labelName = "tp:hygiene"
          }
      ]
  , issueNumber = 3554
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "Enforce correct destructor ordering"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/3554"
  , issueCreatedAt = 2015 (-01) (-13) 01 : 55 : 31 UTC
  , issueBody =
      Just
        "In our code, we have many classes which will automatically call a callback at any time until they are destroyed. Often these classes are used as members of other classes, and the callback accesses other members of the class. Sometimes the callback spawns coroutines which access other members of the class. The safe way to put this together is as follows:\r\n```c++\r\nclass my_class_t {\r\npublic:\r\n    my_class_t() : subs(std::bind(&my_class_t::callback1, this)) { }\r\n    void callback1() {\r\n        ASSERT_FINITE_CORO_WAITING;\r\n        foo.nonblocking_foo();\r\n        coro_t::spawn_sometime(std::bind(&my_class_t::callback2, this, drainer.lock()));\r\n    }\r\n    void callback2(auto_drainer_t::lock_t keepalive) {\r\n        try {\r\n            foo.nonblocking_foo();\r\n            bar.blocking_bar(keepalive.get_drain_signal());\r\n        } catch (const interrupted_exc_t &) {\r\n            /* ignore */\r\n        }\r\n    }\r\n    foo_t foo;\r\n    bar_t bar;\r\n    auto_drainer_t drainer;\r\n    subscription_t subs;\r\n};\r\n```\r\nWhen the destructor is run, first `subs` is destroyed, which prevents calls to `callback1()`. Then `drainer` is destroyed, which blocks until all instances of `callback2()` have finished. This ensures that `callback1()` and `callback2()` cannot access `foo` and `bar` when they are being destroyed.\r\n\r\nThe problem is that people often put this class together in the wrong order. Sometimes they forget the `auto_drainer_t` (see #3552). Other times they put `drainer` after `subs`, which will lead to crashes if `callback1()` runs during or after the `drainer` destructor. Or they may put `foo` and `bar` after `drainer` or after `subs`, which means that their destructors may be called while `callback1()` and `callback2()` can still access them. This is a source of subtle bugs.\r\n\r\nThe following solutions have been proposed:\r\n\r\n* Improve the documentation. We could put a big loud warning comment at the top of `auto_drainer.hpp`, and be sure to educate new engineers about these issues. But documentation is fragile and nobody reads it.\r\n\r\n* We could make `auto_drainer_t` have a non-trivial constructor, to encourage people to think about constructor order. One option is that `auto_drainer_t` should take an initializer-list of `void*`, so it would be initialized as `drainer(&foo, &bar)`; this would symbolically indicate that `foo` and `bar` must be constructed before `drainer`. Another option is to make it take a dummy type called something like `remember_to_consider_destructor_order_t`. But these only encourage correct behavior rather than enforcing it.\r\n\r\n* We could use static analysis to find violations. We would write a list of \"subscription-like classes\" (semilattice and directory subscriptions, `repeating_timer_t`, `mailbox_t`, etc.) and write a static analyzer script to enforce that regular members come first, then the `auto_drainer_t` if any, then subscription-like classes. We could use Clang's Python bindings, or `gcc-xml`.\r\n\r\n* We could force `auto_drainer_t` and subscription-like classes to be explicitly destroyed. Basically, `auto_drainer_t` and `subscription_t` would have `stop()` methods, which would be equivalent to their current destructors; if the destructor was called and `stop()` had not been called, then they would crash in debug mode. This would force the coder to give `my_class_t` an explicit destructor that calls `subs.stop(); drainer.stop()`. Because these would necessarily run before the `foo` and `bar` destructors, this solution automatically enforces that `foo` and `bar` can never be accessed during destruction. It's still possible to call `drainer.stop()` before `subs.stop()`, but it encourages people to think about it."
  , issueState = "open"
  , issueId = Id 54141139
  , issueComments = 7
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 48436
                , simpleUserLogin = N "coffeemug"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/48436?v=3"
                , simpleUserUrl = "https://api.github.com/users/coffeemug"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 883
          , milestoneNumber = 2
          , milestoneClosedIssues = 0
          , milestoneDescription =
              Just
                "Issues in this milestone are not an immediate priority, and will be periodically revisited. When we decide to work on an issue in backlog, we'll move it to next."
          , milestoneTitle = "backlog"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/2"
          , milestoneCreatedAt = 2012 (-11) (-11) 14 : 16 : 11 UTC
          , milestoneState = "open"
          }
  }