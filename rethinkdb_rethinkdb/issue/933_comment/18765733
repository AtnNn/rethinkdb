IssueComment
  { issueCommentUpdatedAt = 2013 (-05) (-31) 19 : 11 : 47 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/18765733"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/933#issuecomment-18765733"
  , issueCommentCreatedAt = 2013 (-05) (-31) 19 : 11 : 47 UTC
  , issueCommentBody =
      "Ah, I see what you mean.\r\n\r\nUnless we want to introduce a \"multi-index\" type into our type system, which I would be pretty opposed to, I think we'd end up having to do some sort of complicated static analysis on the function.  I think that behavior might also be a little more difficult to explain to people.\r\n\r\n(As an aside, you **can** multi-index some fields and not others with the optarg solution by explicitly using `union` and `concat_map` to compute a cross product.  For example:\r\n```ruby\r\nr.table('foo').index_create('bar', :type => :multi_index) {|row|\r\n  row[:multi_field_1].union(row[:multi_field_2]).concat_map {|multi_val|\r\n    [[multi_val, row[:non_multi_field_1]], [multi_val, row[:non_multi_field_2]]]\r\n  }\r\n}\r\n```\r\n)"
  , issueCommentId = 18765733
  }