Issue
  { issueClosedAt = Nothing
  , issueUpdatedAt = 2013 (-05) (-01) 20 : 22 : 19 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/738/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/738"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "e102d8"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:bug"
          , labelName = "tp:bug"
          }
      ]
  , issueNumber = 738
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 258437
        , simpleUserLogin = N "srh"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/258437?v=3"
        , simpleUserUrl = "https://api.github.com/users/srh"
        , simpleUserType = OwnerUser
        }
  , issueTitle =
      "serializer disk_structure.cc reader_t use-after-free"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/738"
  , issueCreatedAt = 2013 (-05) (-01) 18 : 52 : 39 UTC
  , issueBody =
      Just
        "To reproduce, you need to be in a branch that explicitly adds a check that the `reader_t` type in disk_structure.cc is not used after destruction.  This is done in the branch sam_disk_structure_defect, which is otherwise identical to next.  To reproduce, follow these steps:\n\n```\ngit checkout sam_disk_structure_defect\nmake DEBUG=1\n./build/debug/rethinkdb-unittest --gtest_filter=MirroredTest.Durability\n```\n\nThe output is as follows:\n\n```\nNote: Google Test filter = MirroredTest.Durability\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from MirroredTest\n[ RUN      ] MirroredTest.Durability\nVersion: rethinkdb 1.4.3-1122-gbccad5 (debug) (GCC 4.7.3)\nerror: Error in src/serializer/log/lba/disk_structure.cc at line 267:\nPrevious message may not have been written to the log file (cannot open or find log file).\nerror: Assertion failed: [!destructed] \nPrevious message may not have been written to the log file (cannot open or find log file).\nerror: Backtrace:\nPrevious message may not have been written to the log file (cannot open or find log file).\nerror: Wed May  1 11:42:05 2013\n\n       1: lazy_backtrace_t::lazy_backtrace_t() at backtrace.cc:249\n       2: format_backtrace(bool) at backtrace.cc:196\n       3: report_fatal_error(char const*, int, char const*, ...) at errors.cc:71 (discriminator 1)\n       4: reader_t::start_more_readers() at disk_structure.cc:267 (discriminator 1)\n       5: reader_t::reader_t(lba_disk_structure_t*, in_memory_index_t*, lba_disk_structure_t::read_callback_t*) at disk_structure.cc:254\n       6: lba_disk_structure_t::read(in_memory_index_t*, lba_disk_structure_t::read_callback_t*) at disk_structure.cc:279\n       7: lba_start_fsm_t::on_lba_load() at lba_list.cc:58 (discriminator 2)\n       8: lba_disk_structure_t::set_load_callback(lba_disk_structure_t::load_callback_t*) at disk_structure.cc:47\n       9: lba_start_fsm_t::lba_start_fsm_t(lba_list_t*, lba_metablock_mixin_t*) at lba_list.cc:45\n       10: lba_list_t::start_existing(file_t*, lba_metablock_mixin_t*, lba_list_t::ready_callback_t*) at lba_list.cc:80 (discriminator 1)\n       11: ls_start_existing_fsm_t::next_starting_up_step() at log_serializer.cc:256\n       12: ls_start_existing_fsm_t::on_metablock_read() at log_serializer.cc:311\n       13: metablock_manager_t<log_serializer_metablock_t>::start_existing_callback(file_t*, bool*, log_serializer_metablock_t*, metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*) at metablock_manager.cc:226\n       14: boost::_mfi::mf4<void, metablock_manager_t<log_serializer_metablock_t>, file_t*, bool*, log_serializer_metablock_t*, metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*>::operator()(metablock_manager_t<log_serializer_metablock_t>*, file_t*, bool*, log_serializer_metablock_t*, metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*) const at mem_fn_template.hpp:507 (discriminator 3)\n       15: void boost::_bi::list5<boost::_bi::value<metablock_manager_t<log_serializer_metablock_t>*>, boost::_bi::value<file_t*>, boost::_bi::value<bool*>, boost::_bi::value<log_serializer_metablock_t*>, boost::_bi::value<metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*> >::operator()<boost::_mfi::mf4<void, metablock_manager_t<log_serializer_metablock_t>, file_t*, bool*, log_serializer_metablock_t*, metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*>, boost::_bi::list0>(boost::_bi::type<void>, boost::_mfi::mf4<void, metablock_manager_t<log_serializer_metablock_t>, file_t*, bool*, log_serializer_metablock_t*, metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*>&, boost::_bi::list0&, int) at bind.hpp:526\n       16: boost::_bi::bind_t<void, boost::_mfi::mf4<void, metablock_manager_t<log_serializer_metablock_t>, file_t*, bool*, log_serializer_metablock_t*, metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*>, boost::_bi::list5<boost::_bi::value<metablock_manager_t<log_serializer_metablock_t>*>, boost::_bi::value<file_t*>, boost::_bi::value<bool*>, boost::_bi::value<log_serializer_metablock_t*>, boost::_bi::value<metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*> > >::operator()() at bind_template.hpp:20\n       17: callable_action_instance_t<boost::_bi::bind_t<void, boost::_mfi::mf4<void, metablock_manager_t<log_serializer_metablock_t>, file_t*, bool*, log_serializer_metablock_t*, metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*>, boost::_bi::list5<boost::_bi::value<metablock_manager_t<log_serializer_metablock_t>*>, boost::_bi::value<file_t*>, boost::_bi::value<bool*>, boost::_bi::value<log_serializer_metablock_t*>, boost::_bi::value<metablock_manager_t<log_serializer_metablock_t>::metablock_read_callback_t*> > > >::run_action() at runtime_utils.hpp:58\n       18: callable_action_wrapper_t::run() at runtime_utils.cc:67\n       19: coro_t::run() at coroutines.cc:178\nPrevious message may not have been written to the log file (cannot open or find log file).\nerror: Exiting.\nPrevious message may not have been written to the log file (cannot open or find log file).\nTrace/breakpoint trap (core dumped)\n```\n\nThis test can be made to not fail by having the mock_file_t object call its on_io_complete callback later in a new coroutine.  (I checked, and this bug is not caused by a stack overflow.)\n\nThe \"real\" linux_file_t object can also call on_io_complete immediately, without blocking, with its conflict handler.  I think we would not get a conflict when reading the LBA from disk, though, so I'm not sure if this defect could manifest in the real world.  Maybe if we're reading the file stored on an in-memory filesystem or something it would also be possible to get an on_io_complete right away, that depends on details of the linux_file_t implementation that I don't care to look into right now.\n"
  , issueState = "open"
  , issueId = Id 13860765
  , issueComments = 0
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 48436
                , simpleUserLogin = N "coffeemug"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/48436?v=3"
                , simpleUserUrl = "https://api.github.com/users/coffeemug"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 882
          , milestoneNumber = 2
          , milestoneClosedIssues = 0
          , milestoneDescription =
              Just
                "Issues in this milestone are not an immediate priority, and will be periodically revisited. When we decide to work on an issue in backlog, we'll move it to next."
          , milestoneTitle = "backlog"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/2"
          , milestoneCreatedAt = 2012 (-11) (-11) 14 : 16 : 11 UTC
          , milestoneState = "open"
          }
  }