IssueComment
  { issueCommentUpdatedAt = 2012 (-11) (-26) 06 : 55 : 48 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/10706270"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/100#issuecomment-10706270"
  , issueCommentCreatedAt = 2012 (-11) (-26) 06 : 55 : 48 UTC
  , issueCommentBody =
      "So I think I finally know what I don't like about this. There's no clear mental model for what `r.js` means on the server. Let me explain.\r\n\r\nAll our docs say about js is that it is used to \"construct javascript expressions\". This isn't very clear and doesn't actually say anything about how that string gets executed on the server. Reading that as a javascript programmer I would assume that means that `r.js` behaves essentially like `eval`, that is, we implement `r.js` on the server like this:\r\n\r\n```javascript\r\nfunction executeJS(jsstr) {\r\n    return eval(jsstr);\r\n}\r\n```\r\n\r\nThat isn't the way that we actually implement `executeJS` though. The implementation we seem to use is:\r\n```javascript\r\nfunction executeJS(jsstr) {\r\n    return (new Function(jsstr))()\r\n}\r\n```\r\nWow, that looks a lot more complicated, and indeed, it makes our reasoning about its behavior much more complicated as a consequence. This implementation actually requires that jsstr have a return statement within it in order for your javascript function to return a value. That behavior isn't very intuitive however since I probably still expect it to behave like `eval`.\r\n\r\nSo, to solve the problem we simply prepend a `return` for them, in the client. But this then limits us to one statement since the value of the first statement will be returned and the rest ignored as we've essentially converted their sequence of statements into:\r\n```javascript\r\nfunction dumbfunction() {\r\n    return stmt1;\r\n    stmt2; // ignored\r\n    stmt3; // ignored\r\n}\r\n```\r\n\r\nSo, to solve *that* problem we now add a flag that specifies whether or not they want us to prepend a `return` statement for them (and yes, I checked the ruby implementation, all this flag does is prepend a `return` or not). Instructing the client not to prepend a `return` allows them to specify multiple statements which will then all be executed. But now they again they have to remember to put the return statement in that we were trying to save them from in the first place. Oh and if they forget? Then the value of their `r.js` call will be `undefined` and result in a cryptic error message about not being able to convert `undefined` into JSON.\r\n\r\nSo, what has this additional complexity bought us? A complicated execution model that we don't actually explain, unintuitive requirements like when to add a `return` statement that will fail silently if you get it wrong, and a fairly arbitrarily defined flag that is necessitated by a clumsy 'fix' to a problem that the flag reintroduces when invoked!\r\n\r\nFortunately, there is a solution to all of this. Let's invoke the principle of least surprise and just match the behavior of `eval` which our users expect anyway. This is simpler to implement and even easier to explain (\"r.js: works just like eval\").\r\n\r\nBut wait, doesn't the `eval` model have the problem of multiple statement execution? No! for if we had bothered to read the eval documentation we would have seen that `eval`, in fact, has exactly the semantics that we want, namely if passed a series of statements it will execute each of them and then return the value of the last executed statement. Don't believe me? Ctrl-Shift-J and try this out:\r\n```javascript\r\n>>> eval(\"1; 2;\")\r\n2\r\n>>> eval(\"var a = 1; var b = 3; a + b;\")\r\n3\r\n>>> eval(\"/* And even... */ if ( 1 > 2) { 4 } else { 5 }\")\r\n5\r\n```\r\n\r\nI actually didn't know that eval behaved like that until I researched this but it's frickn' awesome and totally solves our problem, as least from the client API standpoint. I don't actually know how our javascript execution system works but there shouldn't be any reason why we can't just invoke V8's eval function. Even if it is more complicated, matching the behavior of an already well documented function that behaves exactly as we want will be worth the effort."
  , issueCommentId = 10706270
  }