IssueComment
  { issueCommentUpdatedAt = 2016 (-01) (-14) 08 : 35 : 31 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 393259
        , simpleUserLogin = N "gebrits"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/393259?v=3"
        , simpleUserUrl = "https://api.github.com/users/gebrits"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/171571098"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5286#issuecomment-171571098"
  , issueCommentCreatedAt = 2016 (-01) (-14) 08 : 30 : 31 UTC
  , issueCommentBody =
      "@danielmewes: I meant optimistic concurrency / locking, also sometimes known as CAS: check-and-set. \r\n\r\nThe (optional) ability to send a versionId with an update request. The update only succeeds if the versionId send equals the current versionId of the document. If not a conflict is thrown. \r\n\r\nWhat happens in a case of conflict depends on the client. From, for example, the Elasticsearch docs: \r\n\r\n> What we do now depends on our application requirements. We could tell the user that somebody else has already made changes to the document, and to review the changes before trying to save them again. Alternatively, as in the case of the widget stock_count previously, we could retrieve the latest document and try to reapply the change.\r\n\r\nhttps://www.elastic.co/guide/en/elasticsearch/guide/current/optimistic-concurrency-control.html\r\n\r\nThe big usecase here is that a client A can be assured that every update it performs succeeds only if it's update was based on current (non-stale) reads. I.e.: if another client B updates a document in between, the versionId is increased and a conflict occurs when client A tries to update. "
  , issueCommentId = 171571098
  }