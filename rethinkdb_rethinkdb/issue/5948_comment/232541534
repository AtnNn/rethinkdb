IssueComment
  { issueCommentUpdatedAt = 2016 (-07) (-14) 02 : 50 : 51 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/232541534"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5948#issuecomment-232541534"
  , issueCommentCreatedAt = 2016 (-07) (-14) 02 : 37 : 22 UTC
  , issueCommentBody =
      "Here's an example machine and input that you can paste and run in the Data Explorer.\r\nIt just writes the symbol 1 onto the tape, transitions to state 1 and terminates.\r\n\r\nYou can define any other input or turing machine in this and run it on your RethinkDB server.\r\n\r\n```js\r\nvar machine = {\r\n  blank_symbol: 0,\r\n  transitions: [\r\n    {\r\n      from_state: 0,\r\n      read_symbol: 0,\r\n      to_state: 1,\r\n      write_symbol: 1,\r\n      move_head: \"R\"\r\n    }\r\n  ],\r\n  initial_state: 0,\r\n  final_states: [1]\r\n};\r\n\r\nvar input = [];\r\n\r\nvar initialState = { tape: input, state: machine.initial_state, head_position: 0 };\r\n\r\n// Reads the current symbol from the tape.\r\nvar readSymbol = function(state) {\r\n    return state('tape').nth(state('head_position')).default(machine.blank_symbol);\r\n  };\r\n\r\n// Tests whether the given transition applies to the current state.\r\nvar checkRule = function(state, rule) {\r\n    return state('state').eq(rule('from_state')).and(readSymbol(state).eq(rule('read_symbol')));\r\n  };\r\n\r\n// Selects an applicable transition.\r\nvar selectRule = function(state) {\r\n    return r.expr(machine.transitions)\r\n      .concatMap(function(rule) {\r\n        return r.branch(checkRule(state, rule), [rule], []);\r\n      })\r\n      .nth(0)\r\n      .default(r.error(\"No applicable rule. Input rejected.\"));\r\n  };\r\n\r\n// Writes `newSymbol` to the current head position and returns the new tape.\r\nvar writeTape = function(state, newSymbol) {\r\n  // Note that head_position is never larger than the current tape length\r\n  var mustAppend = state('tape').count().eq(state('head_position'));\r\n  return r.branch(\r\n    mustAppend,\r\n    state('tape').append(newSymbol),\r\n    state('tape').changeAt(state('head_position'), newSymbol));\r\n};\r\n\r\n// Applies the given transition to the given state, and returns a new state.\r\nvar applyRule = function(state, rule) {\r\n  return {\r\n    tape: writeTape(state, rule('write_symbol')),\r\n    state: rule('to_state'),\r\n    head_position: state('head_position').add(r.branch(rule('move_head').eq(\"L\"), -1, 1))\r\n  };\r\n};\r\n\r\n\r\nr.range()\r\n .fold(\r\n   initialState,\r\n   function(state, _ignored) {\r\n     // Select a transition and compute the new state by applying it.\r\n     var selectedRule = selectRule(state);\r\n     return applyRule(state, selectedRule);\r\n   },\r\n   {\r\n     emit: function(_ignored, _ignored2, state) {\r\n       // Check if we have reached a final state. If yes, accept the input by emitting the current tape.\r\n       return r.branch(\r\n         r.expr(machine.final_states).contains(state('state')),\r\n         [state('tape')],\r\n         []);\r\n     }\r\n   }\r\n )\r\n .limit(1) // Stop as soon as we get to an accepted state\r\n```"
  , issueCommentId = 232541534
  }