IssueComment
  { issueCommentUpdatedAt = 2015 (-05) (-31) 06 : 22 : 02 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 572196
        , simpleUserLogin = N "stuartpb"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/572196?v=3"
        , simpleUserUrl = "https://api.github.com/users/stuartpb"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/107127070"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3771#issuecomment-107127070"
  , issueCommentCreatedAt = 2015 (-05) (-31) 04 : 33 : 46 UTC
  , issueCommentBody =
      "To clarify, in addition to the stuff mentioned by @danielmewes in https://github.com/rethinkdb/rethinkdb/issues/3771#issue-57514922 (ie. not coercing cursors/streams to arrays), these are the properties I would want/need of a new `rethinkdbdash`-modeled `rethinkdb` JS driver (I'm not sure how much of this is currently true of rethinkdbdash):\r\n\r\n*(For clarity, I will refer to the current module returned by `require('rethinkdb')` as `old_r` and the hypothetical new module that would more closely resemble `require('rethinkdbdash')` as `new_r`. Note that `new_r` refers to the base `require('rethinkdbdash')` module object/function, and __not__ an instance returned by __calling__ `require('rethinkdbdash')()`.)*\r\n\r\n- `new_r` contains all the methods and properties (in terms of public interface) of `old_r`, particularly those related to query-building. Queries built with the root `new_r` are \"connectionless\" (like queries built with `old_r` are/were).\r\n  - Calling `.then`, or `.run()` with no arguments, on a \"connectionless\" query is an error (as calling `.run()` with no arguments is now, in `old_r`). Connectionless queries *must* be run with an explicitly-specified connection.\r\n  - Connectionless queries may provide some kind of `.bind(conn)` method, which returns a clone of the query that will use the given connection implicitly when run with `.then` or paramless `.run()`.\r\n- Calling `new_r(opts)` as a function synchronously returns an `old_r`-like instance (the way `require('rethinkdbdash')()` does now), one which can *also* be passed to a constructed query's `.run` as a connection (see #4315).\r\n  - `new_r(opts)` takes the **exact** same set of options regarding the host (or hosts, for cluster pooling) to connect to as `new_r.connect(opts)`.\r\n  - Queries constructed from a `new_r(opts)` instance can use `.then()` or `.run()` without a connection parameter, for an implicit `.run` using the established connection.\r\n  - Running a query against a connection created with `new_r(opts)` (either implicitly **or** by using it as an explicit argument to a query's `.run()`) before the connection is established (ie. synchronously immediately after creation) buffers the query for execution after the connection is established (as I believe rethinkdbdash does currently, at least for implicit-connection runs - again see #4315).\r\n  - Queries constructed from a `new_r(opts)` instance should still support running against an alternative connection provided as a parameter to `.run`.\r\n- Calling `new_r.connect(opts)` provides the **exact** same value as `new_r(opts)` would (ie. with query-builder methods that create queries with implicit bound connections), but asynchronously (via callbacks/promises), and only after the connection is established. (This is mostly for backward compatibility, although there are also paradigms where it makes sense to only use the connection once it's been established.)\r\n  - To clarify/reiterate the implications of \"the **exact** same value\", this would mean that **all** connections, regardless of how they were constructed/returned (ie. whether as `var conn = r(opts)`, `r.connect(opts).then(conn => {/*...*/})`, or `r.connect(opts, function(conn){/*...*/})`), would work as bound-query-building contexts, with all the query-builder interface methods/properties of `old_r` constructing thenable queries that permit calling `.run()` without specifying a connection, to implicitly use the connection they were initially chained from.\r\n  - The return value of `new_r(opts)` may do well to have some kind of equivalent method like `.onConnect` (or even just as a special behavior of an instance's `.connect()` with no arguments), to allow these same behaviors that should only be applied once the connection is established. (In the event that queries have already been buffered, the callbacks/promises registered via `.onConnect` should fire first, as this allows for clean implementation of models where queries are only performed within callbacks and some kind of initialization logic is required.)"
  , issueCommentId = 107127070
  }