IssueComment
  { issueCommentUpdatedAt = 2015 (-05) (-31) 23 : 54 : 30 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 572196
        , simpleUserLogin = N "stuartpb"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/572196?v=3"
        , simpleUserUrl = "https://api.github.com/users/stuartpb"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/107127986"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3771#issuecomment-107127986"
  , issueCommentCreatedAt = 2015 (-05) (-31) 04 : 51 : 03 UTC
  , issueCommentBody =
      "Heck, I could probably implement an example of what I'm talking about as an abstraction on top of the existing `rethinkdb` driver, although it wouldn't have `rethinkdbdash`'s stream2 support (and it would involve way more proxying than I'm comfortable writing). (Edit: I'm looking into doing this by forking `rethinkdbdash`.)\r\n\r\nBasically, to me, more than streams or pooling, it's the ability to have a *synchronously-constructed connection context* that is the most appealing/intriguing aspect of `rethinkdbdash` (along with the minor enhancements that follow from bound contexts, like allowing queries to be thenable). However, that context model isn't suitable for everything you can do with `rethinkdb` (especially if you're working with a codebase written against the older model), which is why I'd need it to remain compatible with the old paradigm in the fashion described above."
  , issueCommentId = 107127986
  }