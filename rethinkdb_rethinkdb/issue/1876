Issue
  { issueClosedAt = Just 2014 (-10) (-21) 18 : 13 : 47 UTC
  , issueUpdatedAt = 2014 (-10) (-21) 18 : 13 : 56 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/1876/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/1876"
  , issueClosedBy = Nothing
  , issueLabels = []
  , issueNumber = 1876
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 297060
        , simpleUserLogin = N "nviennot"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/297060?v=3"
        , simpleUserUrl = "https://api.github.com/users/nviennot"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "Master election / node discovery backends"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/1876"
  , issueCreatedAt = 2014 (-01) (-17) 23 : 14 : 05 UTC
  , issueBody =
      Just
        "When it comes to automatic failovers for masters, there are three options:\r\n* Implement some reliable consensus algorithm builtin in rethinkdb.\r\n* Rely on an external service.\r\n* Implement a not so reliable consensus algorithm builtin in rethinkdb, but use an external name service for reliable consensus.\r\n\r\nI think we should go with option 3 as it offers the best of both worlds:\r\n* You don't have to spent lots of resources to implement a reliable algorithm (it's apparently really hard to do it well). Perhaps a simple gossip algorithm is good enough for development environment or very small deployments (one or two servers).\r\n* When integrating rethinkdb as part as a large system, I'd much rather use the name services that I'm already using. This way, applications that need to talk to the rethinkdb database can simply ask the name server for a running rethinkdb node. (well, you could say that I could use an internal DNS for that, like \"rethinkdb.local\", but that thing still needs to be updated when machines die, or when new machines come up).\r\n* Conversely, rethinkdb can leverage the name server to discover new database nodes. This may add some additional reliability when it comes to determining how many nodes are supposed to be present for example. Also, the configuration of rethinkdb could be reliably stored on the name service.\r\n\r\nHere are the name service backends that I think we should support:\r\n* a builtin native algorithm (gossip?)\r\n* etcd: https://github.com/coreos/etcd#etcd (Raft)\r\n* doozer: https://github.com/ha/doozerd (Paxos)\r\n* zookeeper: http://zookeeper.apache.org/ (Zab)\r\n* chubby: just kidding (Paxos)\r\n\r\nEdit: consensus algorithm fixes\r\n\r\n/cc @philips"
  , issueState = "closed"
  , issueId = Id 25845181
  , issueComments = 5
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 706854
                , simpleUserLogin = N "AtnNn"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/706854?v=3"
                , simpleUserUrl = "https://api.github.com/users/AtnNn"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 0
          , milestoneNumber = 52
          , milestoneClosedIssues = 66
          , milestoneDescription =
              Just
                "These issues have been moved to another repository. Usually `docs` or one of the private repos."
          , milestoneTitle = "moved"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/52"
          , milestoneCreatedAt = 2013 (-11) (-06) 22 : 17 : 28 UTC
          , milestoneState = "closed"
          }
  }