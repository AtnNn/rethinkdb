IssueComment
  { issueCommentUpdatedAt = 2015 (-10) (-12) 07 : 35 : 28 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 172936
        , simpleUserLogin = N "freiksenet"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/172936?v=3"
        , simpleUserUrl = "https://api.github.com/users/freiksenet"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/147311957"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3711#issuecomment-147311957"
  , issueCommentCreatedAt = 2015 (-10) (-12) 07 : 35 : 16 UTC
  , issueCommentBody =
      "Hi!\r\n\r\nWe at [Reindex](https://www.reindex.io) use GraphQL with RethinkDB, so I'd like to share our experience.\r\n\r\nFirst of all, I agree with @leebyron and others in that GraphQL is not a replacement for ReQL and I don't think RethinkDB implementation should try to replicate all ReQL in GraphQL. However, I think a GraphQL interface to RethinkDB certainly makes sense and Reindex is very similar to it in that it's a generic data storage solution, not a custom backend. \r\n\r\nI think it would make sense to have a generic spec, similar to Relay GraphQL spec, that defines how a *generic* data storage provider should implement basic GraphQL CRUD. This way users using Reindex can switch to RethinkDB GraphQL and to some other provider GraphQL.\r\n\r\nWhat I mean by generic, is that it won't have domain specific GraphQL root fields, but rather have root fields that allow basic operations on types that are defined by GraphQL schema. It will also provide guidelines/proposals on how such data will be stored in the data storage. Spec should be compatible with Relay spec, because Relay is the only (or at least most used) client library for GraphQL. To support Relay some more stuff beyond spec in, eg, mutation payloads are required.\r\n\r\nAs we already have such generic implementation at Reindex, I humbly propose that we start with it as a basis for such spec.\r\n\r\n## What questions should spec answer\r\n\r\nNot exhaustive. I'll also provide how Reindex currently answers them.\r\n\r\n1. *How to handle schema?*\r\nWe store schema in one table in RethinkDB, we generate basic types, connection types, root fields and input objects from it on runtime.\r\nHere is a (very alpha) docs for our type JSON:\r\nhttps://www.reindex.io/docs/reindex-schema/\r\n2. *How to represent GraphQL types?*\r\nReindex represents any type with interface `Node` (which is an interface from Relay spec that has unique id) as a RethinkDB table and assumes all other types will be stored inline.\r\n3. *How to represent Relay Connections?*\r\nWe define any 1-* relationship between any two `Nodes` a connection, with \"parent\" side having a Connection field. Non-node types are assumed to be inline, either as lists or objects.\r\n4. *What root fields should be provided?*\r\nWe provide CRUD fields (for type `Foo`: `getFoo`, `createFoo`, `updateFoo`, `replaceFoo`, `deleteFoo`)\r\n5. *What is required to support Relay beyond the spec?*\r\n   1. `node` root field that retrieves object of *any* `Node` type by unique id. We basically concat typename and RethinkDB id through a custom scalar type, base64 encode it and use that as a global id.\r\n   2. mutation results (`Payloads`) should have (so that they work with all Relay mutations)\r\n     1. The changed object itself\r\n     2. The changed object Relay `edge`\r\n     3. Field containing `viewer` object\r\n     4. A field for each connection this object can be a part of\r\n  3. \"global\" connections (so connections to all objects of some type) should be wrapped in an object of `Node` type. We have `Viewer` type and `viewer` root field that returns a singleton objects that has fields containing connections to all types available. It also holds reference to current user.\r\n6. *How user authentication should be handled?*\r\nI think actual authentication is out of scope of the spec, but handling authenticated user is in scope. We pass logged-in user id in GraphQL context to all queries and then it can be used to check permissions. Optionally one can also have some sort of User table and match the logged-in user id with it. We do provide it by default.\r\n7. *How permissions should be handled?*\r\nWith the user id passed to context, one can use it to implement permissions. We have Permissions type/table in our system, which stores objects with user id and type id in them, along with CRUD permissions' booleans. Root fields check for permissions and return null if there are none.\r\nWe also provide permission propagation through connections, where connections to `User` type (which we have), can grant additional permissions, so you can, for example, model that user can update something that he is an author of. The latter is an experiment, we are not sure how well it will work.\r\n\r\nHope that helps. Looking forward to feedback."
  , issueCommentId = 147311957
  }