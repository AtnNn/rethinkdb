IssueComment
  { issueCommentUpdatedAt = 2015 (-10) (-27) 20 : 52 : 18 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/151639571"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3711#issuecomment-151639571"
  , issueCommentCreatedAt = 2015 (-10) (-27) 20 : 50 : 14 UTC
  , issueCommentBody =
      "All -- I've got some good news and some bad news wrt this issue.\r\n\r\nThe good news is that our preliminary design discussions are complete, and the project to get users direct browser access to RethinkDB is now under way. We expect to ship a complete working feature/product in 6-8 weeks.\r\n\r\nThe bad news is that this first implementation will not be using GraphQL. We were (and still are) very excited about GraphQL and the possibilities that it opens up for the future of web development, but during the design process we ran into a number of issues, and eventually decided that it would be unwise to offer a GraphQL protocol for the first implementation. Here is a quick summary on how we reached this decision.\r\n\r\nI think that the closest mental model for GraphQL is to think of it as a replacement for REST. As we started designing browser access to the database on top of GraphQL we ran into the following problems:\r\n\r\n- Relay's GraphQL spec gives relatively little guidance on how to structure the API. For example, there is some guidance on how to structure mutations to make them consumable by Relay, but there is no guidance on which mutations to implement (on this issue GraphQL/Relay is partially less specified than REST). To get a good implementation, we need to figure out how to design basic insert/update/upsert/replace commands in a such a way that React/Relay developers find them useful and convenient, and since GraphQL/Relay is relatively new, it's not immediately clear what a good, convenient mutations API would look like.\r\n- GraphQL has a notion of subscriptions to allow for live updates in the application, but this spec is too narrow for what we want to accomplish. RethinkDB has the capability to do full LiveQuery, which we believe is immensely valuable to application developers, and it's important to us to bake it into the API. If we were to do it in GraphQL, we'd have to extend the spec, fork/hack Relay to operate over WebSockets, and maintain that fork until a full LiveQuery spec/implementation makes it into official GraphQL/Relay. That would be fairly challenging for us to do, and easy to mess up.\r\n- Relay/GraphQL says nothing about authentication and authorization, which is a crucial part of the design for a serverless app product. This isn't specific to GraphQL/Relay -- we'd have to design a good security model/APIs regardless of which protocol we use, but again, since GraphQL/Relay are fairly new and we have little experience with it, it would be very very easy for us to mess up the API.\r\n\r\nAll of the GraphQL/Relay decisions were made by @leebyron/Facebook's team explicitly and by design, and they all seem very smart to me. For example, if they overspecified the structure of the API, they'd significantly limit applicability of the technology; if they added LiveQuery support prematurely, there would be no practical way for 99% of the users to implement it; and if they added a security model, it wouldn't make very much sense since GraphQL is designed as a general purpose protocol.\r\n\r\nThe challenge for us, however, is to build a really great API/implementation to allow our users to build engaging, realtime serverless apps, and without having significant experience building GraphQL/Relay applications, this is a sisyphean task (since APIs are extremely easy to mess up).\r\n\r\nHere is our plan right now:\r\n\r\n- We will build a server-side API/implementation on top of WebSockets/REST -- this will allow us to design a great API because many of us are intimately familiar with these technologies, and the novelty of the protocol will not lead us to make rookie mistakes that will make the API unusable by pragmatic web developers who just want to build their apps.\r\n- We'll also build a JavaScript library that wraps this API on the front-end to let people get started building apps easily (again, this part we understand really well).\r\n- Once the feature is out and the API/security model is solidified, it will be dramatically easier for us to add a native GraphQL adapter. We will almost certainly follow up with a GraphQL implementation of the API after that (once the API is working and we have a lot more information).\r\n\r\nReally sorry to disappoint anyone who was hoping to get this feature in the short-term, but it's extremely important to us to design beautiful APIs that let people build engaging applications, and we're super-sensitive to how easy it is to screw that up. So unfortunately a full implementation based on the GraphQL protocol will take a little longer, but the good news is that you can be assured that once it's out, it will be really, *really* good."
  , issueCommentId = 151639571
  }