IssueComment
  { issueCommentUpdatedAt = 2015 (-09) (-24) 03 : 08 : 13 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 690517
        , simpleUserLogin = N "mike-marcacci"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/690517?v=3"
        , simpleUserUrl = "https://api.github.com/users/mike-marcacci"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/142790837"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3711#issuecomment-142790837"
  , issueCommentCreatedAt = 2015 (-09) (-24) 03 : 02 : 55 UTC
  , issueCommentBody =
      "As a reasonably active member of the RethinkDB community and a very new user of GraphQL, this issue got me very excited at first. However, I have developed some very real reservations about baking this into the RethinkDB core, and I'm a bit concerned that this initiative misinterprets the purpose of GraphQL.\r\n\r\nIn the past, I have rolled my own model systems on top of RethinkDB with similar schema and joining abilities as GraphQL. Despite the amazing flexibility of RQL and RethinkDB, there are implementation complexities that are not solved in RethinkDB and are out of the scope of GraphQL itself. One of these problems has already been discussed a bit in this thread \8211 authorization \8211 but the others have not: schema enforcement (writes, migrations), and data structure (embedded collections vs. new tables, relationship structure).\r\n\r\nIssues\r\n------\r\n\r\n### Authorization\r\nAuthorization is an especially complex beast because each application is going to have completely different rules and structures. It almost goes without saying that this belongs in the application layer, and is for the most part outside the scope of this issue. However, it's important to keep in mind that this flies in the face of any advantage gained by native RethinkDB support, as the application needs to interpret the GraphQL request anyhow (and might as well generate RQL).\r\n\r\n\r\n### Data Structure: Relationships\r\nOne of the key features of GraphQL is its ability to traverse relationships \8211 it is called **Graph**QL after all \8211 and at the moment RethinkDB doesn't have a way to internally mark relationships between documents. \r\n\r\nA solution for this might be to add an \"edge\" index type that links two tables (which sounds really cool as I think about it... perhaps I'll think it through more and make an issue) or a new `$reql_type$`. But without such a core feature, GraphQL is not possible.\r\n\r\n\r\n### Data Structure: Collections\r\nA key feature of document databases is the ability to store large, complex objects (or collections of objects) embedded inside documents. A graph database, on the other hand, emphesizes separation of objects and relating them.\r\n\r\nRethinkdb is a document database in true form, and on several occations I have seen performance improvements by embedding otherwise singlarly-relational data inside one document. More importantly, without [atomic multi-document updates](https://github.com/rethinkdb/rethinkdb/issues/4598) this is often a necessary design decision for data consistency.\r\n\r\n\r\n### Schema Enforcement: Writes\r\nObviously, a schema system (which I am TOTALLY for as a feature in its own rite) needs to be implemented for GraphQL types to work. This is a totally separate discussion: should this be GraphQL or json-schema? How should these be configured? What happens when a write fails checks? What happens to invalid documents when the schema is added? How does one change a schema?\r\n\r\n\r\n### Schema Enforcement: Migrations\r\nIn line with the last comment (but I think it deserves its own heading) is the issue of data migrations on schema changes. Is it safe to implicitly coerce data on its way out? Should we lock tables and perform alters \224 la typical SQL? Should we continue to serve old format, but inforce new writes?\r\n\r\nThese are all HUGE decisions that are prerequisite for GraphQL to become a core part of the database. While I am in favor of multi-document transactions, graph-database style edges and schema enforcments as individual features, they aren't (as far as I know) event close to being implemented.\r\n\r\n\r\nThe Purpose of GraphQL\r\n----------------------\r\nPlease forgive me if I'm wrong about this (I certainly don't work at Facebook) but my understanding is that GraphQL was designed to communicate with an API that contains application logic. While it could certainly be used for querying a logicless API (in this case a RethinkDB database), it feels odd to embed it in a database's core.\r\n\r\nThis is how I imagine most moderately complex GraphQL-based apps will end up working:\r\n\r\n```\r\n     _____________\r\n    |  RethinkDB  |\r\n     \8254\8254\8254\8254\8254\8254|\8254\8254\8254\8254\8254\8254\r\n           |------------------------ RQL\r\n __________|__________\r\n|   GraphQL Parsing   |\r\n|         and         |\r\n|  Application Logic  |\r\n \8254\8254\8254\8254\8254\8254\8254\8254\8254\8254|\8254\8254\8254\8254\8254\8254\8254\8254\8254\8254    SERVER\r\n-----------|------------------------ GraphQL\r\n     ______|______        CLIENT\r\n    |   Browser   |\r\n     \8254\8254\8254\8254\8254\8254\8254\8254\8254\8254\8254\8254\8254\r\n```\r\n\r\nTo even begin adding logic, the application needs to interpret GraphQL and act accordingly, and at this point it might as well build a RQL query.\r\n\r\n\r\nFinal Thoughts\r\n--------------\r\nI really hate to be such a downer, but the more I've thought about this, the more the idea concerns me.\r\n\r\nA quick comparison: When I tried out [Meteor](https://www.meteor.com/) for the first time, I was amazed by how easy it is to write the ubiquitous To-Do app: I fell in love with the ability to perform database queries from the front-end. But once I tried to secure my application, I was forced to rewrite all my logic as back-end functions, and use the front-end to call those... and before I knew it, I had no more front-end queries. I had lost everything that drew me to meteor in the first place. All their hard work on minimongo was left unused and wasted.\r\n\r\nI feel like this feature, while really awesome for ultra-simple To-Do style apps, has very little value for even moderately complex applications. Instead of coupling this to the RethinkDB core, I think it's best left to the application layer, or as a database plugin (which is a REALLY cool idea, btw).\r\n\r\nThe RethinkDb team could instead focus on implementing general-purpose features like transactions, schemas and document edges/relationships that would make writing a GraphQL plugin/library easier and more performant.\r\n\r\n\r\n"
  , issueCommentId = 142790837
  }