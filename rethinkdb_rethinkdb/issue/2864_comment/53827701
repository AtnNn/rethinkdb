IssueComment
  { issueCommentUpdatedAt = 2014 (-08) (-30) 01 : 23 : 40 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 552910
        , simpleUserLogin = N "Tryneus"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/552910?v=3"
        , simpleUserUrl = "https://api.github.com/users/Tryneus"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/53827701"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2864#issuecomment-53827701"
  , issueCommentCreatedAt = 2014 (-08) (-29) 01 : 28 : 25 UTC
  , issueCommentBody =
      "### Command\r\n\r\n`r.db(\8216rethinkdb\8217).table(\8216issues\8217) -> TABLE`\r\n\r\nThis table is read-only and will reject all write queries.  For the primary key, we have a few requirements:\r\n\r\n* The user should be able to obtain some ID for an issue\r\n* The user should be able to perform `r.db('rethinkdb').table('issues').get(<ID>)` to determine if the issue still exists.\r\n* This should work even when performed on a new connection or different server.\r\n\r\nAfter much soul-searching, I agree with @timmaxw's suggestion that we generate a primary key from the issue data itself.  Because most issues are generated locally and not sync'ed cross-cluster, most other methods are not deterministic enough.  In order to ensure uniqueness and not go over the primary key length limit, I believe we would need to hash the fields `[ 'type', 'info' ]` (see the Data section below) to generate a UUID.\r\n\r\n### Data\r\n\r\nEach row will have the following format, where `info` is filled with data based on the issue type:\r\n\r\n```js\r\n{\r\n    id: <UUID>,\r\n    type: <STRING>,\r\n    critical: <BOOL>,\r\n    time: <TIME>,\r\n    description: <STRING>,\r\n    info: <OBJECT>\r\n}\r\n```\r\n\r\n* `id` - the ID for this issue, generated from a hash of `type` and a subset of the data in `info`, specific to the issue type.\r\n* `type` - a terse string identifier for the type of issue (see Issue Types below).\r\n* `critical` - `true` if this issue could cause loss of availability, `false` otherwise\r\n* `time` - a Time object giving the server time that the issue was first detected at.  This will be different when requested from different servers.\r\n* `description` - a verbose string giving the rundown of what is wrong where and how to fix it.\r\n* `info` - an object containing all the relevant data for the issue at hand - a more programmatically useful version of `description`.  See Issue Types below for how this is given for each `type`.\r\n\r\n### Issue Types\r\n\r\n##### Server Down\r\n```js\r\n{\r\n    id: <UUID>,\r\n    type: 'server_down',\r\n    critical: true,\r\n    time: <TIME>,\r\n    description: 'Server <NAME> is inaccessible.',\r\n    info: {\r\n        server_id: <UUID>,\r\n        server: <STRING>\r\n    }\r\n}\r\n```\r\n\r\n`id` generated by a hash of `type` and `server_id`.\r\n\r\n##### Server Ghost\r\n````js\r\n{\r\n    id: <UUID>,\r\n    type: 'server_ghost',\r\n    critical: false,\r\n    time: <TIME>,\r\n    description: 'Server <NAME> was declared dead, but is still connected to the cluster.',\r\n    info: {\r\n        server_id: <UUID>,\r\n        server: <STRING>\r\n    }\r\n}\r\n```\r\n\r\n`id` is generated by a hash of `type` and `server_id`.\r\n\r\n##### Name Collision\r\n\r\nThere are separate issues for each type of object having a name collision, because they exist in separate namespaces.  They are `server_name_collision`, `db_name_collision`, and `table_name_collision`:\r\n\r\n```js\r\n{\r\n    id: <UUID>,\r\n    type: 'server_name_collision',\r\n    critical: true,\r\n    time: <TIME>,\r\n    description: 'The following servers are all named <NAME>: <IDS>.',\r\n    info: {\r\n        name: <STRING>,\r\n        ids: [ <UUID>, ... ]\r\n    }\r\n}\r\n```\r\n\r\n```js\r\n{\r\n    id: <UUID>,\r\n    type: 'db_name_collision',\r\n    critical: true,\r\n    time: <TIME>,\r\n    description: 'The following databases are all named <NAME>: <IDS>.',\r\n    info: {\r\n        name: <STRING>,\r\n        ids: [ <UUID>, ... ]\r\n    }\r\n}\r\n```\r\n\r\n```js\r\n{\r\n    id: <UUID>,\r\n    type: 'table_name_collision',\r\n    critical: true,\r\n    time: <TIME>,\r\n    description: 'The following tables are all named <NAME>: <IDS>.',\r\n    info: {\r\n        db: <STRING>,\r\n        db_id: <UUID>,\r\n        name: <STRING>,\r\n        ids: [ <UUID>, ... ]\r\n    }\r\n}\r\n```\r\n\r\n`id` is generated by a hash of `type` and `name` (and `db_id`, in the case of `table_name_collision`).\r\n\r\n##### Outdated Index\r\n```js\r\n{\r\n    id: <UUID>,\r\n    type: 'outdated_index',\r\n    critical: false,\r\n    time: <TIME>,\r\n    description: 'The following tables have outdated indexes.\\n\\tTable\\tIndexes\\n\\t<NAME>\\t<STRING>...',\r\n    info: {\r\n        tables: [\r\n            {\r\n                table: <STRING>,\r\n                table_id: <UUID>,\r\n                db: <STRING>,\r\n                db_id: <UUID>,\r\n                indexes: [ <STRING>, ... ]\r\n            }, ... ]\r\n    }\r\n}\r\n```\r\n\r\n`id` is generated by a hash of `type` only.  There is only ever 1 outdated index issue at a time.\r\n\r\n##### No Such Server\r\n```js\r\n{\r\n    id: <UUID>,\r\n    type: 'no_such_server',\r\n    critical: true,\r\n    time: <TIME>,\r\n    description: 'The configuration for the table <NAME> cannot find the server <NAME>.',\r\n    info: {\r\n        table: <STRING>,\r\n        table_id: <UUID>,\r\n        db: <STRING>,\r\n        db_id: <UUID>,\r\n        server: <STRING>\r\n    }\r\n}\r\n```\r\n\r\n`id` is generated by a hash of `type`, `server`, `table_id`, and `db_id`.\r\n\r\n### Open Questions\r\n\r\n* These are only the existing issues we have in `/ajax/issues` (minus `vector_clock_conflict`).  Should we add more, like `table_config_bad_server` mentioned by @timmaxw above?\r\n  - I feel like most of these are subsumed by `server_down` and `invalid_config`, but there may be something I'm not considering.\r\n* Descriptions still need helpful text on how to resolve them, but this could be an implementation detail.\r\n* How is this expected to be architected?\r\n  - I'm ok with having this just collect the issues from the `issue_aggregator` like `/ajax/issues` does, I don't see any big problems with that.\r\n\r\n\r\n"
  , issueCommentId = 53827701
  }