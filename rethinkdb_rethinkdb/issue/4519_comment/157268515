IssueComment
  { issueCommentUpdatedAt = 2015 (-11) (-17) 06 : 08 : 36 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 412608
        , simpleUserLogin = N "kamilion"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/412608?v=3"
        , simpleUserUrl = "https://api.github.com/users/kamilion"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/157268515"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4519#issuecomment-157268515"
  , issueCommentCreatedAt = 2015 (-11) (-17) 05 : 00 : 34 UTC
  , issueCommentBody =
      "Anyway, the main idea here is to pick a single cipher that is secure, flexible, operates as a component in a chain, and has support from most of the languages rethinkdb targets.\r\n\r\nOne could implement it as a datatype directly, as a subclass of the BINARY record type to protect data at-rest, as a stream cipher for data in-transit but not at-rest, in an authentication chain to provide boolean pass/fail, a double-decrypt as I described above where both parties perform the same dance (DH handshakes work in a similar vein), or many other combinations of access control and cryptography.\r\n\r\nKey escrow can be done in-process for performance or optionally out-of-process for additional security or utilizing a hardware assistance module.\r\n\r\nI would advocate against implementing something like the openssl cipher suite... It's too easy to misuse those components into something that wastes processor time giving you no real protection at all.\r\n\r\n**Pick something secure, *stick with it for ten years*.**\r\n\r\nSCRYPT's had a lot of rocks thrown at it, and it's always gotten right back up for another hit.\r\nIf it's good enough for litecoin, it should be good enough for rethinkdb...\r\n\r\nEdit: Also, if you're going to use it to do authentication/crypto and wish to retain plaintext compatibility, define a magic cookie value in the client driver, perhaps literally encrypted with the password \"I can't crypto\" or some other suitable shared plaintext, and have the client pass this to the server to SHUT OFF CRYPTO. That way security is preserved for clients that can crypto properly, while still allowing someone to forcibly (and obviously) disable it. Some people favor performance over security, and that should definitely be catered to -- openssh still allows disabling crypto mid-stream for SFTP traffic, *IF* the client bothers requesting it, asking for performance over security. In the same vein, someone could select blowfish for higher performance than the default AES256, without plaintext over the wire.\r\nYou get security by default, you have to ask for high performance. A good tradeoff, no?\r\n\r\nIt's going to be a breaking protocol change anyway to add RBAC and/or crypto; kill both birds with one stone.\r\n\r\nHere's an example of what I'm talking about, using an 'authentication' proxy server for a popular multiplayer game:\r\nhttps://github.com/StarryPy/StarryPy/blob/master/plugins/core/player_manager_plugin/plugin.py#L96\r\n\r\nLine 98 is a magic cookie that is \"too much of a pain\" to construct inside of a function.\r\nIt is a short circuit because this function is called (very often) when a client is banned (and such clients are often willing to try for hours to get back into a game server).\r\n\r\nDefinitely provide something like that in the documentation so that users wishing to retain performance over security are cared for. (And for folks implementing their own drivers, easier to start out with plaintext...)\r\n\r\nEdit2:\r\nThe beautiful thing about SCRYPT, however, is the way you tune it for performance or security. It's controlled quite intuitively -- a bound for the processing time is passed to the function.\r\n\r\nIf you wish to increase security, increase the time bound. Older blobs will still decrypt successfully below the time bound. Newer blobs will be encrypted at the new time bound rate.\r\n\r\nYou cannot decrease the time bound, however, as scrypt will start throwing errors during decryption that it wasn't able to complete enough work in the time allotted to decrypt the value successfully.\r\n\r\nStart out with a time bound of 0.1, this is quick enough for everyone to process. For users that wish to increase security, turn up the time bound to 0.5 seconds like my defaults, or increase security with a 1 second bound, or further still to a two second bound. This scales with processing power... If you crypt something with a 0.5 bound on a fast amd64, you might have to specify a 2 second bound on a raspberry pi to decrypt it successfully. As time goes by, your security naturally increases as your hardware evolves. Quite elegant in that there is only one real knob to turn, it's in a very human-centric value metric (seconds), and you almost never want to touch it unless you introduce drastically lesser-power machines into your cluster... (Like http://raspberrycolocation.com/  -- Quite amazing what four raspberry pi 2 boards do for the money! I don't think that provider has the newer quadcores yet, but if you hunt around, there's quite a few similar operations going on.)"
  , issueCommentId = 157268515
  }