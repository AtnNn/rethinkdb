IssueComment
  { issueCommentUpdatedAt = 2015 (-07) (-09) 20 : 26 : 32 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1366
        , simpleUserLogin = N "deontologician"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1366?v=3"
        , simpleUserUrl = "https://api.github.com/users/deontologician"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/120135861"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4519#issuecomment-120135861"
  , issueCommentCreatedAt = 2015 (-07) (-09) 20 : 26 : 32 UTC
  , issueCommentBody =
      "> It would also be great if we could make the auth key exchange more secure on the protocol level. Here's one proposal:\r\n1. When connecting, the server generates a cryptographic random string and sends it to the client (the challenge).\r\n2. The client concatenates the string with the auth key and hashes it using a secure hash function\r\n3. The client transmits the hash to the server, which verifies it\r\n\r\n> This removes the problem that we're transmitting the auth key in plain text over the network.\r\n\r\nDepending on how this is implemented, this could still open us up to replays. For this to work, the server would need to send a challenge for every query, otherwise anyone listening on the network could replay the hashed challenge+authkey to run any queries they wanted.\r\n\r\nPersonally, I feel like if we're going in the authorization direction, it seems like a good time to implement SSL on the server. It's kind of awkward to explain \"Well we restrict a user's access, but it's trivial to circumvent unless you do these extra steps\". People will assume it's secure because they have to provide a key."
  , issueCommentId = 120135861
  }