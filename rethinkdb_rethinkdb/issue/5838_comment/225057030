IssueComment
  { issueCommentUpdatedAt = 2016 (-06) (-09) 23 : 35 : 22 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/225057030"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5838#issuecomment-225057030"
  , issueCommentCreatedAt = 2016 (-06) (-09) 23 : 33 : 16 UTC
  , issueCommentBody =
      "I assumed this would be client-side, mostly because it's way easier to implement.\r\n\r\nIf we want to do this server-side, we'll need an additional evaluation step on the server I think, or some other significant change to how queries are executed (because there's no longer just a single \"compilation\" pass). I could be over-estimating the amount of work required though.\r\n\r\nWe could consider allowing the client to add \"annotations\" to terms that describe which `chain` command the terms originated from. Then the server could take those annotations into account when generating backtraces. I don't think this would actually be helpful though, as it would also make it harder to find out where exactly inside a query template the error occurred.\r\n(*Edit:* This is assuming that we would \"collapse\" the details of the `f` function passed to `chain` into a single `chain` item in the backtrace. However there might be better ways of printing chain-aware backtraces that don't lose any information)"
  , issueCommentId = 225057030
  }