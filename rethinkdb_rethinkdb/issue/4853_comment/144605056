IssueComment
  { issueCommentUpdatedAt = 2015 (-10) (-01) 03 : 17 : 03 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/144605056"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4853#issuecomment-144605056"
  , issueCommentCreatedAt = 2015 (-10) (-01) 03 : 17 : 03 UTC
  , issueCommentBody =
      "One thing to keep in mind is that if we ever want to add (even just limited/partial) support for referential integrity, having a less expressive reference format will actually make things easier.\r\n\r\nWe're having a similar problem with secondary indexes. Because they can be any function, and we don't distinguish between \"simple\" secondary indexes and arbitrary ones, it is very difficult to automatically deduce anything about them. This makes things like automatically utilizing secondary indexes in e.g. a `filter` query in the context of an optimizer difficult.\r\n\r\nI generally really like the possibilities of arbitrary references, but I think we should think a bit more about what our eventual goals for references are.\r\nIn some cases having a less expressive reference type might actually allow us to implement more features on top of it.\r\n\r\nIncidentally, some proposals discussed in https://github.com/rethinkdb/rethinkdb/issues/4598#issuecomment-140934070 are based on being able to represent a `db, table, primary_key` tuple. References would fit into there very nicely from an API standpoint, though that would only work with the simple type of references."
  , issueCommentId = 144605056
  }