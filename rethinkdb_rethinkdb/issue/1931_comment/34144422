IssueComment
  { issueCommentUpdatedAt = 2014 (-02) (-05) 07 : 53 : 54 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/34144422"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1931#issuecomment-34144422"
  , issueCommentCreatedAt = 2014 (-02) (-05) 07 : 53 : 54 UTC
  , issueCommentBody =
      "> How would NOINLINE cause the link-time optimizer to not inline the functions?\r\n\r\nI don't know. How would it cause the compile-time optimizer to not inline the functions? If you can figure out the latter, that's probably about the same as the former. I would think that it gets translated into some flag in the abstract intermediate representation that GCC uses (\"GIMPLE\" seems to be the relevant one here http://gcc.gnu.org/wiki/GIMPLE ). Both the compile-time as well as the link-time optimizer operate on that same representation in the case of GCC.\r\n\r\nIf your question is about *if* it works with link-time optimizations, then there is some strong evidence in favor of it in the fact that the Linux kernel patches for `-flto` support make heavy use of it: e.g. https://lkml.org/lkml/2012/8/18/210\r\n"
  , issueCommentId = 34144422
  }