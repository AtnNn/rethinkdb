IssueComment
  { issueCommentUpdatedAt = 2016 (-02) (-03) 00 : 42 : 56 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1441929
        , simpleUserLogin = N "jlhawn"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1441929?v=3"
        , simpleUserUrl = "https://api.github.com/users/jlhawn"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/178918111"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3151#issuecomment-178918111"
  , issueCommentCreatedAt = 2016 (-02) (-03) 00 : 41 : 02 UTC
  , issueCommentBody =
      "I am very interested in getting TLS working (or at least forking it and hacking together a build for my use case) and I would like some guidance from the maintainers on how to begin. I've started to familiarize myself with the code in `src/arch/io/network.hpp` and `src/arch/io/network.cc` and since openSSL is already a dependency (though I've seen other issues which talk about removing it) this looks like a good place to start adding openSSL integration for securing the `tcp_conn_t` type.\r\n\r\nMy main goal is to secure the intra-cluster connections with mutual TLS and secure the client driver to server connections with TLS with the option to require and verify a client cert (since RethinkDB already provides the existing authentication key method for authenticating clients).\r\n\r\n>> I think the pre-shared key might be the easiest option to do in practice for people who don't want to set up their own CA.\r\n>\r\n> For sure, the CA system might be easier to maintain for larger deployments but that can always be added later as a progressive enhancement.\r\n\r\nIf you all want to spend more time designing an alternative easy-to-bootstrap/setup system, that's fine, but it will still, in general, have to reduce down to the common TLS requirements that each side of the connection needs. PKI can seem unwieldy to those not familiar with it, but configuring it mostly boils down to having these 3 things:\r\n\r\n1. A private key (`key.pem`).\r\n2. A certificate signed by a trusted key (`cert.pem`).\r\n3. A bundle of those trusted public keys (`ca.pem`).\r\n\r\nFor your goal of easing setup, 2 and 3 could just be the same self-signed cert and you just need to distribute the private key to every server and/or client. You could even distribute them together in one PEM file. This is atypical though since the common security best-practice is for each party to have a its own private key, but at least the private key will never be transmitted over the network when clients connect, making it strictly better than the existing plaintext symmetric authentication key scheme in my opinion. \r\n\r\nSo for now I think it's best to work towards having the PKI/CA system that most everyone is already familiar with and expects when securing systems like this.\r\n\r\nFor securing the intra-cluster connections, each RethinkDB node needs a `key.pem` and `cert.pem` to authenticate to the peer, and a `ca.pem` to verify the peer's certificate against. We can add extra config file fields for these with the values being the path to these files. Each would have a corresponding command line argument when starting the server. If you want to go with standard names for these files then configuration is even simpler: just specify a directory containing these files.\r\n\r\nFor securing the client driver connections, each node would again need to know the key to use and the cert to present to the client, however, since most client drivers don't have support for mutual TLS (as far as I know most only have the ability to verify the server cert against a CA), client authentication would only be required if you specify a CA to verify the clients' certificate against. The (unofficial) Golang driver does seem to support mutual TLS authentication and this is what I use personally. In the case that the server does not authenticate client certs it would be highly recommended to use the authentication key method. Specifying the key, cert, and CA to use for client connections could also be added to the config file and command line args as separate arguments. This allows system administrators to use separate CAs for clients and nodes in the cluster, but there's no reason why you couldn't use the same values.\r\n\r\nI like using RethinkDB very much but not having TLS builtin is a complete showstopper for my team. Using tunnels/proxies to secure connections is not an option due to more stringent security requirements: we need end-to-end security at the application level. The way forward on this seems pretty clear to me, then again I may not be your target audience for what you're trying to do with the product - for example, I don't use the web UI and never intend to. I just want to build secure applications that use RethinkDB for highly-available storage and realtime change streams.\r\n\r\nHave any contributors already started working on this at all? (It has been almost a year and a half after all) I've already started looking into what would need to be done and I wouldn't mind contributing it back upstream. I've looked through the code and I can see why people may not be looking forward to modifying it with comments like:\r\n\r\n```c++\r\n/* linux_tcp_conn_t provides a disgusting wrapper around a TCP network connection. */\r\n```\r\n\r\nand method names like:\r\n\r\n```c++\r\nvoid linux_tcp_conn_descriptor_t::make_overcomplicated(scoped_ptr_t<linux_tcp_conn_t> *tcp_conn)\r\n```\r\n\r\nI haven't done any C++ in a few years but I'm pretty confident that I can get something acceptable with guidance.\r\n\r\nThanks."
  , issueCommentId = 178918111
  }