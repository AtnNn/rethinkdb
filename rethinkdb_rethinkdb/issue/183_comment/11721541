IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-27) 23 : 48 : 49 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 43867
        , simpleUserLogin = N "jdoliner"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/43867?v=3"
        , simpleUserUrl = "https://api.github.com/users/jdoliner"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11721541"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/183#issuecomment-11721541"
  , issueCommentCreatedAt = 2012 (-12) (-27) 23 : 48 : 49 UTC
  , issueCommentBody =
      "I think the special casing basically comes from a desire to have different defaults for different operations if we want to avoid special casing then it comes at the cost of making people explicitly say when they want to drop error rows I'm down for this but as you say people basically always want one behavior with filter and I think it's basically either special casing or an undesired default for one of them.\r\n\r\nBottom (haskell notation is to use the symbol \8869 so I'm going to save myself some typing) just gets propagated as an error. Part of an instance of \8869 is a textual description of why the computation will error if run. If functions are both lazy and pure. Which all of the functions we're talking about in these examples are then \8869 is actually equivalent to an exception in that it short circuits operations, basically once you get \8869 you stop reading of the stream so the rest of it doesn't get computed. However we should bear in mind that this short circuiting doesn't actually save us much computation due to sharding. We still compute the full thing for shards without errors and then throw that result out when we discover one has an error.\r\n"
  , issueCommentId = 11721541
  }