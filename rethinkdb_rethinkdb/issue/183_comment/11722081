IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-28) 00 : 19 : 33 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11722081"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/183#issuecomment-11722081"
  , issueCommentCreatedAt = 2012 (-12) (-28) 00 : 19 : 33 UTC
  , issueCommentBody =
      "> I think the special casing basically comes from a desire to have different defaults for different operations\r\n\r\nI think there are two types of special casing. One is when we arbitrarily change internal semantics to get the behavior we want. An example of this is throwing an error everywhere except in pluck and filter. I think we're all in agreement that this type of special casing is really bad.\r\n\r\nThe second type is when we introduce a primitive (such as bottom) that supports all possible use cases we might want to support, and then have library functions have different behavior built on top of this primitive. This seems perfectly reasonable to me because the behavior doesn't change arbitrarily -- the same behavior, for example, is available to the user (e.g. they could check for bottom in their expressions and do different things based on it, such as throw an error, while they can't catch errors and make decisions on top of them right now).\r\n\r\n> Part of an instance of \8869 is a textual description of why the computation will error if run.\r\n\r\nAh, makes sense.\r\n\r\n> once you get \8869 you stop reading of the stream so the rest of it doesn't get computed. \r\n\r\nOk, that makes sense too.\r\n\r\nSo then, how do we represent bottom on the client?"
  , issueCommentId = 11722081
  }