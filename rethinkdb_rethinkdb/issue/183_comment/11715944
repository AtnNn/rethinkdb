IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-27) 19 : 19 : 01 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 43867
        , simpleUserLogin = N "jdoliner"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/43867?v=3"
        , simpleUserUrl = "https://api.github.com/users/jdoliner"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11715944"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/183#issuecomment-11715944"
  , issueCommentCreatedAt = 2012 (-12) (-27) 19 : 19 : 01 UTC
  , issueCommentBody =
      "So treating missing attributes as `null` is actually a bad idea. I think the most compelling reason is that comparison functions work on it so if missing attributes defaulted to `null` then:\r\n\r\n    table.filter(lambda x: x[\"foo\"] < 5)\r\n\r\nwould return documents in which \"foo\" is either a number less than `5` or is missing. Which is not a behavior I think anyone would expect. Note that we need comparison with `null` to work otherwise grouped map reduce will fail if there's a `null` group. Basically we need to choose between `null` being used as a value for users or a value that we use to indicate internal errors and we're already a couple steps down the road it being a user value. And I think that's the right choice because it's part of JSON.\r\n\r\nSo here's how I understand the desired behavior:\r\n\r\nThus far I've only seen people want default attributes in `filter` I think in most other cases where you're using the value for something you want an error. For example dropping a row from a map reduce because of a missing attribute seems liable to confuse. So let's say for a first approximation the desired behavior is that filter applies a function to each row, `true` and `false` have the same meaning as before however if anywhere during evaluation of this function a missing attribute is accessed then the row is excluded.\r\n\r\nThis sounds a lot like an exception which `filter` implicitly catches and treats the same as the function returning `false` of course that means this is a somewhat heavyweight feature. \r\n\r\nAnother option would be something akin to haskell's bottom. Basically bottom is a special type that indicates \"this computation errors.\" If bottom is passed in to a function then it will return bottom so it gets propagated up and then `filter` could \"catch\" it by considering it akin to `false`. However this can lead to some confusing behavior if you have nested filters."
  , issueCommentId = 11715944
  }