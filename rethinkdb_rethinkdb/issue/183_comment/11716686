IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-27) 19 : 52 : 35 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 43867
        , simpleUserLogin = N "jdoliner"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/43867?v=3"
        , simpleUserUrl = "https://api.github.com/users/jdoliner"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11716686"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/183#issuecomment-11716686"
  , issueCommentCreatedAt = 2012 (-12) (-27) 19 : 52 : 35 UTC
  , issueCommentBody =
      "Bottom is alot like undefined except that it propagates itself. I think undefined is basically the correct idea except that it still has a few confusing behaviors. Most notably under negation for example suppose someone wanted to check if an attribute were within a range they might do:\r\n\r\n    filter(lambda x: low < x[\"foo\"] & x[\"foo\"] < high)\r\n\r\nThis returns false if \"foo\" is undefined which is what we want. However now suppose they want to filter to values outside of the range. They'll likely just invert the original predicate:\r\n\r\n    filter(lambda x: !(low < x[\"foo\"] & x[\"foo\"] < high))\r\n\r\nAnd now they're in a bit of trouble because this returns true if `foo` is undefined which I think is unexpected. However with bottom this would still return bottom which means it wouldn't be included in the filter.\r\n\r\nUndefined also does indeed compare equal to itself both under `==` and `===` so\r\n\r\n    filter(lambda x: x[\"foo\"] == x[\"bar\"])\r\n\r\nwould return documents for which both \"foo\" and \"bar\" are undefined which strikes me as unexpected."
  , issueCommentId = 11716686
  }