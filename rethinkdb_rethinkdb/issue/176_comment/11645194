IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-23) 11 : 30 : 07 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11645194"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/176#issuecomment-11645194"
  , issueCommentCreatedAt = 2012 (-12) (-23) 11 : 30 : 07 UTC
  , issueCommentBody =
      "> Personally, I think returning anything from an asynchronous method is kind of weird, as the returned object can only be used as soon as the callback has been called (and any error has been handled).\r\n\r\nIn case of rethink's node.js driver this isn't strictly true -- `run()` returns the cursor object immediately, and cursor's `next` method is asynchronous. This way you can say `cursor = query.run(); cusror.next(callback)`.\r\n\r\nMongo's syntax seems a little more complex to me because it requires two callbacks for `find` -- the initial one to get error or iterator, and then one per row on an iterator. In rethink you get the cursor right away (e.g., it isn't an async call), and accessing the cursor (via `next` or `collect`) actually requires async behavior and takes a callback.\r\n\r\nWhichever option we go with, this will definitely be overhauled as part of #140 -- thanks for reporting this!"
  , issueCommentId = 11645194
  }