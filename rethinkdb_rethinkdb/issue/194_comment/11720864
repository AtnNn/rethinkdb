IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-27) 23 : 09 : 34 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11720864"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/194#issuecomment-11720864"
  , issueCommentCreatedAt = 2012 (-12) (-27) 23 : 07 : 25 UTC
  , issueCommentBody =
      "I think we should do this right, and implement something reasonably general-purpose, such as mssql's `OUTPUT` command. This would work on bulk as well as single operations, and on things other than update (e.g. we might want to get deleted documents as we delete them, or replaced documents, etc.)\r\n\r\nWe could implement it as additional parameters to mutation commands, or as a chainable `.output(...)` command. One benefit of doing a general purpose system like this is that the user can pass a ReQL lambda that receives an old and new document, and then they can do any operation they want. For example:\r\n\r\n```\r\nr.table('foo').update(...).output(lambda old_row, new_row: ...).run()\r\n```\r\n\r\nThis way the user can return the old document, new document, any attributes they want, a sum of attributes, or really anything that strikes their fancy.\r\n\r\nEDIT: ideally we'd design this system in a way where our current json summary document (the one that returns number of inserted/update/deleted documents, errors, generated ids, etc.) could be implemented on top of this system."
  , issueCommentId = 11720864
  }