IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-28) 00 : 05 : 24 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11721825"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/194#issuecomment-11721825"
  , issueCommentCreatedAt = 2012 (-12) (-28) 00 : 05 : 24 UTC
  , issueCommentBody =
      "I can't exactly put my finger on why, but I'm not a particularly big fan of the `{ new: ..., old: ...}` paradigm. It's sort of \"outside\" of the spirit of ReQL, and it hardcodes some names into a new JSON document -- there's something strange about it. I never loved how we did it with `join`, and this is similar. \r\n\r\nI don't think the `output` proposal above is underpowered. Consider:\r\n\r\n```\r\ndo(lambda x,y: ...,\r\n    table.get(1).update(...).output(lambda o, n: { left: o, right: n}),\r\n    table.get(2).update(...).output(lambda o, n: { left: o, right: n}))\r\n```\r\n\r\nAlso:\r\n\r\n```\r\ntable.update(...).output(lambda o, n: { left: o, right: n}).group_map_reduce(...)\r\n```\r\n\r\nOf course this begs the question of why have output take the lambda command in the first place instead of just returning the `{new: ..., old: ...}` document. One thing we can do is use the new/old paradigm here, and then replace it everywhere later if/when we have a better solution.\r\n\r\nBTW, I don't think we should return this data by default, because 99% of the time the user won't want it. Presumably we could detect that by seeing if anything is chained after the modification command. If nothing is chained, perhaps the user would have to pass a flag to `run`."
  , issueCommentId = 11721825
  }