IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-27) 10 : 23 : 37 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 297060
        , simpleUserLogin = N "nviennot"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/297060?v=3"
        , simpleUserUrl = "https://api.github.com/users/nviennot"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11705024"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/194#issuecomment-11705024"
  , issueCommentCreatedAt = 2012 (-12) (-27) 10 : 23 : 37 UTC
  , issueCommentBody =
      "@al3xandru findAndModify() actually accept a \"new\" argument. c.f. http://docs.mongodb.org/manual/reference/command/findAndModify/\r\n\r\nIn the following sentence, assume a deterministic query update which is most of the time true (no `Math.rand()` for example). By knowing the update query and the original document right before the update, the user can figure out the value of the updated document. So granted, \"new\" is really just a nice to have.\r\n\r\nBut findAndModify can reveal itself to be quite useful:\r\n\r\nSuppose that you have an app that would give lottery tickets to people.\r\nHave a document with a field `lottery_tickets` which contains an\r\narray of tickets to be drawn, such as ` [4,3,1,7,5,8,10,2,6,9]`.\r\nEach participant would take a ticket by doing a `findAndModify(\"lottery_tickets.pop()\")`.\r\nIt would return the chosen number, and would be race free since rethinkdb serializes writes to the same document.\r\n\r\nHow to approach this use case with the rethinkdb api?\r\n\r\n--- \r\n\r\nthe \955 at the bottom right of the rethinkdb website\r\n/me amused"
  , issueCommentId = 11705024
  }