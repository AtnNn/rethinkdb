IssueComment
  { issueCommentUpdatedAt = 2016 (-06) (-15) 18 : 58 : 02 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 7431361
        , simpleUserLogin = N "larkost"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/7431361?v=3"
        , simpleUserUrl = "https://api.github.com/users/larkost"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/226286013"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5856#issuecomment-226286013"
  , issueCommentCreatedAt = 2016 (-06) (-15) 18 : 58 : 02 UTC
  , issueCommentBody =
      "And to put the conversation I had with @danielmewes into the record: my initial guess is that the memory spike is because we use a producer/consumer model, and on these systems the producer is reading much faster then the consumer can push out the door so the excess winds up building up in memory. \r\n\r\nAssuming that proves to be the main problem then it would be easy to switch away from `multiprocessing.SimpleQueue` to `multiprocessing.Queue` which has the option to limit the number of items in-flight. That switch would require some testing, as I am uncertain why `SimpleQueue` was chosen in the first place. There could be demons waiting in the corners."
  , issueCommentId = 226286013
  }