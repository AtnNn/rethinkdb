IssueComment
  { issueCommentUpdatedAt = 2015 (-05) (-18) 19 : 35 : 26 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 265071
        , simpleUserLogin = N "kofalt"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/265071?v=3"
        , simpleUserUrl = "https://api.github.com/users/kofalt"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/100543240"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4150#issuecomment-100543240"
  , issueCommentCreatedAt = 2015 (-05) (-09) 20 : 36 : 57 UTC
  , issueCommentBody =
      "I applaud the forward motion on getting query optimization into RethinkDB. As an author of a framework whose usage of RDB is 100% dynamically generated, I feel this proposal is in the right direction - but will need some adjustment to inspire joy rather than pain. \r\n\r\nTo demonstrate, here is my rough code design (draft only!) for using this feature as proposed:\r\n\r\n1. At program launch, consume a script-generated or RDB-api-provided set of indexes on each table.\r\n1. Begin constructing a query. Add `begin_optimizer()`.\r\n1. When adding each Term, perform the following:\r\n  1. Cross-index the implied table and desired operation with set of known indexes.\r\n  1. Add index optarg if there's a match.\r\n  1. Place the new Term in a buffer for optimized or un-optimized Terms.\r\n1. Unroll the optimized buffer, add `end_optimizer()`, unroll the un-optimized buffer.\r\n1. Execute; monitor deployments for slow queries.\r\n\r\nAdvocates of explicit index use might be laughing right about now :) This is obviously not complete and does not handle AST nesting - say, branches. I really would rather not write clumsy AST-buffering logic to try & massage a query into an optimizer block whitelist. \r\n\r\nThe reason for the query construction shenanigans is to keep application logic from knowing about indexes. I assert that **maintaining an arbitrary many-to-many mapping in unrefactorable function call optargs is an absolute anathema for maintainability and sanity**. I want *no part* in writing an application whose performance utterly depends upon every developer and refactor correctly (manually!) correlating a 30-to-300 or 300-to-3000 index:query ratio.\r\n\r\nOne's team will inevitably make a mistake, and will probably result in a tool that can parse your application code to look for written (static) queries and cross-reference it with known indexes. I am reminded of laboriously adding type assertions in a dynamic language, lacking a compiler to do it automatically.\r\n\r\nAdding or removing any index implies a potential code diff in every portion of an application's persistence layer. Contrast this difficult to validate, change-management nightmare with:\r\n\r\n1. Construct a SQL statement.\r\n1. Execute; monitor deployments for slow queries.\r\n\r\nI think this gets into dev vs ops: correctness & performance are two different concerns. The developer has the most complete information for making a query correct; I assert that (in many cases) the database has the most complete information for making a query performant.\r\n\r\n@mlucy has provided some excellent points on the flip side of this assertion. My primary response to his post would be that optimizers should offer the option of returning the result query: remove concerns about magic by exposing the resultant transform. I've used this exact behavior before to great effect with a traditional RDBMS in Fortune 100 deployments. That said, your assertion that \"choosing indexes is usually too important of a decision to be done automatically under the hood in all cases\" is reasonable, and I completely understand wanting to support that scenario.\r\n\r\nThe good news is that I think RDB can be perfectly capable of supporting both opinions, and we needn't debate philosophy to accomplish our goals. Changes that would make my approach significantly easier - while leaving @coffeemug's original intentions largely intact - are, in rough order of scope:\r\n\r\n1. Allow `begin_optimizer()` ... `end_optimizer()` to contain non-indexed Terms. API contract could be that any & all Terms inside the optimizer block get re-ordered. More complicated than the proposed mandated whitelist, as the reordering has to be AST-equivalent (nested Terms, branching).\r\n\r\n1. Given the above, for most queries I would have most / all of the query in an optimizer block... at which point a query optarg `optimize=true` as shorthand starts to make sense.\r\n\r\n1. As mentioned previously, it would be great to have a query optarg that returns the query actually executed after optimization. I feel this would go a long way towards alleviating hidden-magic concerns.\r\n\r\n1. The golden pony would be something like #2356, with an optarg on the optimizer block (or the entire query) adding indexes to Terms that lack them. Doing this outside the database, in a 'userland' query construction library, is simply never going to be optimal. I realize this one sounds unlikely :)\r\n\r\nAdding merely the first component would eliminate the increased complexity burden this proposal currently threatens. I have a full application (and a happy developer team!) churning along with queries ignorant of indexes, which get added later by a library. Adding in an RDB optimizer is highly desirable. \r\n\r\nIdeally, these proposed tweaks would allow for both usage types to gain increased database functionality."
  , issueCommentId = 100543240
  }