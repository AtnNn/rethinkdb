Issue
  { issueClosedAt = Just 2016 (-08) (-11) 20 : 45 : 39 UTC
  , issueUpdatedAt = 2016 (-08) (-11) 20 : 45 : 39 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/5948/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/5948"
  , issueClosedBy = Nothing
  , issueLabels = []
  , issueNumber = 5948
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "`r.turing`"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/5948"
  , issueCreatedAt = 2016 (-07) (-14) 02 : 36 : 39 UTC
  , issueBody =
      Just
        "`input.turing(machine)` evaluates the turing machine specified by `machine` (see below) on the initial tape given by `input` (an array of integers). It then returns an array representing the prefix of the tape that has been accessed by the machine. If the input is rejected, an exception is thrown.\n\n`machine` is an object as follows:\n\n``` js\n{\n  blank_symbol: int,\n  transitions: [\n    {\n      from_state: int,\n      read_symbol: int,\n      to_state: int,\n      write_symbol: int,\n      move_head: \"L\"|\"R\"\n    },\n    ...\n  ],\n  initial_state: int,\n  final_states: [int, ...]\n}\n```\n## \n\nThe implementation is simply as a query rewrite in terms of other ReQL operations.\n\nSome helper functions:\n\n``` js\nvar initialState = { tape: input, state: machine.initial_state, head_position: 0 };\n\n// Reads the current symbol from the tape.\nvar readSymbol = function(state) {\n    return state('tape').nth(state('head_position')).default(machine.blank_symbol);\n  };\n\n// Tests whether the given transition applies to the current state.\nvar checkRule = function(state, rule) {\n    return state('state').eq(rule('from_state')).and(readSymbol(state).eq(rule('read_symbol')));\n  };\n\n// Selects an applicable transition.\nvar selectRule = function(state) {\n    return r.expr(machine.transitions)\n      .concatMap(function(rule) {\n        return r.branch(checkRule(state, rule), [rule], []);\n      })\n      .nth(0)\n      .default(r.error(\"No applicable rule. Input rejected.\"));\n  };\n\n// Writes `newSymbol` to the current head position and returns the new tape.\nvar writeTape = function(state, newSymbol) {\n  // Note that head_position is never larger than the current tape length\n  var mustAppend = state('tape').count().eq(state('head_position'));\n  return r.branch(\n    mustAppend,\n    state('tape').append(newSymbol),\n    state('tape').changeAt(state('head_position'), newSymbol));\n};\n\n// Applies the given transition to the given state, and returns a new state.\nvar applyRule = function(state, rule) {\n  return {\n    tape: writeTape(state, rule('write_symbol')),\n    state: rule('to_state'),\n    head_position: state('head_position').add(r.branch(rule('move_head').eq(\"L\"), -1, 1))\n  };\n};\n```\n\nThe actual query:\n\n``` js\nr.range()\n .fold(\n   initialState,\n   function(state, _ignored) {\n     // Select a transition and compute the new state by applying it.\n     var selectedRule = selectRule(state);\n     return applyRule(state, selectedRule);\n   },\n   {\n     emit: function(_ignored, _ignored2, state) {\n       // Check if we have reached a final state. If yes, accept the input by emitting the current tape.\n       return r.branch(\n         r.expr(machine.final_states).contains(state('state')),\n         [state('tape')],\n         []);\n     }\n   }\n )\n .limit(1) // Stop as soon as we get to an accepted state\n```\n\n**Note:** This is not an actual serious proposal. I just thought it was cool that you could do this in ReQL.\n\n**Warning**: Don't run this on a production server. It's easy to end up with a query that never terminates, and I'm not sure if those queries can be interrupted.\n"
  , issueState = "closed"
  , issueId = Id 165463450
  , issueComments = 2
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 706854
                , simpleUserLogin = N "AtnNn"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/706854?v=3"
                , simpleUserUrl = "https://api.github.com/users/AtnNn"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 1
          , milestoneNumber = 18
          , milestoneClosedIssues = 180
          , milestoneDescription =
              Just
                "These feature requests, bugs and pull requests have been acknowledged, but will not be fixed."
          , milestoneTitle = "wontfix"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/18"
          , milestoneCreatedAt = 2013 (-03) (-29) 20 : 23 : 24 UTC
          , milestoneState = "closed"
          }
  }