Issue
  { issueClosedAt = Just 2016 (-08) (-11) 20 : 45 : 39 UTC
  , issueUpdatedAt = 2016 (-08) (-11) 20 : 45 : 39 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/5948/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/5948"
  , issueClosedBy = Nothing
  , issueLabels = []
  , issueNumber = 5948
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "`r.turing`"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/5948"
  , issueCreatedAt = 2016 (-07) (-14) 02 : 36 : 39 UTC
  , issueBody =
      Just
        "`input.turing(machine)` evaluates the turing machine specified by `machine` (see below) on the initial tape given by `input` (an array of integers). It then returns an array representing the prefix of the tape that has been accessed by the machine. If the input is rejected, an exception is thrown.\r\n\r\n`machine` is an object as follows:\r\n```js\r\n{\r\n  blank_symbol: int,\r\n  transitions: [\r\n    {\r\n      from_state: int,\r\n      read_symbol: int,\r\n      to_state: int,\r\n      write_symbol: int,\r\n      move_head: \"L\"|\"R\"\r\n    },\r\n    ...\r\n  ],\r\n  initial_state: int,\r\n  final_states: [int, ...]\r\n}\r\n```\r\n\r\n--\r\n\r\nThe implementation is simply as a query rewrite in terms of other ReQL operations.\r\n\r\nSome helper functions:\r\n```js\r\nvar initialState = { tape: input, state: machine.initial_state, head_position: 0 };\r\n\r\n// Reads the current symbol from the tape.\r\nvar readSymbol = function(state) {\r\n    return state('tape').nth(state('head_position')).default(machine.blank_symbol);\r\n  };\r\n\r\n// Tests whether the given transition applies to the current state.\r\nvar checkRule = function(state, rule) {\r\n    return state('state').eq(rule('from_state')).and(readSymbol(state).eq(rule('read_symbol')));\r\n  };\r\n\r\n// Selects an applicable transition.\r\nvar selectRule = function(state) {\r\n    return r.expr(machine.transitions)\r\n      .concatMap(function(rule) {\r\n        return r.branch(checkRule(state, rule), [rule], []);\r\n      })\r\n      .nth(0)\r\n      .default(r.error(\"No applicable rule. Input rejected.\"));\r\n  };\r\n\r\n// Writes `newSymbol` to the current head position and returns the new tape.\r\nvar writeTape = function(state, newSymbol) {\r\n  // Note that head_position is never larger than the current tape length\r\n  var mustAppend = state('tape').count().eq(state('head_position'));\r\n  return r.branch(\r\n    mustAppend,\r\n    state('tape').append(newSymbol),\r\n    state('tape').changeAt(state('head_position'), newSymbol));\r\n};\r\n\r\n// Applies the given transition to the given state, and returns a new state.\r\nvar applyRule = function(state, rule) {\r\n  return {\r\n    tape: writeTape(state, rule('write_symbol')),\r\n    state: rule('to_state'),\r\n    head_position: state('head_position').add(r.branch(rule('move_head').eq(\"L\"), -1, 1))\r\n  };\r\n};\r\n```\r\n\r\nThe actual query:\r\n```js\r\nr.range()\r\n .fold(\r\n   initialState,\r\n   function(state, _ignored) {\r\n     // Select a transition and compute the new state by applying it.\r\n     var selectedRule = selectRule(state);\r\n     return applyRule(state, selectedRule);\r\n   },\r\n   {\r\n     emit: function(_ignored, _ignored2, state) {\r\n       // Check if we have reached a final state. If yes, accept the input by emitting the current tape.\r\n       return r.branch(\r\n         r.expr(machine.final_states).contains(state('state')),\r\n         [state('tape')],\r\n         []);\r\n     }\r\n   }\r\n )\r\n .limit(1) // Stop as soon as we get to an accepted state\r\n```\r\n\r\n**Note:** This is not an actual serious proposal. I just thought it was cool that you could do this in ReQL.\r\n\r\n**Warning**: Don't run this on a production server. It's easy to end up with a query that never terminates, and I'm not sure if those queries can be interrupted."
  , issueState = "closed"
  , issueId = Id 165463450
  , issueComments = 2
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 706854
                , simpleUserLogin = N "AtnNn"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/706854?v=3"
                , simpleUserUrl = "https://api.github.com/users/AtnNn"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 1
          , milestoneNumber = 18
          , milestoneClosedIssues = 180
          , milestoneDescription =
              Just
                "These feature requests, bugs and pull requests have been acknowledged, but will not be fixed."
          , milestoneTitle = "wontfix"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/18"
          , milestoneCreatedAt = 2013 (-03) (-29) 20 : 23 : 24 UTC
          , milestoneState = "closed"
          }
  }