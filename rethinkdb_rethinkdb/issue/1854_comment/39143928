IssueComment
  { issueCommentUpdatedAt = 2014 (-03) (-31) 21 : 23 : 37 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/39143928"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1854#issuecomment-39143928"
  , issueCommentCreatedAt = 2014 (-03) (-31) 21 : 23 : 37 UTC
  , issueCommentBody =
      "One way to think about this is to enumerate functions where `r.args` is useful.  A few:\r\n* `r.get_all`\r\n* `r.object`\r\n* Predicates like `eq` (you can write `r.eq(r.args(arr))` to check that all the values in the array are equal).\r\n* `with_fields`, `has_fields`, `pluck`, `without`, `order_by`, `group`, etc. (anything that takes `n` fields).\r\n* `and`, `or`\r\n* `contains`\r\n* `sindex_status`, `sindex_wait`\r\n\r\nAnother way, though, is to observe that basically every dynamic language I can think of has run into this problem and solved it in the same way (`*` in Ruby, `,@` in CL, etc.).  It isn't language-breaking magical syntax; it's just useful syntax that people are already used to from their client language."
  , issueCommentId = 39143928
  }