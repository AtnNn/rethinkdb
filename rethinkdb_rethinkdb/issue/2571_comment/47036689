IssueComment
  { issueCommentUpdatedAt = 2014 (-06) (-24) 22 : 00 : 00 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47036689"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2571#issuecomment-47036689"
  , issueCommentCreatedAt = 2014 (-06) (-24) 22 : 00 : 00 UTC
  , issueCommentBody =
      "Ok, here is a new proposal. I've tried to incorporate many of the suggestions. Please let me know if I forgot something.\r\n\r\nIt's a copy of the initial ones, but changed sections are marked with *CHANGED* or *NEW*.\r\n\r\n#### Geospatial data representation\r\n\r\n* Support Points, LineStrings and Polygons compatible to GeoJSON ([Wikipedia](http://en.wikipedia.org/wiki/GeoJSON), [full specs](http://geojson.org/geojson-spec.html) ).\r\n* Define a new ReQL geometry pseudo-type\r\n* Provide two functions to convert from/to GeoJSON:\r\n  * `r.geoJSON(object) : object -> geometry` converts from the GeoJSON object `object` to the geometry pseudo type\r\n  * `r.geoJSON(string) : string -> geometry` (optional): equivalent to `r.geoJSON(r.json(string))`\r\n  * `geometry.toGeoJSON() : geometry -> object` does the opposite of `r.geoJSON(object)`\r\n* Provide constructors:\r\n  * `r.geoPoint(long, lat) : float, float -> geometry`\r\n  * `r.geoLine(p1, p2, ...) : geometry, geometry, ... -> geometry` where the input arguments must be points\r\n  * `r.geoLine([long1, lat1], [long2, lat2], ...) : [float, float], [float, float], ... -> geometry`\r\n  * `r.geoPolygon(p1, p2, ...) : geometry, geometry, ... -> geometry` where the input arguments must be points\r\n  * `r.geoPolygon([long1, lat1], [long2, lat2], ...) : [float, float], [float, float], ... -> geometry`\r\n  * `polygon1.sub(polygon2) : geometry, geometry -> geometry` subtracts polygon2 from polygon1. For now, we should make the following requirement: polygon2 must be completely inside of polygon1. This allows to construct polygons with holes in them.\r\n  * *CHANGED* For convenience: `r.geoCircle(center, radius, {num_vertices: ...}) : geometry, float -> geometry`, `r.geoRectangle(bottomLeft, upperRight) : geometry, geometry -> geometry` create a line describing the corresponding shape. Can be combined with `fill()` (see Misc) to get spheres / filled rectangles. TODO: We have to define some unit for the radius. One way would be the distance as a fraction of the circumference of the reference sphere (earth). If we want to use absolute units (miles, km), we would need a way to define the reference circumference (using earth's by default). A third option is specifying distances in terms of the angle between two points on a sphere's surface (with the sphere's center as the third point)\r\n\r\n#### Creating a geospatial index\r\n* *CHANGED* `r.indexCreate(field/function, {geospatial: true})`\r\n* *CHANGED* `r.indexCreate([field1, field2, ...]/function, {geospatial: true})` creates a compound index. The geometry must *always* be in `field1`! The remaining fields will be indexed like in a regular index.\r\n* *CHANGED* Documents for which the field is not a geometry object are ignored in such an index.\r\n* *CHANGED* For a non-geospatial index, geometry objects are either ignored or be handled like objects (slightly related to #1032)\r\n* *CHANGED* You *cannot* apply orderBy to a geospatial index.\r\n\r\n#### Misc\r\n* *CHANGED* `p1.distance(p2) : geometry, geometry -> float` computes the minimal geodesic distance between points p1 and p2. Let's ignore distances to/between polygons and lines for now. Other coordinate systems can be supported through opt args later. TODO: The same considerations regarding units as for `r.circle()` apply. We have to sort this out.\r\n* `l.fill() : geometry -> geometry` Takes a line, makes it the outline of a polygon. The line has to be closed (and possibly must not intersect with itself, not sure about that yet).\r\n* *CHANGED* `polygon.contains(geometry) : geometry, geometry -> bool` tests whether geometry is completely contained in polygon\r\n* `geometry1.intersects(geometry2) : geometry, geometry -> bool` tests whether geometry1 and geometry2 intersect\r\n* Bonus (not geospatial): `set1.contains(set2) : array, array -> bool` `contains()` for two arrays. Tests whether all elements of set1 are found in set2.\r\n* Bonus (not geospatial): `set1.intersects(set2) : array, array -> bool` `intersects()` for two arrays.\r\n\r\n#### Querying\r\n* *CHANGED* Thinking about it again, I think what @mlucy said makes sense. We only need intersection or equality for querying a geo index, nothing else. Filtering by containment can be done by post-filtering in ReQL for now (it would be implemented internally through post-filtering anyway, only intersection would actually be accelerated by an index).\r\n* *CHANGED* `r.getAll(value, {index: ...})` when applied to a geo index queries by *equality* to value.\r\n* *NEW* `r.getIntersecting(polygon, {index: ...})` must be applied to a geo index. Finds all geometry that intersects\r\n* *NEW* `r.getIntersecting([polygon, value2, value3, ...], {index: ...})` same for a compound geo index. Returns the same as `r.getIntersecting(polygon, {index: ...}).filter(r.and(r.row(field2).eq(value2), r.row(field3).eq(value3), ...))` when applied to a corresponding non-compound index on only the geometry field.\r\n* *CHANGED* `r.orderFrom(p, {index: ...})` gets the documents in ascending distance from point p. The most useful application of this is probably a \"nearest neighbor\" query. (Note: For internal reasons, there will be a limit on the number of documents you can read from the resulting stream. It has to do a lazy `distinct()` internally.)"
  , issueCommentId = 47036689
  }