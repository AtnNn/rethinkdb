IssueComment
  { issueCommentUpdatedAt = 2014 (-07) (-03) 08 : 21 : 46 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47879439"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2571#issuecomment-47879439"
  , issueCommentCreatedAt = 2014 (-07) (-03) 08 : 21 : 46 UTC
  , issueCommentBody =
      "> Why should `getAll()` not work to query the value by the value of a geo index just like you can use it to query by the value of a non-geo index?\r\n\r\n@mlucy convinced me that geo indexes are somewhat special, and should be queried by a set of special commands dedicated to geo querying. Because to create an index (under my proposal above) you pass the lambda to a `geo` optarg, it seems natural to introduce a set of geo querying primitives, and chain on `.between` and `.getAll` to use compound indexes on top of that. Allowing `getAll` on that would break this abstraction.\r\n\r\nNote that under this proposal you can still put a geo object in a regular index and query it with `getAll` for equality. It's just weird to allow that for a geo index.\r\n\r\n> I don't like `getIntersecting` with the `exact: true` flag. That sounds like a contradiction to me, because it's not doing an intersection test anymore but a different kind of test (a more strict one).\r\n\r\nI agree, this is a bit weird. Can you think of a better name for the optarg, or a good name for a `getExact` command that would do this?\r\n\r\n> As discussed above I prefer `toGeoJSON` over `toJSON`.\r\n\r\nSorry, I missed your previous comment on this. I don't feel that strongly about this any more, so I retract my objection."
  , issueCommentId = 47879439
  }