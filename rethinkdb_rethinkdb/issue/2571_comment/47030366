IssueComment
  { issueCommentUpdatedAt = 2014 (-06) (-24) 21 : 02 : 36 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1461947
        , simpleUserLogin = N "neumino"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1461947?v=3"
        , simpleUserUrl = "https://api.github.com/users/neumino"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47030366"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2571#issuecomment-47030366"
  , issueCommentCreatedAt = 2014 (-06) (-24) 21 : 02 : 36 UTC
  , issueCommentBody =
      "> Any secondary index can store geospatial data\r\n\r\nThat sounds like a bad idea. It's pretty different than https://github.com/rethinkdb/rethinkdb/issues/1032\r\n\r\nIf you store other values in the tree, it means that they will get returned with an `orderBy`. If you consider `distance < anything_that_is_not_a_distance` , then it works fine when you look for the closest neighbors, but miserably fails when you look for the furthest neighbors.\r\n\r\nAlso, last time I tried Mongo, it did not create a geo index if one of my document's field was not a location.\r\n\r\n> `geometry.isContained(polygon)`\r\n\r\nCould we have `polygon.contains(geometry)` instead? It's nicer to write, and easier to understand I think.\r\n\r\n> About compound index, maybe we should do something like that\r\n\r\n```\r\n// Compound index fullName: [doc(\"firstName\"), doc(\"lastName\")]\r\nr.table(\"users\").getAll(\"Michel\", {index: \"fullName\"}).getAll(\"Tu\", {index: \"fullName\"})\r\n```\r\nOr we could explicitly use indices, or use objects instead of arrays (and build two trees?).\r\n\r\nWithout considering implementation, the syntax for a compound index that includes a geospatial index would be\r\n```\r\nr.table(\"users\").getAll(\"Michel\", {index: \"nameGeo\"}).insersects(somePolygon, {index: \"nameGeo\")\r\n```\r\n\r\nAnd we can also replace intersects with a kind of orderBy.\r\n\r\n- About getting the closest neighbors, could we have something like\r\n```\r\nr.table(\"users\").orderFrom(aPoint. {index: \"location\"})\r\n```\r\n\r\n\r\nOne more question\r\n- Can we ship a table with locations names?\r\nSo we can write queries like\r\n```\r\nr.table(\"users\").getAll(r.table(\"location\").get(\"France\"), {index: \"location\"})\r\n```"
  , issueCommentId = 47030366
  }