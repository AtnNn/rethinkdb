IssueComment
  { issueCommentUpdatedAt = 2014 (-06) (-27) 19 : 40 : 45 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47298184"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2571#issuecomment-47298184"
  , issueCommentCreatedAt = 2014 (-06) (-27) 01 : 05 : 32 UTC
  , issueCommentBody =
      "Here's a new updated proposal.\r\n\r\n##### Changes from previous proposal:\r\n- Added a section on distance units\r\n- Fixed ordering of latitude / longitude parameters to adhere to standard recommendations\r\n- Geometry objects are handled like regular objects in non-geo indexes\r\n- Renamed `contains` to `includes` to avoid conflict with existing function\r\n- Removed `set_intersects()` from the proposal to keep the proposal a little smaller. We can add and discuss that separately at a later point.\r\n- Added a `fill` opt arg to `circle()` and `rectangle()`\r\n- Removed the `geo` prefix from constructors\r\n- Renamed `orderFrom` to `getNearest`\r\n- Added a `maxResults` opt-arg to `getNearest`. We will have such a limit internally, and so it makes sense to make users aware of it and make it configurable. You can still chain `.limit()` behind it of course to get a smaller number of results.\r\n- Added compound index syntax to `getNearest`\r\n\r\n##### Suggestions not yet considered:\r\n- I didn't include @neumino's suggestion for allowing to chain `getAll()` and `getIntersecting()`. Also no GeoHash yet (I imagine that could be added later, as it doesn't seem essential to the initial functionality).\r\n- I didn't change compound index querying to the `tags` / `sub_index` syntax.\r\n- I didn't rename `toGeoJSON` to `toJSON` as suggested by @coffeemug, because GeoJSON is a very specific format. It's not just any JSON, it is a standardized way of representing geometry inside of JSON (http://http://geojson.org). @coffeemug: You say you feel strongly about this. Do you still uphold that given that GeoJSON is a specific standard and can actually be considered a feature of RethinkDB if it is supported (a user has specifically asked for it in the other thread)?\r\n\r\n\r\n### Proposal\r\n\r\n#### Geospatial data representation\r\n\r\n* Support Points, LineStrings and Polygons compatible to GeoJSON ([Wikipedia](http://en.wikipedia.org/wiki/GeoJSON), [full specs](http://geojson.org/geojson-spec.html) ).\r\n* Define a new ReQL geometry pseudo-type\r\n* Provide two functions to convert from/to GeoJSON:\r\n  * `r.geoJSON(object) : object -> geometry` converts from the GeoJSON object `object` to the geometry pseudo type\r\n  * `r.geoJSON(string) : string -> geometry` (optional): equivalent to `r.geoJSON(r.json(string))`\r\n  * `geometry.toGeoJSON() : geometry -> object` does the opposite of `r.geoJSON(object)`\r\n* Provide constructors:\r\n  * `r.point(lat, long) : float, float -> geometry`\r\n  * `r.line(p1, p2, ...) : geometry, geometry, ... -> geometry` where the input arguments must be points\r\n  * `r.line([lat1, long1], [lat2, long2], ...) : [float, float], [float, float], ... -> geometry`\r\n  * `r.polygon(p1, p2, ...) : geometry, geometry, ... -> geometry` where the input arguments must be points\r\n  * `r.polygon([lat1, long1], [lat2, long2], ...) : [float, float], [float, float], ... -> geometry`\r\n  * `polygon1.sub(polygon2) : geometry, geometry -> geometry` subtracts polygon2 from polygon1. For now, we should make the following requirement: polygon2 must be completely inside of polygon1. This allows to construct polygons with holes in them.\r\n  * `r.circle(center, radius, {num_vertices: ..., fill: true/false, unit: ..., geoSystem: ...}) : geometry, float -> geometry`. Also see section below on distances.\r\n  * `r.rectangle(bottomLeft, upperRight, {fill: true/false}) : geometry, geometry -> geometry` create a line describing the corresponding shape\r\n\r\n#### Creating a geospatial index\r\n* `r.indexCreate(field/function, {geo: true})`\r\n* `r.indexCreate([field1, field2, ...]/function, {geo: true})` creates a compound index. The geometry must *always* be in `field1`! The remaining fields will be indexed like in a regular index.\r\n* Documents for which the field is not a geometry object are ignored in such an index.\r\n* For a non-geospatial index, geometry objects are handled like objects without a meaningful order\r\n* You *cannot* apply `orderBy` or `between` to a geospatial index.\r\n\r\n#### Misc\r\n* `p1.distance(p2, {unit: ..., geoSystem: ...}) : geometry, geometry -> float` computes the minimal geodesic distance between points p1 and p2. Also see section on distances.\r\n* `l.fill() : geometry -> geometry` Takes a line, makes it the outline of a polygon. The line has to be closed (and possibly must not intersect with itself, not sure about that yet).\r\n* `polygon.includes(geometry) : geometry, geometry -> bool` tests whether geometry is completely contained in polygon\r\n* `geometry1.intersects(geometry2) : geometry, geometry -> bool` tests whether geometry1 and geometry2 intersect\r\n\r\n#### Querying\r\n* We only support intersection or equality for querying a geo index. Filtering by containment can be done by post-filtering in ReQL for now (it would be implemented internally through post-filtering anyway, only intersection would actually be accelerated by an index).\r\n* `r.getAll(value, {index: ...})` when applied to a geo index queries by *equality* to value.\r\n* `r.getIntersecting(polygon, {index: ...})` must be applied to a geo index. Finds all geometry that intersects\r\n* `r.getIntersecting([polygon, value2, value3, ...], {index: ...})` same for a compound geo index. Returns the same as `r.getIntersecting(polygon, {index: ...}).filter(r.and(r.row(field2).eq(value2), r.row(field3).eq(value3), ...))` when applied to a corresponding non-compound index on only the geometry field.\r\n* `r.getNearest(p, {index: ..., maxResults: ...})` gets the documents in ascending distance from point p. The most useful application of this is probably a \"nearest neighbor\" query. For internal reasons, there is a limit on the number of documents you can read from the resulting stream. This limit can be configured by setting the `maxResults` opt arg, with some reasonable default.\r\n\r\n#### Distances\r\nOperations that rely on distances (`r.circle()` and `distance()`) accept opt args as follows:\r\n* `geoSystem`\r\n  * `\"WGS84\"`/`\"wgs84\"` (default). WGS84 defines a reference earth ellipsoid which we will use for distance calculations. It is the most commonly used standard as far as I know. See http://en.wikipedia.org/wiki/World_Geodetic_System\r\n  * `\"unitSphere\"` a perfect sphere of 1 km radius\r\n* `unit`\r\n  * `\"km\"` (default) kilometers\r\n  * `\"mi\"` international miles, see http://en.wikipedia.org/wiki/Mile\r\n  * `\"nm\"` nautical miles\r\n  * `\"degrees\"` angle between two surface points from the center of the sphere/ellipsoid in degrees (TODO: Might have to imply `geoSystem: \"unitSphere\"`, will have to think about that a bit more)"
  , issueCommentId = 47298184
  }