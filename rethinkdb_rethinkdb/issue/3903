Issue
  { issueClosedAt = Just 2015 (-07) (-28) 01 : 22 : 25 UTC
  , issueUpdatedAt = 2015 (-07) (-28) 01 : 22 : 25 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/3903/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/3903"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "e10c02"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/pr:high"
          , labelName = "pr:high"
          }
      , IssueLabel
          { labelColor = "fbda04"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/st:review"
          , labelName = "st:review"
          }
      , IssueLabel
          { labelColor = "007575"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:API_settled"
          , labelName = "tp:API_settled"
          }
      , IssueLabel
          { labelColor = "e102d8"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:bug"
          , labelName = "tp:bug"
          }
      , IssueLabel
          { labelColor = "0052cc"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:ReQL_proposal"
          , labelName = "tp:ReQL_proposal"
          }
      ]
  , issueNumber = 3903
  , issueAssignee =
      Just
        SimpleUser
          { simpleUserId = Id 1777134
          , simpleUserLogin = N "mlucy"
          , simpleUserAvatarUrl =
              "https://avatars.githubusercontent.com/u/1777134?v=3"
          , simpleUserUrl = "https://api.github.com/users/mlucy"
          , simpleUserType = OwnerUser
          }
  , issueUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "`squashing_queue_t` ordering/starvation issue"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/3903"
  , issueCreatedAt = 2015 (-03) (-07) 00 : 47 : 38 UTC
  , issueBody =
      Just
        "`squashing_queue_t` (which we use to implement `squash: true`) doesn't preserve ordering of changes.  (It just stores them in a big map to squash them together.)  This has two problems:\r\n\r\n* It's unintuitive in the simple case where no changes are squashed (how to order changes to different keys when squashing occurs is sort of non-obvious, but if no squashing occurs then the results are very confusing).\r\n* There are starvation problems -- if someone is reading keys almost exactly as fast as the server is generating them, they will never get to the end of the queue, so changes that happen to large `store_key_t`s will basically never be sent.\r\n\r\nWe should also consider adding a `{state: consistent}` message when `include_states: true` is used that will let you know when you've emptied the squashing queue.  This is important to know because if there are still entries in the squashing queue, then after applying all the changes you've gotten you'll be in a state that might never have existed, but if the queue is empty then you're in a state that the database was in at some point in time.  For example:\r\n\r\n```rb\r\nr.table('test').insert({id: 0, a: 0})\r\nr.table('test').insert({id: 1, a: 0})\r\n\r\nchanges = r.table('test').changes.run\r\n\r\nr.table('test').get(0).update({a: 1})\r\nr.table('test').get(1).update({a: 1})\r\nr.table('test').get(0).update({a: 2})\r\n```\r\n\r\nIf we squash the first and third change together, and you've only received that change, then you'll see a state `[{id: 0, a: 2}, {id: 1, a: 0}]` which never existed in the history of the database, and might be confusing because it violates some constraints you've put on your writes.  (If we put the squashed write after the unsquashed write instead of before the same problem exists in reverse.)  `{state: 'consistent'}` would only be sent after you'd received both the squashed and unsquashed change (because the queue would be empty), and would let you know that you're seeing a state that actually existed at some point."
  , issueState = "closed"
  , issueId = Id 60180560
  , issueComments = 19
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 316661
                , simpleUserLogin = N "timmaxw"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/316661?v=3"
                , simpleUserUrl = "https://api.github.com/users/timmaxw"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 0
          , milestoneNumber = 95
          , milestoneClosedIssues = 217
          , milestoneDescription =
              Just "To-do list before shipping auto-failover"
          , milestoneTitle = "2.1"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/95"
          , milestoneCreatedAt = 2015 (-03) (-04) 21 : 09 : 42 UTC
          , milestoneState = "closed"
          }
  }