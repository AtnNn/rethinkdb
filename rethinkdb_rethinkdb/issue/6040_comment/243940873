IssueComment
  { issueCommentUpdatedAt = 2016 (-09) (-01) 23 : 15 : 49 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 167416
        , simpleUserLogin = N "VeXocide"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/167416?v=3"
        , simpleUserUrl = "https://api.github.com/users/VeXocide"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/243940873"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/6040#issuecomment-243940873"
  , issueCommentCreatedAt = 2016 (-09) (-01) 00 : 18 : 55 UTC
  , issueCommentBody =
      "## Classes\r\n\r\n### Use `class` if the class has an invariant; use `struct` if the data members can vary independently\r\n\r\nIn the former example the members can be modified independently. Moreover, any invariants on the members, such as the age being a positive number, are enforced by their respective type.\r\n\r\nIn the latter example there are invariants on the combination of members, the valid values of `day_` depend on the value of `month_`. Secondly there are invariants on each member, `month_` must be between one and twelve.\r\n\r\n```\r\nstruct user_t {\r\n    std::string name;\r\n    uint8_t age;\r\n};\r\n\r\nclass date_t {\r\npublic:\r\n    // Add constructors and members here.\r\n\r\nprivate:\r\n    int16_t year_;\r\n    int8_t month_;\r\n    int8_t day_;\r\n};\r\n```\r\n\r\n## Resource management\r\n\r\n### A raw pointer (a `T *`) and raw reference (a `T &`) are non-owning\r\n\r\nContrary to a smart pointer such as a `std::unique_ptr<T>` (or `scoped_ptr_t<T>`) a raw pointer or raw reference does not own the object they reference.\r\n\r\n### Use `lifetime_t` to emphasize storage of a raw pointer or raw reference\r\n\r\nIf a class holds on to a raw pointer or a raw reference for its lifetime accept that via a `lifetime_t`, forcing the user to use `make_lifetime` and consider the lifetime of the argument.\r\n\r\nHere `foo` stores `bar` for the duration of its life, meaning that `bar` must outlive it. Forcing the user of `foo_t` to use `make_lifetime` should have them verify this is the case.\r\n\r\n```\r\n#include <containers/lifetime.hpp>\r\n\r\nclass foo_t {\r\npublic:\r\n    foo_t(lifetime_t<bar &> bar) : bar_(bar) { }\r\n\r\nprivate:\r\n    bar_t &bar_;\r\n};\r\n\r\nbar_t bar;\r\nfoo_t foo(make_lifetime(bar));\r\n```\r\n\r\n### No `static_cast<bool>` for optionals.\r\n\r\nA `static_cast<T>` explicitly overrides the C++ type system which should be done with restraint, and is unnecessary here. Instead we do an explicit comparison to `boost::none` similar to the existing rule of explicitly comparing pointers to `nullptr`.\r\n\r\n```\r\nboost::optional<int> count;\r\nif (count == boost::none) {\r\n    // Handle boost::none.\r\n} else {\r\n    // Handle count.get().\r\n}\r\n```\r\n\r\nWhile `boost::optional<T>` has an explicit, and thus safe, conversion to `bool` in C++ we felt this didn't make it clear enough that you were dealing with an `optional` contrary to anything else implicitly convertible to `bool`. The explicit comparison also fails to compile if the type is later changed to anything else that's implicitly convertible.\r\n\r\n### Use pointers for out, and in-out parameters\r\n\r\nPointers shall be used for out and in-out parameters. Furthermore these shall be postfixed with `_out` or `_in_out` as applicable.\r\n\r\n```\r\nfoo(int *bar_out) {\r\n    *bar_out = 23;\r\n}\r\n\r\nint bar;\r\nfoo(&bar);\r\n```\r\n\r\nThis is such that one can tell from the call-site of a function which parameters might get modified in-place by the function call, those passed by pointer.\r\n\r\n## Naming\r\n\r\n### Class member names\r\nClass member names shall be postfixed with an underscore.\r\n\r\nThis prevents conflicts with class methods and allows you to easily distinguish between class members and method arguments.\r\n\r\n```\r\nclass foo_t {\r\nprivate:\r\n    int bar_;\r\n};\r\n```\r\n\r\n### Non-`const` references\r\nNon-`const` references shall be postfixed with `_ref` to indicate that modifying the value of such a reference can have non-local side effects. Note that via the above rule regarding class member names one can have a postfix of `_ref_`.\r\n\r\n```\r\nclass foo_t {\r\n    foo_t(int &bar_ref) : bar_ref_(bar_ref) { }\r\n\r\nprivate:\r\n    int &bar_ref_;\r\n};\r\n```\r\n\r\n### Macro names\r\nMacro names shall be ALL_CAPS.\r\n\r\n```\r\n#define STRINGIZE(text) #text\r\n```"
  , issueCommentId = 243940873
  }