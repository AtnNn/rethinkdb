IssueComment
  { issueCommentUpdatedAt = 2012 (-11) (-16) 10 : 41 : 05 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/10443038"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/52#issuecomment-10443038"
  , issueCommentCreatedAt = 2012 (-11) (-16) 10 : 37 : 17 UTC
  , issueCommentBody =
      "Okaaay. I don't understand the full nature of this problem nor of the fix. So the fix might well be incomplete. It might have side-effects (though I cannot think of any).\r\n\r\nFirst, this is what fixes the problem for me:\r\nin mirrored.cc, method mc_inner_buf_t::allocate, the else case, right behind \"inner_buf->data_token.reset();\", add the following lines:\r\n\r\n    ...\r\n    inner_buf->snap_refcount = 0;\r\n    inner_buf->block_sequence_id = NULL_BLOCK_SEQUENCE_ID;\r\n    inner_buf->data_token.reset();\r\n        \r\n    // Is this the fix?\r\n    inner_buf->writeback_buf().set_dirty(true);\r\n    inner_buf->writeback_buf().set_recency_dirty(true);\r\n    inner_buf->writeback_buf().set_needs_flush(true);\r\n\r\n    return inner_buf;\r\n    ...\r\n\r\nI'm unsure whether the set_recency_dirty and set_needs_flush are required. The last one is important for patches only, which seem to be disabled by default. I didn't test if it is required with patches enabled or not, but it shouldn't hurt either I think.\r\n\r\nOk, here's a bit of background for this part of the code. It is all from my memories, so things might have slightly changed or I might mix up some details. Anyway, let's start with what happens when you delete a block.\r\n\r\n1. You acquire a lock on the buf and set the do_delete flag to true.\r\n\r\n2. When you release the buf (mc_buf_lock_t::release()), the command to delete is passed on to the writeback, which later passes it on to the serializer. This happens though the line \"inner_buf->writeback_buf().mark_block_id_deleted()\".\r\nImportant: When the writeback happens, and the writeback sees that the block is tagged for deletion, it releases the block id (writeback_t::do_concurrent_flush()).\r\n\r\n3. Now we should also delete the inner_buf, because the block associated with it has been deleted. However things get more complicated here, and that is due to snapshots:\r\nIf there are snapshots of the buffer around (inner_buf->safe_to_unload() returns false then), we cannot delete the inner_buf from memory yet. The snapshots are still using it, even though the most current version has been deleted. So we have to stick with it for a little (or much) longer.\r\n\r\n4. Let's say somebody else now allocates a new block. We assume that the writeback for the deleted block has already gone through, so that someone has a chance to get the block id of the block that was previously deleted. And this is what the else-branch in mc_inner_buf_t::allocate is all about. If this happens, we don't actually create a new inner_buf (which wouldn't work, because for each block_id we can only have one inner_buf in the cache at any time). We instead reset the existing one (that merely contains snapshots at this point), so it can be re-used.\r\nNow what my change from above does is that it makes sure that in such a case, the re-used block gets serialized during the next writeback, thereby also undoing the deletion in the serializer.\r\n\r\nHowever this shouldn't be necessary. First we don't seem to set_dirty in the other alternative, where we allocate a fresh inner_buf. And that one doesn't seem to cause any problems. Second, everybody who allocates a fresh block should also initialize it before releasing the lock on it. When it gets initialized (either by applying patches or through get_data_major_write() ), set_dirty should be called anyway.\r\nThis is what I don't understand, and why this fix might not actually fix the right thing. I'm passing this to @jdoliner to investigate further. (I might also have another look later)\r\n\r\nA last note:\r\nOne might suggest: Why can't we wait with marking the block_id_deleted() until the inner_buf is completely released (including all of its snapshots)? This would simplify stuff a lot, wouldn't it?\r\nUnfortunately we cannot. The reason for this is that the last transaction that releases the buffer might not be the write transaction (the one that marked the inner_buf for deletion in the first place). It might be just a regular non-privileged snapshot or rwi_read_outdated_ok transaction. If such a read-only transaction would tell the writeback to delete a block, terrible things could happen. Primarily, it wouldn't synchronize with the flush lock and could mess up a running writeback. Many other pieces of code might break in subtle ways if read transactions suddenly trigger writebacks.\r\n(Something related answers @srh 's comment in mirrored.cc \"// TODO(sam): Shouldn't these already be set somehow?\" No, we cannot because then the block_id would be freed even though there's still a mc_buf_lock_t in rwi_write mode held on the current version of the block. The next one who needs a new block might then get the same block id where somebody else is still holding a write lock on. Scary...)"
  , issueCommentId = 10443038
  }