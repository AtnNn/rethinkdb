IssueComment
  { issueCommentUpdatedAt = 2012 (-11) (-13) 11 : 04 : 07 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/10322538"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/52#issuecomment-10322538"
  , issueCommentCreatedAt = 2012 (-11) (-13) 10 : 59 : 40 UTC
  , issueCommentBody =
      "Ok, I can reproduce this rather reliably now.\r\n1. Enable AGGRESSIVE_BUF_UNLOADING in the buffer cache\r\n2. Start with a completely fresh database, two servers\r\n3. Run the stress client as described above\r\n4. After a few seconds, raise the number of shards to 4 (restart stress client afterwards)\r\n5. Keep enabling and disabling replication (set replicas to 2 and 1 respectively). Make sure that the stress client is restarted whenever it terminates due to aborted transactions.\r\n6. Watch the database being corrupted.\r\n\r\nMy best guess is a race with replication / backfilling.\r\n\r\n(by the way: I'd recommend adding a line guarantee(data_token); to line 166 of mirrored.cc between the index_read and the block_read. This gives a slightly more graceful crash on corrupted database files (i.e. no seg fault). Corrupted database files might be encountered occasionally even in the absence of any bug in RethinkDB after all.)"
  , issueCommentId = 10322538
  }