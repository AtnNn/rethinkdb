IssueComment
  { issueCommentUpdatedAt = 2015 (-08) (-14) 15 : 06 : 23 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 297060
        , simpleUserLogin = N "nviennot"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/297060?v=3"
        , simpleUserUrl = "https://api.github.com/users/nviennot"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/128055788"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4630#issuecomment-128055788"
  , issueCommentCreatedAt = 2015 (-08) (-05) 16 : 16 : 42 UTC
  , issueCommentBody =
      "We shouldn't try to support all the different I/O flavors the user would want.\r\nI think we should support an asynchronous flavored run, which the blocking behavior is implemented by the callbacks. The original blocking run() would be implemented using it.\r\n\r\nPractically, I would rename `em_run` to `async_run`, and remove any EventMachine references in the code. It is not useful for the RethinkDB driver. The driver would operate as such:\r\n\r\n```ruby\r\ndef async_run(query, options, handler=SyncHandler.new)\r\n  ...schedule query to run...\r\n  return handler\r\nend\r\n\r\ndef run(query, options, handler=SyncHandler.new)\r\n  async_run(query, options, handler).wait\r\nend\r\n```\r\n\r\nSupport we have a Handler interface defined as such:\r\n\r\n```ruby\r\n# Handler interface\r\nclass Handler\r\n  # For simplicity, I'm assuming we can only get back a single value from the\r\n  # database, excluding streams, so we don't have to deal with cursors in the\r\n  # following code.\r\n\r\n  def on_value(val)\r\n    # called from the RethinkDB thread\r\n  end\r\n\r\n  def on_error(err)\r\n    # called from the RethinkDB thread\r\n  end\r\n\r\n  def wait\r\n    # not a callback, but a way to block until we have some values.\r\n    # This is called by the synchronous version of run().\r\n    # It should return the received value, or raise received errors.\r\n    # Just like futures/promises.\r\n  end\r\nend\r\n```\r\n\r\nTo provide the original behavior of `run()`, the driver could internally use the following synchronous handler.\r\n\r\n```ruby\r\nclass SyncHandler < Handler\r\n  def initialize\r\n    @mutex = Mutex.new\r\n    @cond = ConditionVariable.new\r\n  end\r\n\r\n  def on value(val)\r\n    @mutex.synchronize do\r\n      @value = val\r\n      @cond.signal\r\n    end\r\n  end\r\n\r\n  def on error(err)\r\n    @mutex.synchronize do\r\n      @error = err\r\n      @cond.signal\r\n    end\r\n  end\r\n\r\n  def wait\r\n    @mutex.synchronize do\r\n      @cond.wait(@mutex)\r\n    end\r\n\r\n    raise @error if @error\r\n    return @value\r\n  end\r\nend\r\n```\r\n\r\nThe user could implement such Handler when using EventMachine (This could be provided by the RethinkDB driver as well):\r\n\r\n```ruby\r\nclass EventMachineHandler < Handler\r\n  def initialize(success_cb, error_cb)\r\n    @success_cb = success_cb\r\n    @error_cb = error_cb\r\n  end\r\n\r\n  def on value(val)\r\n    EM.schedule { @success_cb.call(val) }\r\n  end\r\n\r\n  def on error(err)\r\n    EM.schedule { @error_cb.call(err) }\r\n  end\r\n\r\n  def wait\r\n    raise NotImplementedError\r\n  end\r\nend\r\n```\r\n\r\nNow with EventMachine and em-synchony (uses Fibers):\r\n\r\n```ruby\r\nclass EventMachineSyncHandler < Handler\r\n  def initialize\r\n    @ready = EventMachine::DefaultDeferrable.new\r\n  end\r\n\r\n  def on value(val)\r\n    @ready.succeed(val)\r\n  end\r\n\r\n  def on error(err)\r\n    @ready.succeed(err)\r\n  end\r\n\r\n  def wait\r\n    value = EM::Synchrony.sync(@ready)\r\n    raise value if value.is_a?(Exception)\r\n    value\r\n  end\r\nend\r\n```\r\n\r\nThe driver should not worry about what the user wants in terms of blocking\r\nsemantics. It should be abstracted away in the Handler interface.  Note that\r\nthis also provides asynchronous capabilities without the use of EventMachine.\r\nThe following example would run two queries in parallel with the SyncHandler:\r\n\r\n```ruby\r\nhandler1 = query.async_run()\r\nhandler2 = query.async_run()\r\n\r\nvalue1 = handler1.wait\r\nvalue2 = handler2.wait\r\n```\r\n"
  , issueCommentId = 128055788
  }