IssueComment
  { issueCommentUpdatedAt = 2013 (-10) (-04) 19 : 03 : 51 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 43867
        , simpleUserLogin = N "jdoliner"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/43867?v=3"
        , simpleUserUrl = "https://api.github.com/users/jdoliner"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/25722784"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1511#issuecomment-25722784"
  , issueCommentCreatedAt = 2013 (-10) (-04) 19 : 03 : 51 UTC
  , issueCommentBody =
      "I actually agree with @atnnn here even though it was originally my proposal. Having `r.any = r.any(*(arg.map(lambda x: x.default(False))))` seems good until you add in negation. Either we accept that in some cases `r.any(expr) == r.any(!expr)` which I think sucks or we also rewrite `r.not(x)` to be `r.not(x.default(True))`. For example: `r.not({}[\"foo\"] != 5) = False` meaning `{}[\"foo\"]` is not not equal to `5` which is to say it is equal to `5`. At least it would be in a world where negating twice was a no-op. But we will have exited such a world if we implement this.\r\n\r\nI think the filter semantics we have no are already confusing but it's such a commonly hit problem that we need to do something and what we do do is something that can probably be explained in a few sentences. This is a much less commonly hit problem, and we'd be doing something that's several times as complicated and would require paragraphs to explain. It's just not worth it, it's going to make people's lives harder."
  , issueCommentId = 25722784
  }