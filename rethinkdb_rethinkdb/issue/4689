Issue
  { issueClosedAt = Nothing
  , issueUpdatedAt = 2016 (-04) (-29) 21 : 02 : 41 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/4689/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/4689"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "02e10c"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:enhancement"
          , labelName = "tp:enhancement"
          }
      ]
  , issueNumber = 4689
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 148955
        , simpleUserLogin = N "jcw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/148955?v=3"
        , simpleUserUrl = "https://api.github.com/users/jcw"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "Connect to MQTT?"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/4689"
  , issueCreatedAt = 2015 (-08) (-14) 21 : 45 : 41 UTC
  , issueBody =
      Just
        "For applications where more and more of the code is moving into the browser (SPA's, React, etc), and given that they can connect via http and websockets, would it be an idea to have RethinkDB talk to an MQTT pub-sub broker such as Mosquitto?\r\n\r\nThe scenario being: `server = rethinkdb + mqtt + static-assets-http-server`, with browsers connecting through a websocket to MQTT to deal with real-time feeds (using various QoS modes), and going _through_ MQTT for database CRUD + query operations.\r\n\r\nIt may sound like an odd mix, but for a low-power server such as a Raspberry Pi, the combination of rethinkdb/pub-sub/httpd could be all that's needed, and each of these can be _very_ efficient and low on resource requirements.\r\n\r\nIt's quite easy to turn a C/C++ app into an MQTT client through the libmosquitto packet. Another option would be to run a separate app sitting between db and pub-sub, but that involves more moving parts. Then again, such a bridge could include httpd functionality, and store all assets in the db as well.\r\n\r\nAny thoughts on this? Has this been done before? I'd be grateful for any pointers/tips..."
  , issueState = "open"
  , issueId = Id 101108152
  , issueComments = 6
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 48436
                , simpleUserLogin = N "coffeemug"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/48436?v=3"
                , simpleUserUrl = "https://api.github.com/users/coffeemug"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 882
          , milestoneNumber = 2
          , milestoneClosedIssues = 0
          , milestoneDescription =
              Just
                "Issues in this milestone are not an immediate priority, and will be periodically revisited. When we decide to work on an issue in backlog, we'll move it to next."
          , milestoneTitle = "backlog"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/2"
          , milestoneCreatedAt = 2012 (-11) (-11) 14 : 16 : 11 UTC
          , milestoneState = "open"
          }
  }