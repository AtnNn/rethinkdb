IssueComment
  { issueCommentUpdatedAt = 2013 (-04) (-09) 02 : 01 : 09 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/16090133"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/353#issuecomment-16090133"
  , issueCommentCreatedAt = 2013 (-04) (-09) 02 : 01 : 09 UTC
  , issueCommentBody =
      "Certain RQL API functions take lambda functions as arguments. Since `FUNCALL` is the simplest one of these I'll use it as an example as expressed in the Python driver.\r\n\r\nTake the following query\r\n```python\r\nr.expr(\"str\").do(lambda x: x)\r\n```\r\n\r\nThis translates to a `FUNCALL` with the following structure (simplifying the datum terms a bit):\r\n```\r\nFUNCALL { FUNC { [1], VAR [1] }, \"str\" }\r\n```\r\n\r\nThe `FUNCALL` term itself just applies it's first argument (a function) to it's other arguments (in this case, the string \"str\"). Other terms also take functions but have different semantics. `MAP` takes a sequence (an array or a stream derived from a database table) and applies it's function to each element in the sequence to produce a new sequence.\r\n\r\nIn it's protobuf representation, the `FUNC` term has two components. The first is an array of argument names, given as integers. The second is the term that defines the body of the function. When evaluated, the arguments to the function are bound to the names given in the array and then the body term is evaluated giving the return value of the function. The `VAR` term is evaluated by looking up it's associated variable name (here 1) in the current execution environment.\r\n\r\nSo how does this play out in this example? Here the `FUNCALL` binds the argument \"str\" to the variable name 1. It then evaluates the term defining the body of the function, the `VAR [1]`. This looks up the variable 1 from the environment, currently bound to \"str\" and returns it.\r\n\r\nIt get's a lot trickier when you nest functions because you have to be sure not to shadow variable names. Consider the following example:\r\n\r\n```python\r\nr.expr(1).do(lambda x: x.do(lambda y: x))\r\n```\r\nWhich translates to\r\n```\r\nFUNCALL { FUNC { [1], FUNCALL { [2], VAR { 1 } } }, 1 }\r\n```\r\n\r\nThe Python driver, responsible for assigning variable names, uses a global counter to assign a unique name to each function argument. If it were to restart the numbering for each function then the first argument of the inner function would also be assigned the number 1. We would then not be able to tell which argument the term `VAR [1]` is meant to refer to.\r\n\r\nIn the original source code of course the programmer has assigned the names `x` and `y` to disambiguate the two arguments but the driver has no access to the original argument names at run time. The simplest way to resolve the problem is to guarantee unique variable names and the simplest way to do that is with a global counter.\r\n\r\n---\r\n\r\nThe other big question is just how the driver translates a Python `lambda` expression into a RQL anonymous function. This is done identically in the other drivers so I'll just stick to Python.\r\n\r\nWe start by assigning unique names to the arguments expected by the function and then construct the `VAR` terms referring to those names. Then the magic happens. We simply call the lambda function on those variable references and use the value returned by the lambda function as the body of the RQL function.\r\n\r\nThe previous examples don't actually show this that well since they simply return their argument so consider the following:\r\n\r\n```python\r\nr.expr(1).do(lambda x: x + 1)\r\n```\r\n\r\nFirst a variable reference is constructed and then it is passed to the lambda function `lambda x: x + 1`. The body of the lambda function invokes the `__add__` method on the variable reference and `1`. Because the `VAR` term object passed into the function is just another RQL AST node the `__add__` method behaves just as if we'd written `r.expr(1) + 1` and constructs an `ADD` term with the `VAR` term and `1` as the arguments. This `ADD` term then becomes the body of the RQL function, effectively encapsulating the computation represented by the original Python lambda function!\r\n\r\n---\r\n\r\nSo how does this apply to your first question about averaging a field name. In Python, finding the average value of a field name for all rows of a table would look like this:\r\n\r\n```\r\nr.table('table').map(lambda x: x['field']).reduce(lambda a,b: a + b) / r.table('table').count()\r\n```\r\n\r\nThis query makes use of two lambda functions in the service of the common map-reduce pattern. The first applies a `GETATTR` to each row in the table. Here the field is passed in as a literal value but could also be any term that evaluates to a string, including a variable reference. The second applies `ADD` to it's two arguments. The `REDUCE` term repeatedly calls this function on values in the stream until it produces a single value, here the sum of the values of 'field' for each row in the table. The final step (for the sake of completeness) is to divide this sum by the number of rows in the table to give the average value.\r\n\r\n\r\nI hope that this answers your questions. Please let me know if there's anything else I can explain."
  , issueCommentId = 16090133
  }