IssueComment
  { issueCommentUpdatedAt = 2013 (-04) (-09) 21 : 37 : 30 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/16141981"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/353#issuecomment-16141981"
  , issueCommentCreatedAt = 2013 (-04) (-09) 21 : 37 : 30 UTC
  , issueCommentBody =
      "As @jdoliner mentioned, the server analyzes your query before execution to determine which terms cannot be proved deterministic. Non-deterministic terms include those that have side effects (write queries like `insert` or `update`) and those whose value may depend on external input. Pretty much anything can happen within a snippet of JavaScript including a call to `Math.random` which draws on external entropy to determine it's value. Since all `JAVASCRIPT` terms are black boxes from the perspective of the RQL query engine they are considered non-deterministic by default even if some (such as `r.js(\"1 + 1\")`) may indeed be deterministic. Even proving simple cases such as this are hard to do programmatically.\r\n\r\nDeterminism checking is an important part of RQL query execution because determinism gives us a lot of scope for optimization. The most commonly understood optimization enabled by this is memoization whereby the value of a pure-function (or deterministic RQL sub-query) is cached to avoid the cost of re-executing the function. In almost the opposite case, we can rely on the fact that deterministic terms can be re-evaluated many times and still return the same value to distribute an unevaluated term across the cluster to be simply re-executed when needed. While this might sound counterintuitive as an optimization strategy, this property can be used to increase parallelization by eliminating sequential dependencies on the value of a single term. RethinkDB tries to distribute your query across the cluster as much as possible but can be prevented from doing so by a non-deterministic term. Relying a non-deterministic term deep in your query could force most of the execution to take place on a single server.\r\n\r\n---\r\n\r\nOn a different note, I should have included something about JavaScript functions earlier. You've probably already noticed that the only way to bind values to variables in RQL is to use function arguments. We used to support a `let` statement but since this was ugly and hard to use we replaced it with `FUNCALL` (`do` in the driver API) which can be used to bind values to variables and to manage variable scopes.\r\n\r\nTo illustrate how this is useful, let's say you want to square a RQL value which requires making two references to the value. You can compute the value twice `(...some query...) * (...repeated...)` but this is wasteful and wouldn't even work if you had to rely on a non-deterministic term. Instead, we can compute the value once and bind it to a function argument by using `do`: `(...some query...).do(lambda x: x * x)`.\r\n\r\nA similar technique is used to pass RQL values to JavaScript terms. Indeed, without some way to pass values to your JavaScript snippets it wouldn't be a very useful feature. Any JavaScript term that evaluates to a JS function can be used anywhere a RQL `FUNC` term is expected, including in `FUNCALL`. Thus we could rewrite our squaring query as: `(...).do(r.js('(function(x) { return x * x; })'))`.\r\n\r\nLet me better illustrate this with a more realistic example. Let's say you want to find all users in your user table with Scottish sounding names (which we define as containing a 'Mc' or 'Mac' prefix). The obvious tool for the job, regular expressions (now we have two problems...), are not natively available in RQL. Fortunately  this functionality is available through the `JAVASCRIPT` term. Indeed, the whole point of providing the `r.js` function is to make such missing functionality available within your queries. To pass the name string to the JS term we have to define a JS function that accepts it as an argument. Since `filter` expects a function term anyway, we can simply pass the JS term directly to the `filter` in place of an ordinary RQL function:\r\n\r\n```python\r\nr.table('users').filter(r.js(\"\"\"(function(user) {\r\n    return user.last_name.match(/^((Mac)|(Mc))[A-Z]/)\r\n})\"\"\")\r\n```"
  , issueCommentId = 16141981
  }