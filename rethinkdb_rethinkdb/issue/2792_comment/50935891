IssueComment
  { issueCommentUpdatedAt = 2014 (-08) (-01) 21 : 17 : 45 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/50935891"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2792#issuecomment-50935891"
  , issueCommentCreatedAt = 2014 (-08) (-01) 21 : 17 : 45 UTC
  , issueCommentBody =
      "Both the queries `(...).update({\"a\": 2, \"b\": 1})` and `(...).update({\"a\": 2})` will be treated as functions from the old value of the row to the new value of the row. On the input `{\"id\": 123, \"a\": 1, \"b\": 1}`, they both produce the output `{\"id\": 123, \"a\": 2, \"b\": 1}`. So what do we do with this new row? We compare the new value of each field to the old value of each field, and issue vector clock updates for any fields that have changed. So only the `a` field gets a vector clock update, in both cases.\r\n\r\nHypothetically we could try to distinguished between \"untouched fields\" and \"fields that were overwritten with the same value\", but that seems like a massive pain in the ass to implement."
  , issueCommentId = 50935891
  }