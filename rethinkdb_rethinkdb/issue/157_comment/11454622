IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-17) 18 : 54 : 38 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11454622"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/157#issuecomment-11454622"
  , issueCommentCreatedAt = 2012 (-12) (-17) 18 : 54 : 38 UTC
  , issueCommentBody =
      "In a separate email I argued for the requiring an identity base is mostly redundant while additing significant additional complexity and confusion to the API (as we have seen several times now). Though Joe's proposed changes do eliminate the confusion of multiple base application, I still think we should be able to get away with no base option at all, elminating the remaining API complexity.\r\n\r\nWhile an optional argument might look acceptable in Python they are harder to implement and use in other languages while in all cases adding significant complexity to the API and documentation. In some cases optional arguments are unavoidable, but here I really think that the alternatives are actually better.\r\n\r\nConsider the common case where we are reducing a multi-value stream. Here an identity base is not necessary while any non-identity base can simply be applied to the final value of the reduction.\r\n\r\n```python\r\n# An identity base is pointless, hence the optionality of the base\r\n>>> r([1,2,3]).reduce(lambda a,b: a+b, base=0).run()\r\n6\r\n>>> r([1,2,3]).reduce(lambda a,b: a+b).run()\r\n6\r\n\r\n# Even with a non-identity base it's clear that the optional argument\r\n# is both less clean and intuitive than the alternative\r\n>>> r([1,2,3]).reduce(lambda a,b: a+b, base=1).run()\r\n7\r\n>>> (r([1,2,4]).reduce(lambda a,b: a+b)+1).run()\r\n7\r\n```\r\n\r\nThe story is almost identical for single element streams. Simply defining any reduction on a single element stream to be the value of that element effectively converts the situation to the multi-value case above:\r\n\r\n```python\r\n# An identity base is pointless even in the 1 element case\r\n>>> r([1]).reduce(lambda a,b: a+b, base=0).run()\r\n1\r\n>>> r([1]).reduce(lambda a,b: a+b).run()\r\n1\r\n\r\n# Even with a non-identity base the alternative is cleaner\r\n>>> r([1]).reduce(lambda a,b: a+b, base=1).run()\r\n2\r\n>>> (r([1]).reduce(lambda a,b: a+b)+1).run()\r\n2\r\n```\r\n\r\nZero element streams, of course, are a little more complicated. Here the base serves as a default value to provide when the stream contains no elements. However mathematically neat, requiring that the user provide a default value to simply hand back in an exeptional case seems a bit silly. Let's say that we define any reduction on a zero element stream to be `null` in these cases. We again have a few alternatives to the optional argument.\r\n\r\n```python\r\n>>> r([]).reduce(lambda a,b: a+b, base=0).run()\r\n0 \r\n# This isn't spectacular but works\r\n>>> r([]).do(lambda stream: r.branch(stream.length() == 0),\r\n...          0,\r\n...          stream.reduce(lambda a,b: a+b)).run()\r\n0\r\n\r\n# Similar idea but detects the null instead\r\n>>> r([]).reduce(lambda: a,b: a+b).do(lambda res: r.branch(res, res, 0)).run()\r\n0\r\n\r\n# We can generalize that approach with a default function\r\n>>> r([]).reduce(lambda: a,b: a+b).default(0).run()\r\n0\r\n\r\n# Or\r\n>>> r.default(r([]).reduce(lambda: a,b: a+b), 0).run()\r\n0\r\n\r\n# And of course the detection can be done in the client as well\r\n>>> res = r([]).reduce(lambda: a,b: a+b).run()\r\n>>> if res is None:\r\n...   res = 0\r\n```\r\n\r\nThese approaches are generally how developers have always handled the possible exceptional case. I don't see any reason in particular to special case `reduce`.\r\n\r\nLastly, I should address the case where the stream has no elements and we desire a non-zero base. Null checking and then applying the base would actually be kind of a hassle. Fortunately there is yet another alternative:\r\n\r\n```python\r\n# We can easily guarantee a non-zero element stream by adding in our base\r\n>>> r([]).union([1]).reduce(lambda a,b: a+b).run()\r\n1\r\n\r\n# append might be a little cleaner though I think might force conversion to an array\r\n>>> r([]).append(1).reduce(lambda a,b: a+b).run()\r\n1\r\n```\r\n\r\nThis last option is essentially equivalent to providing an optional base simply using the primitives we already have. Arguably less complex to use than the optional argument this feels like a win-win for us and our users. We can eliminate all the remaining API complexity and simplify the implementation to boot."
  , issueCommentId = 11454622
  }