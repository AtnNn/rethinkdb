IssueComment
  { issueCommentUpdatedAt = 2013 (-01) (-23) 20 : 46 : 27 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/12621347"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/221#issuecomment-12621347"
  , issueCommentCreatedAt = 2013 (-01) (-23) 20 : 46 : 27 UTC
  , issueCommentBody =
      "@thisandagain and @raynos I finally have a proposal I'd like to get your feedback on. I went ahead and implemented much of the new driver functionality while putting aside these interface questions. With much of the rest of the driver implemented I should be able to fairly easily prototype the different options.\r\n\r\nI've been trying to balance several goals in thinking about this. One, of course, is to follow existing conventions where possible and integrate as seamlessly into the host as we can, but we have also always tried to maintain some similarity between the drivers where possible.\r\n\r\nIn working on this I've also been struck by the need to consider how easy it is to use in a repl. While not important in production applications, many users first experiences and experimentation with the driver will likely be in a repl and I would like to make that experience as enjoyable and seamless as it is to use within a script. This is obviously harder to square with the asynchronous nature of JS and may force some details that may be hard to understand otherwise.\r\n\r\nThe following proposal is thus based on a preferences for the `function(err, result) {...` style of Node and the batched iterator from the python driver. A key contribution was made by @raynos in a separate message in which he suggested removing the extra step of getting a cursor from `run` and then asynchronously iterating over the cursor.\r\n\r\n```javascript\r\n// connect also returns the connection (ignored here) as\r\n// a convenience for repl users.\r\nr.connect({host:'localhost', port:28015}, function(err, conn) {\r\n   if(err) throw err;\r\n\r\n   // Within this callback all `run` invocations will be made against\r\n   // this connection. In other contexts, invoke `run` from the connection\r\n   // object itself to avoid ambiguity or invoke `with` on the connection\r\n   // to reenter a context in which this connection will be used by `query.run`\r\n   // To support repl usage, the last connection global will still be set and\r\n   // used outside of specific `with` contexts.\r\n   conn.run(query, function(err, result) {...});\r\n   conn.with(function() {\r\n      query.run(function(err, result) {...});\r\n   });\r\n   \r\n   // There is no cursor. `run` takes a callback the receives any\r\n   // error or any result. `run` itself returns nothing\r\n   r.table('tbl').get(0).run(function(err, result) {\r\n      if(err) throw err;\r\n      result['field'];\r\n      ...\r\n   });\r\n\r\n   // Stream results received a lazy batched iterator (just like\r\n   // Python driver) that supports the JS array iteration methods\r\n   r.table('tbl').run(function(err, tbl) {\r\n      if(err) throw err;\r\n\r\n      // `forEach`, map, reduce, etc. are implemented on the iterator\r\n      tbl.forEach(function(row) {\r\n          processRow(row);\r\n\r\n          // There is no `length` field (as on regular arrays) but\r\n          // a special method `more` (or pick a synonym) can be\r\n          // used to determine the end of the stream\r\n          if(!tbl.more())\r\n             finishedProcessingRows();\r\n      });\r\n   });\r\n\r\n   // Queries that return arrays support the same access pattern\r\n   r([1,2,3]).run(function(err, seq) {\r\n       // Though `seq` is an array not a lazy iterator it can be\r\n       // processed in the same way\r\n       seq.forEach(function(row) {\r\n          processRow(row);\r\n      });\r\n   });\r\n\r\n   // `map` and `filter` themselves return lazy iterators\r\n   var filtered = tbl.filter(function(row) { ... });\r\n   filtered.forEach(function(row) { ... });\r\n\r\n   // The old `collect` is still here if you'd prefer to wait for\r\n   // the whole sequence to be returned\r\n   tbl.collect(function(whole) {\r\n      // Whole is just an array and can be used in a for loop\r\n      // But how do we warn against using the lazy iterator\r\n      // in a standard for loop?\r\n      for(var i = 0; i < whole.length; i++) {\r\n         processRow(row[i]);\r\n      }\r\n   });\r\n\r\n   // The new Node streaming interface will also be supported so\r\n   // that RethinkDB result streams can be plugged directly into\r\n   // other Node libraries.\r\n   tbl.on('readable', function() {\r\n      var chunk = tbl.read(10);\r\n      if(chunk != null) {\r\n         for(var i = 0; i < chunk.length; i++) {\r\n            processRow(chunk[i]);\r\n         }\r\n      }\r\n   });\r\n\r\n   tbl.on('end', function() {\r\n      finishedProcessingRows();   \r\n   });\r\n});\r\n```\r\n\r\nWhile I think it is important to eventually include support for Node streams I don't think it will be the standard way that most users (especially beginners and browser users) will want to interact with query result streams. It also would appear to be the case that the new stream API isn't stable or even available in a current Node release. I'd rather develop a good and accessible custom API design than rely for now on an API that isn't quite ready yet. When Node streams are ready though, I do agree that we should support them."
  , issueCommentId = 12621347
  }