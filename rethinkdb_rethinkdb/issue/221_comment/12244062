IssueComment
  { issueCommentUpdatedAt = 2013 (-01) (-14) 22 : 40 : 47 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/12244062"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/221#issuecomment-12244062"
  , issueCommentCreatedAt = 2013 (-01) (-14) 22 : 40 : 47 UTC
  , issueCommentBody =
      "@Raynos The current cursor API works like a pull stream. The `next` method takes a callback to which it passes a single row. If the callback returns `true` it continues to iterate over the stream, requesting more data from the server as it goes.\r\n\r\nAs for prefix style, the RethinkDB team is actually very LISP friendly. The new [protobuf spec](https://github.com/rethinkdb/rethinkdb/wiki/protobuf_rfc_raw_spec) should look quite familiar to any LISP hackers. We'll support both styles so you can choose how you want to structure your query.\r\n\r\nI've actually read that fake operator overloading page before. It's a cute hack, but, as the author says, \"you probably shouldn't use it in production code\". "
  , issueCommentId = 12244062
  }