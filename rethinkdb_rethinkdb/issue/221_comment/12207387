IssueComment
  { issueCommentUpdatedAt = 2013 (-01) (-14) 05 : 39 : 36 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 479538
        , simpleUserLogin = N "Raynos"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/479538?v=3"
        , simpleUserUrl = "https://api.github.com/users/Raynos"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/12207387"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/221#issuecomment-12207387"
  , issueCommentCreatedAt = 2013 (-01) (-14) 05 : 39 : 36 UTC
  , issueCommentBody =
      "Massive :+1: on cursors and range queries being streams.\r\n\r\nAlso :+1: on being able to write to the database as a stream. In fact if you take inspiration from the [levelup][1] api you can't go wrong.\r\n\r\nA good API would be something like:\r\n\r\n - `rethink.connect()` returns a conn object. \r\n - a `conn` object can be called with `.use()` to return a new connection object using that database\r\n - Keep your `rethink.table(...).stuff()` query builder API.\r\n - a `conn` object has a `run` method which returns a cursor which is a streams2 stream. Any error in this query\r\n    would emit an `\"error\"` event.\r\n - a `conn` object has a `query` method which takes a callback of `(err, value)`. Internally it would use `run`,\r\n    create a cursor and grab the first value out of it.\r\n - a `conn` object has a `collect` sugar method which takes a callback of `(err, values)` and it uses `run` internally\r\n    and consumes the entire cursor stream into an array\r\n\r\nThe important thing of such an API is that leverage callbacks and streams whilst keeping your novel query builder API. It's also important to note that you have multiple methods that execute a query in different manners which gives users freedom to choose whichever one is most suitable for their application.\r\n\r\nA thorough code example would be:\r\n\r\n```js\r\nvar rethink = require(\"rethinkdb\")\r\nvar WriteStream = require(\"write-stream\")\r\n\r\nvar conn = rethink.connect({\r\n    host: \"localhost\"\r\n    , posrt: 28015\r\n}, function (err, conn) {\r\n    // optional callback. Called when connection open\r\n})\r\n\r\n// if you don't have a callback then `conn` will emit either \"open\" or \"error\"\r\n// at some point in the future\r\n\r\n// any operations done on `conn` before \"open\" are queued internally\r\n\r\nvar db = conn.use(\"heroes\")\r\nvar run = db.run\r\n\r\n// db.run(Query) returns a cursor represented as a stream \r\n// from (isaacs/readable-stream) / streams2 as those are pull streams which \r\n// is what you want for cursors\r\nvar stream = run(rethink.table(\"marvel\"))\r\n\r\n// either read from it\r\nvar chunk = stream.read()\r\nstream.on(\"readable\", function () {\r\n    var anotherChunk = stream.read()\r\n})\r\n\r\n// or pipe it\r\nstream.pipe(WriteStream(function write(chunk) {\r\n    // reading\r\n}, function end() {\r\n    // cursor is empty\r\n}));\r\n\r\n// of course the stream should still have all the rethink cursor methods.\r\n\r\n// cursor.next is confusing, instead just be a readable stream and comply to \r\n// back pressure from `.pipe()` i.e. writable stream applies back pressure\r\n// if it doesn't want to continue the iteration\r\n\r\nstream.pipe(WriteStream(function write(chunk) {\r\n    // process\r\n\r\n    // apply backpressure to stop iteration.\r\n    // emit \"drain\" in the future to continue\r\n    return false\r\n}))\r\n\r\n// cursor.collect is not necessary, users can use their prefered streaming\r\n// abstraction\r\n\r\nvar toArray = require(\"write-stream/array\")\r\n\r\nstream.pipe(toArray(function (results) {\r\n    // do stuff\r\n}))\r\n\r\nvar query = db.query\r\n\r\n// some queries only return either error or a single result. Those should be\r\n// callbacks. You should have a different primitive that's not run for that.\r\n\r\n// If it makes sense model these internally as a cursor/stream of one value\r\n// and just call the callback with either error or first value.\r\n\r\nquery(rethink.dbCreate(\"superheroes\"), function (err, result) {\r\n    // stuff\r\n})\r\n\r\nquery(rethink.dbDrop(\"superheroes\"), function (err, result) {\r\n    // stuff\r\n})\r\n\r\nvar marvel = rethink.table(\"marvel\")\r\n\r\nquery(marvel.insert({ ... }), function (err, result) {\r\n\r\n})\r\n\r\nquery(marvel.get(\"superman\"), function (err, doc) {\r\n\r\n})\r\n\r\n// between is a range query so it returns a stream\r\n\r\nvar stream = run(marvel.between(10, 20))\r\n\r\n// do stuff with stream\r\n\r\n// it may make sense to have `collect` buffer the entire stream result into \r\n// memory and return it as an array\r\n\r\nvar collect = db.collect\r\n\r\ncollect(marvel.between(10, 20), function (err, results) {\r\n\r\n})\r\n\r\n// let and letVar feel unnecessary, just use real javascript values\r\n\r\nvar ironman = rethink.table(\"marvel\").get(\"ironMan\")\r\n\r\nquery(ironman(\"name\"), function (err, result) {\r\n\r\n})\r\n\r\nvar ironman = rethink.table(\"marvel\").get(\"IronMan\")\r\nvar thor = rethink.table(\"marvel\").get(\"Thor\")\r\n\r\nvar greatest = rethink.branch(\r\n    ironman(\"manliness\").get(thor(\"manliness\"))\r\n    , ironman\r\n    , thor\r\n)\r\n\r\nquery(greatest, function (err, result) {\r\n\r\n})\r\n\r\n// A forEach abstraction can just be replaced with streams\r\n\r\nvar transform = require(\"transform-stream\")\r\n\r\nrun(rethink.table(\"marvel\")).\r\n    pipe(transform(function (hero, finish) {\r\n        var deleteVillian = rethink.\r\n            table(\"villians\").\r\n            get(hero(\"villianDefeated\")).\r\n            del()\r\n\r\n        query(deleteVillian, finish)\r\n    })).\r\n    pipe(toArray(function (results) {\r\n        /* ... */\r\n    }))\r\n\r\n// arrayToStream and streamToArray are really confusing. Is a sequence a node\r\n// stream?!\r\n```\r\n\r\nIt should be noted I know nothing about your db and merely redesigned your API to be more node idiomatic based on your api documentation. \r\n\r\n   [1]: https://github.com/rvagg/node-levelup"
  , issueCommentId = 12207387
  }