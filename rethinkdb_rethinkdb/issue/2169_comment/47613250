IssueComment
  { issueCommentUpdatedAt = 2014 (-07) (-01) 04 : 56 : 59 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47613250"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2169#issuecomment-47613250"
  , issueCommentCreatedAt = 2014 (-07) (-01) 03 : 25 : 06 UTC
  , issueCommentBody =
      "I get the impression that this issue is blocking people from using RethinkDB at scale, so it seems like it's worth doing soon. However, many of the low-level details of clustering will be changing. I propose that we begin by implementing a high-level API, which should be approximately equivalent to the current admin web UI or CLI. This will still require some changes as the clustering system evolves, but the changes will be relatively minor.\r\n\r\nJust to get the ball rolling, here's a preliminary API. This is only for manipulating the goals; I haven't included any facilities for checking on the cluster status.\r\n\r\n* `r.table(...).shards_set(number)`: Sets how many shards in the table. There is a corresponding `shards_get()`. There is also `shards_rebalance()`, which initiates a rebalance of the table while keeping the total number of shards the same. If we implement hash-sharding, `rebalance()` will be deprecated (we can make it a no-op that issues a warning).\r\n\r\n* `r.table(...).primary_goal_set(goal)`: Sets a table's primary. The `goal` can have several formats:\r\n    * The string `\"any\"`. This means that RethinkDB will select a machine. This is the default.\r\n    * A datacenter name. RethinkDB will select a machine from the given datacenter.\r\n    * A list of machine names, with as many entries as there are shards. RethinkDB will use the specific machines given for the specific shards.\r\n    For the first iteration, RethinkDB will select a machine when `primary_goal_set()` is called and then never change it. When we implement auto-failover, RethinkDB may select a new machine subject to the same constraints, or give an error if it was given a specific machine name.\r\n    \r\n    There is a corresponding `primary_goal_get()`, which returns a value in exactly the same format. We will need a separate API call to ask which machine was actually assigned, but that's not critical.\r\n    \r\n    If `shards_set()` is called when the primary goal is set to a list of specific machines, then it will either truncate machines from the end of the list or insert new machines chosen arbitrarily. We should think more about this behavior.\r\n\r\n* `r.table(...).secondaries_goal_set(goal)` and `r.table.secondaries_goal_get()`: These are like `r.table(...).primary_goal_set()` and `r.table.primary_goal_get()` except that the goal is a list. Each element of the list follows the same format as the goal in `r.table(...).primary_goal_set()`. The number of elements in the list determines the number of secondaries. For example, if I want two secondaries in the `us_east` datacenter, I could write `r.table(...).secondary_goal_set([\"us_east\", \"us_east\"])`. The order of the list is irrelevant.\r\n\r\n* We also need some way to set write acks. I suggest that we adopt @neumino's proposal for secondaries that are guaranteed to be up to date. (Edit: This is issue #2119. Thanks @neumino.) Then we could replace `r.table(...).secondary_goal_set()` with `r.table(...).secondary_uptodate_goal_set()` and `r.table(...).secondary_outdated_goal_set()`. (Obviously these names are bad, but you get the idea.)\r\n\r\n* `r.table(...).durability_set(durability)` and `r.table.durability_get()`, where `durability` is `\"soft\"` or `\"hard\"`.\r\n\r\n* If we call a `get()` for a value that is in a vector clock conflict, it should throw an exception. Calling `set()` on a value in conflict should resolve the conflict. In the long term, the semilattices will probably go away, and so we won't have any vector clock conflicts.\r\n\r\nThis API is more powerful (in some ways) than the current web UI and CLI, so it would require some changes to the format of the goals, and we would have to update the web UI and CLI so that they could view and edit the new format. However, I think that this is OK. Once we release an API for editing the goals, it will become much more difficult for us to change the format of goals, so we should invest the extra effort to get the format of the goals right when we release the API.\r\n"
  , issueCommentId = 47613250
  }