IssueComment
  { issueCommentUpdatedAt = 2013 (-06) (-13) 08 : 40 : 08 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/18518470"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/868#issuecomment-18518470"
  , issueCommentCreatedAt = 2013 (-05) (-27) 23 : 53 : 26 UTC
  , issueCommentBody =
      "Alright, here's the complete API as I understand it, with some notes.  (I removed `contains` because I think it should be done as part of #885.).  I also made one API change, from `index_of` to `indexes_of`, to address Sam's concern about being able to get the last index in a general way.  (I also think it's a generally more useful operator.)\r\n\r\n- [x] `prepend`, `append` (`append` is already implemented) (completed)\r\n- [x] `insert_at` -- `r([1,2,3]).insert_at(1, nil) => [1, nil, 2, 3]` (@jdoliner is working on this.)\r\n- [x] `splice_at` -- `r([1,2,3]).splice_at(1, [\"foo\", \"bar\"]) => [1, \"foo\", \"bar\", 2, 3]` (@jdoliner is working on this.)\r\n- [x] `delete_at` -- `r([1,2,3]).delete_at(1) => [1, 3]` or `r([1,2,3,4]).delete_at(1,2) => [1,4]` (@jdoliner is working on this.)\r\n- [x] `change_at` -- `r([1,2,3]).change_at(1, nil) => [1, nil, 3]` (@jdoliner is working on this.)\r\n\r\nAll of these should only operate on arrays.\r\n\r\n(@jdoliner is working on these, now in CR 600)\r\n- [x] `set_insert` -- `r.set_insert([1,2,3,3,4], 5) => [1,2,3,4,5])`\r\n- [x] `set_intersection` -- `r.set_intersection([1,2,3], [2,3,4]) => [2, 3]`\r\n- [x] `set_union` -- `r.set_union([1,2,3], [2,3,4]) => [1,2,3,4]`\r\n- [x] `set_difference` -- `r.set_difference([1,2,3,3,4,4], [1,3]) => [2,4]`\r\n\r\nAll of these should have the constraint that the resulting array is a set, meaning that no element appears more than once.  I don't think they need to preserve ordering.\r\n\r\n(@jdoliner is working on these 2, these were CR 609)\r\n- [x] `+` -- `r([1,2,3]) + r([4,5]) => [1, 2, 3, 4, 5]` (basically union with an ordering guarantee, I think people expect to be able to add arrays).\r\n- [x] `*` -- `r([1,2,3]) * 2 => [1, 2, 3, 1, 2, 3]` (@neumino thinks this is nice, I'm sold).\r\n\r\nBe careful of the error messages when doing these.\r\n\r\n- [x] `difference` -- `r([1,2,3]).difference([3,4]) => [1, 2]` (Ruby defines this and it's really handy) (@jdoliner is working on this. CR 612)\r\n- [x] `count` -- `r([1,2,3,1]).count(1) => 2` or `r([1,2,3,1]).count(lambda x: x % 2 == 1) => 3` (CR 569)\r\n- [x] `is_empty` -- `r([]).is_empty => true`\r\n- [x] `indexes_of` -- `r([1,2,3,2]).indexes_of(2) => [1, 3]` or `r([1,2,3]).indexes_of{|x| x.eq(2)} => [1]` (@atnnn is working on this)\r\n\r\nI think that these should be able to take any sequence as the first argument, since it can be implemented efficiently (and `count` already has those semantics).  To be consistent with other terms, this means that `difference` and `indexes_of` should return a stream if they're passed a stream.  `difference` should return a selection if it's passed a selection.\r\n\r\n"
  , issueCommentId = 18518470
  }