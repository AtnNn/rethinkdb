IssueComment
  { issueCommentUpdatedAt = 2013 (-05) (-24) 22 : 13 : 31 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 43867
        , simpleUserLogin = N "jdoliner"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/43867?v=3"
        , simpleUserUrl = "https://api.github.com/users/jdoliner"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/18432717"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/868#issuecomment-18432717"
  , issueCommentCreatedAt = 2013 (-05) (-24) 22 : 08 : 05 UTC
  , issueCommentBody =
      "Summary of proposal up to this point, I left out things that one person proposed and no one else responded to. If something you feel strongly about is missing speak up because I think barring further discussion this is what we're going to implement.\r\n* `prepend`.\r\n* `append` (rename `append` because it sucks).\r\n* `insert_at` -- `r([1,2,3]).insert_at(1, nil) => [1, nil, 2, 3]`\r\n* `splice_at` -- `r([1,2,3]).splice_at(1, [\"foo\", \"bar\"]) => [1, \"foo\", \"bar\", 2, 3]`\r\n* `delete_at` -- `r([1,2,3]).delete_at(1) => [1, 3]` or `r([1,2,3,4]).delete_at(1,2) => [1,4]`\r\n* `change_at` -- `r([1,2,3]).change_at(1, nil) => [1, nil, 3]`\r\n* `set_intersection` -- `r.set_intersection([1,2,3], [2,3,4]) => [2, 3]`\r\n* `set_union` -- `r.set_union([1,2,3], [2,3,4]) => [1,2,3,4]`\r\n* `set_difference` -- `r.set_difference([1,2,3,3,4,4], [1,3]) => [2,4]`\r\n* `contains` -- `r([1,2,3]).contains(1) => true`, `r([1,2,3]).contains(4) => false`, `r([1,2,3]).contains(1, 2) => true`, `r([1,2,3]).contains(1, 4) => false` (the current `contains` will become `has_fields`).\r\n* `+` -- `r([1,2,3]) + r([4,5]) => [1, 2, 3, 4, 5]` (basically union with an ordering guarantee, I think people expect to be able to add arrays).\r\n* `difference` -- `r([1,2,3]) - r([3,4]) => [1, 2]` (Ruby defines this and it's really handy).\r\n* `*` -- `r([1,2,3]) * 2 => [1, 2, 3, 1, 2, 3]` (@neumino thinks this is nice, I'm sold).\r\n* `index_of` -- `r([1,2,3]).index_of(2) => 1` (Has some open debates.)\r\n* `count` -- `r([1,2,3,1]).count(1) => 2` or `r([1,2,3,1]).count(lambda x: x % 2 == 1) => 3`\r\n\r\nEdit: updated prepend and append."
  , issueCommentId = 18432717
  }