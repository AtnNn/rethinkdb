IssueComment
  { issueCommentUpdatedAt = 2014 (-07) (-07) 19 : 46 : 23 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/48231117"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2663#issuecomment-48231117"
  , issueCommentCreatedAt = 2014 (-07) (-07) 19 : 46 : 23 UTC
  , issueCommentBody =
      "I think the overall API is good. Here are some comments about details:\r\n\r\n* We'll probably release the ReQL admin API before we implement a consensus algorithm. So we'll have to come up with a stop-gap solution for conflict resolution. I propose that reading a conflicted value gives an exception and writing a conflicted value resolves the conflict. The web UI can offer more detailed conflict-resolution tools.\r\n\r\n* I think that all of the writable aspects of the table should live in a single object called `r.table('foo').config()`. Something like this:\r\n    ```python\r\n# Get the current configuration\r\n> r.table('foo').config()\r\n{\r\n    \"shards\": [\r\n        {\"master\": \"machine1\", \"replicas\": [\"machine2\", \"machine3\"]},\r\n        {\"master\": \"machine2\", \"replicas\": [\"machine1\", \"machine3\"]}\r\n        ],\r\n    \"acks\": [\r\n        [[\"machine1\", \"machine2\", \"machine3\"], 1]\r\n        ],\r\n    \"durability\": {\r\n        \"machine1\": \"soft\",\r\n        \"machine2\": \"soft\",\r\n        \"machine3\": \"soft\"\r\n        }\r\n}\r\n# Require an ack from every machine instead of just one\r\n> r.table('foo').config().update({\r\n    \"acks\": [[[\"machine1\", \"machine2\", \"machine3\"], 3]]\r\n    })\r\n```\r\n\r\n* I propose that the high-level API consists of only a single call:\r\n    ```python\r\n# Most of these parameters are optional\r\n> r.table('foo').suggest_config(shards=2,\r\n                                master=\"us_east\",\r\n                                replicas={\"us_east\": 1, \"us_west\": 1},\r\n                                acks={\"us_east\": 1},\r\n                                durability=\"soft\")\r\n{\r\n    \"shards\": [\r\n        {\"master\": \"us_east_machine_1\", \"replicas\": [\"us_east_machine_2\", \"us_west_machine_1\"]},\r\n        {\"master\": \"us_east_machine_2\", \"replicas\": [\"us_east_machine_1\", \"us_west_machine_2\"]}\r\n        ],\r\n    \"acks\": [\r\n        [[\"us_east_machine_1\", \"us_east_machine_2\"], 1]\r\n        ],\r\n    \"durability\": {\r\n        \"us_east_machine_1\": \"soft\",\r\n        \"us_east_machine_2\": \"soft\",\r\n        \"us_west_machine_1\": \"soft\",\r\n        \"us_west_machine_2\": \"soft\",\r\n        }\r\n}\r\n```\r\n    `suggest_config()` has no side effects. If you want to apply the suggested configuration, call `r.table('foo').config().update(r.table('foo').suggest_config(...))`.\r\n\r\n* What if the tags in `replicas` overlap when calling `suggest_config()`? I can think of a behavior that seems reasonable, but I can't think of a simple way to explain it, which is a bad sign.\r\n\r\n* The low-level API should never touch tag names; for example, it should be an error to write `r.table('foo').config().update({\"acks\": [[\"us_east\", 3]]})`. The problem is that people might get confused and think that it is storing the tag name, when actually it is looking up the list of machines with that tag and storing the list. Instead, we should provide a function `r.machines_with_tag(tag)` and tell people to call this function and store the result.\r\n\r\n* We could collect all of the read-only attributes under `r.table('foo').status()`. Here's a first draft of the format:\r\n    ```python\r\n> r.table('foo').status()\r\n{\r\n    \"shards\": [\r\n        {\r\n            \"machine1\": {\"state\": \"ready\"},\r\n            \"machine2\": {\"state\": \"down\"},\r\n            \"machine3\": {\"state\": \"backfilling\", \"backfiller\": \"machine1\", \"progress\": 0.778},\r\n        },\r\n        {\r\n            \"machine1\": {\"state\": \"need_primary\"},\r\n            \"machine2\": {\"state\": \"down\"},\r\n            \"machine3\": {\"state\": \"need_primary\"},\r\n        }],\r\n    \"ok\": False,\r\n    \"issues\": [\r\n        {\r\n            \"type\": \"machine_down\",\r\n            \"machine\": \"machine2\",\r\n        }\r\n        ],\r\n    \"stats\": {\r\n        \"num_rows\": 199232,\r\n        \"write_qps\": 273,\r\n        \"read_qps\": 1634,\r\n        # lots more here\r\n        }\r\n}\r\n```\r\n    I'd like to allow something like `r.table('foo').status().changes()` as well, but stats change very frequently, and I don't want to push constant updates to stats. I'm not sure how to handle this. One option is to have a separate stats call that doesn't support `changes()`.\r\n\r\n* Any function that manipulates machines should have a `r.machine_` prefix. For example, `r.machine_get_tags()` and `r.machine_divest()`.\r\n\r\n* It would be nice to get rid of `set_*()` and `get_*()` methods completely. Could we change `r.machine_get_tags()` and `r.machine_set_tags()` to `r.machine_tags()` and `r.machine_tags().update()` or something?\r\n\r\n* Here's a proposal for tag management: The main way to set a machine's tags is to pass them on the command line when the machine starts up. Tags are not stored on disk. We can still provide a function to change a machine's tags at runtime, but we should warn the user that changes made this way will disappear when the machine is restarted.\r\n\r\n* Maybe we should have a `machine_status()` function. It would return if the machine is up or not, issues, and stats. Since we might have hundreds of thousands of tables at some point, and since we already have an interface for getting table state, it probably shouldn't return any per-table information.\r\n\r\n* We should consider making a \"machine\" type to organize the tags, `divest()`, status, etc. However, this might be overkill.\r\n\r\n* Are there any issues, status, stats, etc. that aren't per-table or per-machine? If so, we need an additional interface.\r\n\r\n* I agree with @neumino that `divest` is a confusing term. Maybe we could rename it to `machine_vacate()`? `machine_remove_responsibilities()`? `machine_remove_tables()`?\r\n\r\n* I think it's fine if the web UI only allows a limited set of configuration commands, but I think it should display whatever the configuration is, even if it's a configuration that can only be created through the ReQL API and not through the web UI. @coffeemug, is that what you meant?\r\n\r\n* We should use the terms \"master\", \"primary\", \"replica\", and \"secondary\" consistently. In particular:\r\n    * We should pick exactly one term for the master/primary and exactly one term for replicas/secondaries, and ban any alternatives.\r\n    * If we pick \"replica\", we should decide whether or not it includes the master/primary and be clear about that. It would be nice if we could find an unambiguous term. Maybe \"mirror\"?\r\n    * We should use exactly the same terminology in the web UI and the ReQL API.\r\n\r\n* @neumino: If a machine that is mentioned in any table's configuration is inaccessible, then that should produce a \"dead machine\" issue. The only way to get an \"unsatisfiable goals\" error is when calling a function from the high-level API. For example, if I call `r.table('foo').suggest_config(shards=1000000)` it will raise an exception saying \"it's impossible to have 1000000 shards because you only have 4 machines in your cluster\". So \"unsatisfiable goals\" never appears as an issue, only as an exception. Does this answer your objection to \"unsatisfiable goals\"?\r\n\r\n"
  , issueCommentId = 48231117
  }