IssueComment
  { issueCommentUpdatedAt = 2014 (-07) (-09) 03 : 04 : 27 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/48424974"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2663#issuecomment-48424974"
  , issueCommentCreatedAt = 2014 (-07) (-09) 03 : 04 : 27 UTC
  , issueCommentBody =
      "Ok, getting to the meat of the thing.\r\n\r\n__Configuration documents__\r\n\r\nI agree that there should be a document a user can read (and possibly write to) that describes the clustering configuration of the table. However, I disagree that the way to get it should be `r.table('foo').config()`. I think we should add a system database with a set of system tables that contain this information (e.g. `r.db('system').table('clustering')`) where the `id` of each entry is the table name. I know this is controversial, so let's ignore that for now and pretend you do it by `r.system('clustering')`. But in case you're wondering, here is why I think this should have a `db` interface:\r\n\r\n- Pretty much every other SQL and NoSQL db in the world does it this way. It's familiar.\r\n- Existing and new GUI (and may-be curses) tools that let users browse tables will automagically allow them to also browse clustering and other system documents.\r\n- I can do sophisticated cross-table queries. For example, let's say I want to find every table that a given machine is responsible for. I can plausibly do it via `r.db('system').table('clustering').some_query_goes_here`, and this will only improve as ReQL improves. I can join things. I can do all sorts of cool stuff.\r\n- If we add a RESTful API to read documents via HTTP, it will work on system tables out of the box (which is really important for monitoring tools that already understand HTTP and JSON). \r\n\r\nSo assuming we do that:\r\n\r\n```py\r\n> r.db('system').table('clustering').run() # or r.system('clustering').run() if you prefer\r\n[{\r\n\"id\": [\"db_name\", \"table_name_1\"], # or \"db_name.table_name_1\"\r\n\"shards\": [\r\n    {\"master\": \"machine1\", \"replicas\": [\"machine2\", \"machine3\"]},\r\n    {\"master\": \"machine2\", \"replicas\": [\"machine1\", \"machine3\"]}\r\n    ],\r\n\"acks\": [\r\n    [[\"machine1\", \"machine2\", \"machine3\"], 1]]\r\n},\r\n{\r\n\"id\": [\"db_name\", \"table_name_2\"], # or \"db_name.table_name_2\"\r\n\"shards\": [\r\n    {\"master\": \"machine1\", \"replicas\": [\"machine2\", \"machine3\"]},\r\n    {\"master\": \"machine2\", \"replicas\": [\"machine1\", \"machine3\"]}\r\n    ],\r\n\"acks\": [\r\n    [[\"machine1\", \"machine2\", \"machine3\"], 1]]\r\n}]\r\n```\r\n\r\n__High level API__\r\n\r\nHaving to type `r.table('foo').config().update(r.table('foo').suggest_config(...))` or `r.db('system').table('clustering').get([\"db_name\", \"table_name\"]).update(r.table('foo').suggest_config(...))` is poor user experience for two reasons. As a user I think:\r\n\r\n- Why can't I type `r.table('foo').configure(...)` damn it?!!\r\n- What the heck do all these optional arguments do damn it?!! What if I mix them incorrectly? *How* do I mix them to do what I want?\r\n\r\nSo I think we should answer these questions by:\r\n\r\n- Making the function a verb that actually does stuff\r\n- Having a few small functions instead of one big one\r\n\r\nThe cost of doing that is that people might think they're storing configuration that includes tags, but I think that's minor compared to the cost of annoyance of having to call `update`. Also, once users learn how the functions work once, they'll understand them forever (and we can make sure things aren't ambiguous by writing good docs).\r\n\r\nSo:\r\n\r\n```py\r\n> r.table('foo').shard(5, dry_run=true).run()\r\n# returns new configuration document and does nothing\r\n\r\n> r.table('foo').shard(5).run()\r\n# returns new configuration document and shards the table\r\n\r\n> r.table('foo').shard(5, placement=\"us_east\").run()\r\n# returns new configuration document, shards the table, and picks masters from \"us_east\"\r\n```\r\n\r\nWe can trivially break up `suggest_shards` into multiple functions (where each optarg is essentially its own function). I can write down the detailed API if we agree on the overall premise.\r\n\r\nThere is an additional question -- what if I want to shard *and* replicate? Issuing two calls in a row isn't the same operationally as issuing one big call, so I think we should support that:\r\n\r\n```py\r\nr.table('foo').shard(...).replicate(...).run()\r\n```\r\n\r\nI propose we support that by having each relevant function (`shard`/`replicate`/etc.) return a single-row selection that the next function operates on. Essentially, `r.table('foo').shard(...)` is equivalent to `r.db('system').table('clustering').get('foo').shard(...)`. Also, if one of the commands has `dry_run` set to true and others don't, we throw an error and tell them to set `dry_run` to true everywhere or nowhere.\r\n\r\nThis proposal is:\r\n\r\n- Somewhat less elegant than the whole update/suggest thing (but tolerably so)\r\n- 100x more user-friendly\r\n\r\n__Low level API__\r\n\r\nI think we should support low level functions in exactly the same way as high level functions above that give users a nice interface to the document. But I'm not going to specify those until we agree on the overall premise above (specifying these will be easier after that).\r\n"
  , issueCommentId = 48424974
  }