Issue
  { issueClosedAt = Nothing
  , issueUpdatedAt = 2016 (-08) (-05) 20 : 48 : 31 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/3471/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/3471"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "007575"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:API_settled"
          , labelName = "tp:API_settled"
          }
      ]
  , issueNumber = 3471
  , issueAssignee =
      Just
        SimpleUser
          { simpleUserId = Id 1777134
          , simpleUserLogin = N "mlucy"
          , simpleUserAvatarUrl =
              "https://avatars.githubusercontent.com/u/1777134?v=3"
          , simpleUserUrl = "https://api.github.com/users/mlucy"
          , simpleUserType = OwnerUser
          }
  , issueUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "ReQL proposal: restarting feeds"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/3471"
  , issueCreatedAt = 2014 (-12) (-23) 20 : 02 : 12 UTC
  , issueBody =
      Just
        "The question of restarting feeds came up in #2953, #1118, and #2613. Since we've learned a lot since these issues were opened, I decided to start with a clean slate and a specific proposal.\r\n\r\nWhen the user calls `changes()` on a stream, the feed protocol would inject an opaque timestamp into results as follows:\r\n\r\n```py\r\n# Returns a feed along with an opaque timestamp\r\n> r.table('foo').changes()\r\n[{ 'old_val': ..., 'new_val': ..., 'timestamp': OPAQUE}]\r\n```\r\n\r\nThe user could then pass the opaque timestamp back to `changes()` via the `return_initial` optarg to get all the changes since the timestamp. We'd be piggy-backing off existing replication logic, so we'd have to tell the user the range of \"obsolete\" keys they should delete, and then fill them in on the new values in that range:\r\n\r\n```py\r\n> r.table('foo').changes(return_initial=OPAQUE)\r\n[\r\n  # Obsolete range of keys to delete\r\n  { 'obsolete_range': [LEFT_KEY1, RIGHT_KEY1] },\r\n  # Backfill the user on values they missed in the range\r\n  { 'new_val': ..., 'timestamp': OPAQUE}, { 'new_val': ..., 'timestamp': OPAQUE},\r\n\r\n  # Another obsolete range\r\n  { 'obsolete_range': [LEFT_KEY2, RIGHT_KEY2] },\r\n  # Values to backfill in the range\r\n  { 'new_val': ..., 'timestamp': OPAQUE}, { 'new_val': ..., 'timestamp': OPAQUE},\r\n\r\n  # Now we can start the feed\r\n  { 'old_val': ..., 'new_val': ..., 'timestamp': OPAQUE},\r\n  ...\r\n]\r\n```\r\n\r\nA special value for `return_initial` is `True`, which backfills the user from scratch:\r\n\r\n```py\r\n> r.table('foo').changes(return_initial=True)\r\n[\r\n  # Backfill the user on all the values\r\n  { 'new_val': ..., 'timestamp': OPAQUE}, { 'new_val': ..., 'timestamp': OPAQUE},\r\n\r\n  # Now we can start the feed\r\n  { 'old_val': ..., 'new_val': ..., 'timestamp': OPAQUE},\r\n  ...\r\n]\r\n```\r\n\r\nThis would work on streams in general, like `t.map().changes()` and `t.filter().changes()`.\r\n\r\nNote, if the changefeed is set up on a datum (e.g. a single document), the only legal values for `return_initial` are `True` or `False`. \r\n\r\nThere is a question of what the default for `return_initial` should be. I can see a couple of options:\r\n\r\n- Set it to `False`. This is annoying for datum feeds (e.g. a feed on a document).\r\n- Set it to `True`. This may be annoying for stream feeds (e.g. a feed on a table).\r\n- Set it to `False` on streams, and to `True` on datums. This might be confusing to users.\r\n\r\nAlso note, under this proposal the `squash` optarg would continue operating as it does now, but would have no effect on the initial values.\r\n\r\n/cc @danielmewes @timmaxw @mlucy. How hard would this be to implement on top of the current replication logic? Are there flaws in the API? Would it work on more general streams (like `t.filter().changes()`)?"
  , issueState = "open"
  , issueId = Id 52770469
  , issueComments = 165
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 48436
                , simpleUserLogin = N "coffeemug"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/48436?v=3"
                , simpleUserUrl = "https://api.github.com/users/coffeemug"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 268
          , milestoneNumber = 41
          , milestoneClosedIssues = 0
          , milestoneDescription =
              Just
                "Issues in this milestone will be revisited after each major release during the planning stage for the major release after it. They will be moved to a specific release milestone if chosen for that release."
          , milestoneTitle = "subsequent"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/41"
          , milestoneCreatedAt = 2013 (-06) (-30) 07 : 32 : 52 UTC
          , milestoneState = "open"
          }
  }