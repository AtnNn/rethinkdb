IssueComment
  { issueCommentUpdatedAt = 2015 (-04) (-29) 21 : 17 : 06 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/97587822"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3471#issuecomment-97587822"
  , issueCommentCreatedAt = 2015 (-04) (-29) 21 : 17 : 06 UTC
  , issueCommentBody =
      "@deontologician -- this is an order of magnitude easier for us to implement if we can have the requirement that they need to reconnect to the same server they originally started the changefeed on.  We decided that having named changefeeds that couldn't be accessed from anywhere in the cluster violated our clustering model too egregiously; that was the original motivation for putting these functions on the cursor.  `Cursor::serialize` will basically produce an opaque token from their perspective, except that it feels more like they're migrating a cursor rather than being given a token that's only valid on one server.  (We'll presumably include server/port information in the serialized version so that `r.resume_cursor` can connect to the right server automatically for them.)\r\n\r\nIt's also something we can tack onto the `resumable` proposal; we can do that one, and if people want more we can add `Cursor::serialize` pretty trivially.  Whereas if we wanted to do named changefeeds we'd probably have to decide that before releasing the `resumable` proposal."
  , issueCommentId = 97587822
  }