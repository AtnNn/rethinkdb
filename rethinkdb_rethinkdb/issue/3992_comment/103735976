IssueComment
  { issueCommentUpdatedAt = 2015 (-05) (-20) 02 : 58 : 36 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/103735976"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3992#issuecomment-103735976"
  , issueCommentCreatedAt = 2015 (-05) (-20) 02 : 58 : 36 UTC
  , issueCommentBody =
      "> One disadvantage of this proposal is that it's less obvious which operations are atomic.\r\n\r\nI think the opposite is true. If I run `r.table('foo').filter({x: 1}).update({x: r.row('x').add(1)})`, RethinkDB doesn't give me an error. So according to our rule, I assume the query is executed atomically (which it isn't!) So we should either error and force the user to decide if they want to pass `non_atomic=True`, or change the implementation to actually operate atomically.\r\n\r\nI think the latter option (changing the implementation in these cases) is much better, because if we error there will be a *huge* class of queries that will break (and passing `non_atomic` everywhere or rewriting them will be very annoying for users)."
  , issueCommentId = 103735976
  }