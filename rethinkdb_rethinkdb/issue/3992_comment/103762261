IssueComment
  { issueCommentUpdatedAt = 2015 (-05) (-20) 05 : 16 : 17 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/103762261"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3992#issuecomment-103762261"
  , issueCommentCreatedAt = 2015 (-05) (-20) 05 : 16 : 17 UTC
  , issueCommentBody =
      "I would rather we do this in 2.1 if we could.  I think the current behavior is both bad and unintuitive.\r\n\r\nIMO we should make it so every term that can easily be made atomic is.  Even if we leave the docs the way they are so that the official position is that `.filter.update` isn't guaranteed to be atomic, it will still eliminate 99% of cases where people don't realize something's non-atomic and screw themselves as a result.  This is doubly true because writing `.filter.update` doesn't produce an error; it's just silently non-atomic and then your app breaks in production.\r\n\r\nI think it's OK to officially not guarantee something, but to make the database as safe as possible by default for people who don't think to read the official guarantees.  (Think e.g. how GCC turns off strict aliasing by default.)\r\n\r\nI'd be happy to put off arguing about whether or not to guarantee certain things are atomic, and whether or not to introduce an atomic selection type, until 2.2, but I really don't see a reason not to make the default behavior safe for all selections where it's easy."
  , issueCommentId = 103762261
  }