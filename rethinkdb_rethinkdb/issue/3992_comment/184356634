IssueComment
  { issueCommentUpdatedAt = 2016 (-02) (-15) 19 : 35 : 09 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/184356634"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3992#issuecomment-184356634"
  , issueCommentCreatedAt = 2016 (-02) (-15) 19 : 35 : 09 UTC
  , issueCommentBody =
      "@AtnNn I like that proposal.\r\nWe do need to figure out what `document_query` means exactly though (does it only work for `filter`, or also for predicates such as `between`, `getAll` or `getIntersecting`?).\r\n\r\nWe also need to be somewhat careful in how we name and describe this, since a `document_query` query isn't actually atomic at all.\r\nIf RethinkDB crashes in the middle of a multi-document update for example, it will have updated some documents but not others.\r\nIf you compare the set of documents that are updated by such a query and the set of documents in the table that fulfil the filter predicate at any given time, it's also possible that the updated set is not equal to any of the matching sets that existed in the table during the query execution (it will usually be a subset of some matching set, but not always I think).\r\n\r\nWe need to make it clear that there's still not going to be any atomicity across documents, and that the only thing it does is that it turns the filter predicate into a CAS update."
  , issueCommentId = 184356634
  }