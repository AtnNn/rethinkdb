IssueComment
  { issueCommentUpdatedAt = 2015 (-05) (-20) 03 : 48 : 10 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/103745605"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3992#issuecomment-103745605"
  , issueCommentCreatedAt = 2015 (-05) (-20) 03 : 48 : 10 UTC
  , issueCommentBody =
      ">  If I run r.table('foo').filter({x: 1}).update({x: r.row('x').add(1)}), RethinkDB doesn't give me an error. So according to our rule, I assume the query is executed atomically (which it isn't!)\r\n\r\nThe *query* isn't executed atomically, the *update* is executed atomically. The conjunction of the update and filter is not executed atomically. I think that if we find the right way to phrase this, we could make it super simple for users to understand. Maybe we could say \"the only thing that's executed atomically is the function you pass to a `.update()` call\", or something.\r\n\r\nThe problem with the alternative is that there isn't a clear rule. Suppose we make `.filter().update()`, `.getAll().update()`, and `.getIntersecting().update()` atomic. So what about `.orderBy().limit().update()` or `.nth().update()`? Or `.filter(r.row('x').eq(subquery)).update()`? It feels like if we add special support to make `.filter().update()` and similar queries atomic, we're just putting off the problem."
  , issueCommentId = 103745605
  }