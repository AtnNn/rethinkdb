IssueComment
  { issueCommentUpdatedAt = 2014 (-07) (-16) 20 : 37 : 11 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1461947
        , simpleUserLogin = N "neumino"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1461947?v=3"
        , simpleUserUrl = "https://api.github.com/users/neumino"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/49223188"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/281#issuecomment-49223188"
  , issueCommentCreatedAt = 2014 (-07) (-16) 20 : 37 : 11 UTC
  , issueCommentBody =
      "I can think of three reasons why we would like to provide a connection pool\r\n- Less code to write -- meaning shorter, more relevant examples\r\n- Better integration with Node/Flask/Sinatra -- users expect to share resources between requests (not like PHP users)\r\n- Better error handling -- if you want to share connections for multiple requests, it's currently hard/impossible to properly do it.\r\n- Connect to multiple nodes\r\n\r\n\r\n# Proposal\r\n\r\n## Create a pool\r\n```\r\nr.createPool(options) -> pool\r\n``` \r\nWhere options are:\r\n- `host`, `port`, `authKey`, `db`, options for `r.connect`\r\n- `min`: `<number>`, minimum number of available connections in the pool\r\n- `max`: `<number>`, maximum number of connections in the pool (regardless of their state)\r\n- `timeout`: `<number>`, how long a pool has to provide a connection before sending an error \r\n- `waitRetry`: `<number>`, time to wait in case before calling `r.connect` again when it first failed (`min(2^failed_attempts*timeoutError, maxWaitRetry)`.\r\n- `maxWaitRetry`: `<number>` see `waitRetry`\r\n- `timeGarbage`: `<number>`, how long the pool should keep an idle connection before removing it.\r\n\r\n\r\nI am not sure whether we need this or not:\r\n- `name`: `<string>` Is that useful? You could specify a pool with its name instead of its reference.\r\n\r\n\r\n## Execute a query\r\n\r\n```\r\nquery.run(connection) // currently what we have\r\nquery.run(pool) // get a connection from the pool and run a query\r\nquery.run() // use any of the pool created\r\n```\r\n\r\nIf people want to connect to multiple nodes, they can call `createPool` multiple times, and then call `run` without argument (we can pick a pool in a round robin fashion - and skip pools without an available connection).\r\n\r\nI tend to think that it's simpler to have one pool connect to only one node (and not multiple ones) because it will make error handling easier.\r\n\r\n_Note_: We could deprecate `repl` too.\r\n\r\n\r\n## Under the hood\r\n\r\n### Internal methods\r\n- `createConnection`: Call `r.connect` and in case of success call `putConnection`\r\n- `putConnection`: Put a connection in the pool\r\n- `getConnection`: Get a connection from the pool\r\n\r\nThese methods should be private because users could easily put back a connection that is not available (there could be a feed/cursor using it).\r\nWe can have an optimal behavior by looking at the response's type the driver retrieve (it should release the connection for every response as long as it is not a cursor or a feed).\r\n\r\nThat way, by putting a lock on the pool, we should be able to provide a thread safe pool for Ruby and Python (two threads will never have access to the same connection).\r\n\r\n\r\n### Data structure\r\n\r\nThe pool should use something like a double queue.\r\n\r\nPutting a connection in the pool should append at the end of the double queue. Getting a connection in the pool should pop the last element. That should allow the driver to release some connections if they are not used.\r\n\r\n### Things to keep in mind\r\n\r\nA TCP connection can be closed (by the host, by the other side), can timeout etc. We should catch all these events and make sure to immediately remove the connection from the pool if it happens.\r\n\r\nThe JavaScript driver currently has a few flaws that I'll fix in the next few days.\r\n\r\n\r\n### Error handling\r\n\r\nThe driver should try to keep `min` connections available in the pool. Meaning that it can aggressively create connections.\r\nFor example in this snippet:\r\n```\r\nfor(var i=0; i<1000; i++) {\r\n   r.table(\"foo\").get(1).run()\r\n}\r\n```\r\nThe driver will create 1000 connections at the same time (if `max > 1000`).\r\n\r\nIn case `createConnection` fails, the pool should enter a `slow` mode and try re-creating a connection with a timeout `min(2^failed_attempts*timeoutError, maxWaitRetry)` (and no more than one connection at a time)\r\nAs soon as `createConnection` succeed, it gets back in `normal` mode, and can try to create as many connections as possible to maintain `min` connections available.\r\n\r\nThis should solve two use cases:\r\n- The user tries to create too many connections (and hit a `max open files` error). In this case the pool will maintain the maximum number of connections possible while not trying too hard to open a new connection.\r\n- The server is down, and all the connections are removed from the pool. As soon `createConnection` succeed again, the pool will be populated with `min` connections.\r\n\r\n## More methods\r\n\r\n- `getLength` returns the number of connections in the pool\r\n- `getAvailableLength` returns the number of available connections in the pool\r\n- `getWaitingQueries` returns the number of queries waiting for a connection\r\n- `drain`: Close all the connections in the pool and deactivate it (no more connection can be created) -- Should we wait for the outstanding queries to return first? Should add an option for that?\r\n\r\n\r\n\r\n## Miscellaneous\r\nOne more thing. I would like to make the JavaScript driver callable. So you would import the driver this way:\r\n\r\n```\r\nvar r = require('rethinkdb')(); // create a pool with the default values\r\nvar r = require('rethinkdb')({pool: false}); // does not create a pool\r\nvar r = require('rethinkdb')({host: \"newton\", port: 44203}) // create a pool of connections to newton\r\n```\r\n\r\nThat would prevent an extra line `r.createPool()`, and prevent errors in case you create the pool too late. This is what express is doing (probably because they consider that you are supposed to create only one http server most of the time).\r\n"
  , issueCommentId = 49223188
  }