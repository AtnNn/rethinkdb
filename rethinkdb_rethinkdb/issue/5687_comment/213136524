IssueComment
  { issueCommentUpdatedAt = 2016 (-04) (-21) 22 : 16 : 58 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 159819
        , simpleUserLogin = N "cefn"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/159819?v=3"
        , simpleUserUrl = "https://api.github.com/users/cefn"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/213136524"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5687#issuecomment-213136524"
  , issueCommentCreatedAt = 2016 (-04) (-21) 22 : 16 : 58 UTC
  , issueCommentBody =
      "I'm not sure I follow, since it strikes me that any case of filter(true) and filter(false) even where some complex conditional is being assessed, could be entirely substituted by an if clause and an assignment. \r\n\r\nIf true, the query specification is the complex clause, if false, the query specification is the empty sequence.\r\n\r\nThere are in-principle edge cases where javascript dynamic typing might return either true or an Object, (hence implicitly using the different forms of overloading offered by filter), but these should probably not be encouraged by the API from a code-style point of view.\r\n\r\nIf you feel that query filtering really should be able to handle the boolean case, you could introduce a threatening looking error message to filter with a get-out, like asking authors to...\r\n* wrap the boolean value in r.literal()\r\n* force filter 'conditions' to return the explicit values r.true(), r.false() or r.boolean(condition)\r\n* introduce a boolean-specific filter operation like allOrNone()"
  , issueCommentId = 213136524
  }