IssueComment
  { issueCommentUpdatedAt = 2013 (-05) (-15) 23 : 31 : 03 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 552910
        , simpleUserLogin = N "Tryneus"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/552910?v=3"
        , simpleUserUrl = "https://api.github.com/users/Tryneus"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/17972715"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/739#issuecomment-17972715"
  , issueCommentCreatedAt = 2013 (-05) (-15) 23 : 31 : 03 UTC
  , issueCommentBody =
      "So, just tried this on next, and this actually causes a crash when the web ui connects:\r\n\r\n```c\r\nVersion: rethinkdb 1.4.5-1490-g9358e8 (debug) (GCC 4.6.1)\r\nerror: Error in ../src/stl_utils.tcc at line 72:\r\nerror: Assertion failed: [inserted] The map that was given is not a bijection and can't be inverted\r\nerror: Backtrace:\r\nerror: Wed May 15 16:28:25 2013\r\n       \r\n       1: rethinkdb_backtrace(void**, int) at thread_stack_pcs.cc:151\r\n       2: lazy_backtrace_t::lazy_backtrace_t() at backtrace.cc:250\r\n       3: format_backtrace(bool) at backtrace.cc:197\r\n       4: report_fatal_error(char const*, int, char const*, ...) at errors.cc:67\r\n       5: std::map<uuid_u, peer_id_t, std::less<uuid_u>, std::allocator<std::pair<uuid_u const, peer_id_t> > > invert_bijection_map<peer_id_t, uuid_u>(std::map<peer_id_t, uuid_u, std::less<peer_id_t>, std::allocator<std::pair<peer_id_t const, uuid_u> > > const&) at stl_utils.tcc:72\r\n       6: stat_http_app_t::prepare_machine_info(std::vector<uuid_u, std::allocator<uuid_u> > const&) at stat_app.cc:68\r\n       7: stat_http_app_t::handle(http_req_t const&) at stat_app.cc:198\r\n       8: routing_http_app_t::handle(http_req_t const&) at routing_app.cc:29\r\n       9: routing_http_app_t::handle(http_req_t const&) at routing_app.cc:29\r\n       10: http_server_t::handle_conn(scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t) at http.cc:308\r\n       11: boost::_mfi::mf2<void, http_server_t, scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t>::operator()(http_server_t*, scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t) const at mem_fn_template.hpp:280\r\n       12: void boost::_bi::list3<boost::_bi::value<http_server_t*>, boost::arg<1>, boost::_bi::value<auto_drainer_t::lock_t> >::operator()<boost::_mfi::mf2<void, http_server_t, scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t>, boost::_bi::list1<scoped_ptr_t<linux_tcp_conn_descriptor_t>&> >(boost::_bi::type<void>, boost::_mfi::mf2<void, http_server_t, scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t>&, boost::_bi::list1<scoped_ptr_t<linux_tcp_conn_descriptor_t>&>&, int) at bind.hpp:392\r\n       13: void boost::_bi::bind_t<void, boost::_mfi::mf2<void, http_server_t, scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t>, boost::_bi::list3<boost::_bi::value<http_server_t*>, boost::arg<1>, boost::_bi::value<auto_drainer_t::lock_t> > >::operator()<scoped_ptr_t<linux_tcp_conn_descriptor_t> >(scoped_ptr_t<linux_tcp_conn_descriptor_t>&) at bind_template.hpp:33\r\n       14: boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf2<void, http_server_t, scoped_ptr_t<linux_tcp_conn_descriptor_t> const&, auto_drainer_t::lock_t>, boost::_bi::list3<boost::_bi::value<http_server_t*>, boost::arg<1>, boost::_bi::value<auto_drainer_t::lock_t> > >, void, scoped_ptr_t<linux_tcp_conn_descriptor_t>&>::invoke(boost::detail::function::function_buffer&, scoped_ptr_t<linux_tcp_conn_descriptor_t>&) at function_template.hpp:154\r\n       15: boost::function1<void, scoped_ptr_t<linux_tcp_conn_descriptor_t>&>::operator()(scoped_ptr_t<linux_tcp_conn_descriptor_t>&) const at function_template.hpp:761\r\n       16: linux_nonthrowing_tcp_listener_t::handle(int) at network.cc:800\r\n       17: boost::_mfi::mf1<void, linux_nonthrowing_tcp_listener_t, int>::operator()(linux_nonthrowing_tcp_listener_t*, int) const at mem_fn_template.hpp:166\r\n       18: void boost::_bi::list2<boost::_bi::value<linux_nonthrowing_tcp_listener_t*>, boost::_bi::value<int> >::operator()<boost::_mfi::mf1<void, linux_nonthrowing_tcp_listener_t, int>, boost::_bi::list0>(boost::_bi::type<void>, boost::_mfi::mf1<void, linux_nonthrowing_tcp_listener_t, int>&, boost::_bi::list0&, int) at bind.hpp:314\r\n       19: boost::_bi::bind_t<void, boost::_mfi::mf1<void, linux_nonthrowing_tcp_listener_t, int>, boost::_bi::list2<boost::_bi::value<linux_nonthrowing_tcp_listener_t*>, boost::_bi::value<int> > >::operator()() at bind_template.hpp:21\r\n       20: callable_action_instance_t<boost::_bi::bind_t<void, boost::_mfi::mf1<void, linux_nonthrowing_tcp_listener_t, int>, boost::_bi::list2<boost::_bi::value<linux_nonthrowing_tcp_listener_t*>, boost::_bi::value<int> > > >::run_action() at runtime_utils.hpp:58\r\n       21: callable_action_wrapper_t::run() at runtime_utils.cc:67\r\n       22: coro_t::run() at coroutines.cc:178\r\n```\r\n\r\nSeems like it should be a simple enough fix to check the remote metadata when connecting to make sure your id is not already there.  If it is, I think it should exit at that point.  Maybe it should just log something and complain, not sure."
  , issueCommentId = 17972715
  }