IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-16) 07 : 25 : 22 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 43867
        , simpleUserLogin = N "jdoliner"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/43867?v=3"
        , simpleUserUrl = "https://api.github.com/users/jdoliner"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11415147"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/159#issuecomment-11415147"
  , issueCommentCreatedAt = 2012 (-12) (-16) 07 : 25 : 22 UTC
  , issueCommentBody =
      "I think basically the best we can do here is to say that sorting on an arbitrary value requires that each shard be able to fit its data set in memory. We could make that better but as @coffeemug points out that's sort of a problem unto itself. \r\n\r\nI'd say there are 2 parts to this project, and there were very specific reasons that we didn't do either for the first release.\r\n\r\nDistributing sort. Right now shards just return unsorted data and it's all sorted on the parser node. The reason is because this requires keeping state on the shards which is something that nothing else does. I think in order to do this we're going to want to modify the ICL so that it supports streaming queries.\r\n\r\nIndex optimizations. The reason we didn't do this is because we didn't want to have to build an optimizer for the first product. We're clearly going to need one to make secondary indexes usable so I think it's time to consider how to make one. We probably are only going to be doing trivial optimizations to start but I suspect we'll want to eventually support more complex things. Take this query for example:\r\nThe reason we didn't do this is because we didn't want to have to build an optimizer for the first product. We're clearly going to need one to make secondary indexes usable so I think it's time to consider how to make one. We probably are only going to be doing trivial optimizations to start but I suspect we'll want to eventually support more complex things. Take this query for example:\r\n\r\n    table.map(lambda x: x.extend(...)).order_by(\"id\")\r\n\r\nIt's not trivial to detect that we can use indexes for this but the performance on this query sucks if we don't because you need to fit everything in memory and there's actually no way around this without an optimizer. Reversing the order of the operations doesn't fix the problem (in fact it makes the performance worse)."
  , issueCommentId = 11415147
  }