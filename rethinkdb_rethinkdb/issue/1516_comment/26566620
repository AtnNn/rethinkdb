IssueComment
  { issueCommentUpdatedAt = 2013 (-10) (-18) 01 : 33 : 48 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/26566620"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1516#issuecomment-26566620"
  , issueCommentCreatedAt = 2013 (-10) (-18) 01 : 33 : 48 UTC
  , issueCommentBody =
      "I found this very useful blog post which describes how one can retrieve the stack trace at runtime in a form which can be processed further: http://tombarta.wordpress.com/2008/08/01/c-stack-traces-with-gcc/\r\n\r\nI will try to implement a kind of coroutine profiler which uses the stack trace to find out which function exactly a coroutine is in at the time where it yields.\r\nIt would still not help much if the yield happens far away from where a coroutine actually spends its time. However I guess one could then place additional \"profiling checkpoints\" throughout whichever part of the code is suspicious, making the profiler record timing data in those places in addition to places where coroutines yield.\r\n\r\nThe advantage over a general-purpose profiler would be its awareness of when a coroutine begins and ends executing."
  , issueCommentId = 26566620
  }