IssueComment
  { issueCommentUpdatedAt = 2013 (-10) (-18) 01 : 52 : 53 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 43867
        , simpleUserLogin = N "jdoliner"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/43867?v=3"
        , simpleUserUrl = "https://api.github.com/users/jdoliner"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/26567228"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1516#issuecomment-26567228"
  , issueCommentCreatedAt = 2013 (-10) (-18) 01 : 52 : 53 UTC
  , issueCommentBody =
      "We already have something exactly like that with lazy_backtrace_t I think.\r\n\r\n\r\nOn Thu, Oct 17, 2013 at 6:33 PM, Daniel Mewes <notifications@github.com>wrote:\r\n\r\n> I found this very useful blog post which describes how one can retrieve\r\n> the stack trace at runtime in a form which can be processed further:\r\n> http://tombarta.wordpress.com/2008/08/01/c-stack-traces-with-gcc/\r\n>\r\n> I will try to implement a kind of coroutine profiler which uses the stack\r\n> trace to find out which function exactly a coroutine is in at the time\r\n> where it yields.\r\n> It would still not help much if the yield happens far away from where a\r\n> coroutine actually spends its time. However I guess one could then place\r\n> additional \"profiling checkpoints\" throughout whichever part of the code is\r\n> suspicious, making the profiler record timing data in those places in\r\n> addition to places where coroutines yield.\r\n>\r\n> The advantage over a general-purpose profiler would be its awareness of\r\n> when a coroutine begins and ends executing.\r\n>\r\n> \8212\r\n> Reply to this email directly or view it on GitHub<https://github.com/rethinkdb/rethinkdb/issues/1516#issuecomment-26566620>\r\n> .\r\n>"
  , issueCommentId = 26567228
  }