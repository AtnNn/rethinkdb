IssueComment
  { issueCommentUpdatedAt = 2013 (-06) (-11) 04 : 27 : 33 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/19242270"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/889#issuecomment-19242270"
  , issueCommentCreatedAt = 2013 (-06) (-11) 04 : 27 : 33 UTC
  , issueCommentBody =
      "@jdoliner --\r\n\r\n* How would you represent `obj.pluck({:a => {:b => {:c => true}, :d => true}})` in your scheme?  As `obj.pluck({:a => [{:b => [:c]}, :d]})`?  It's much less obvious what that does at first sight, at least to me.  I think we should at least provide people the option to use the boolean notation.\r\n\r\n* I'd be fine with having pluck automatically map over arrays when it recurses down.  I think that's probably what people will want.  If we do this, then we could re-purpose arrays to match your proposed syntax and just accept both (i.e. `{:a => {:b => true}}` is identical to `{:a => [:b]}` or `{:a => :b}`).\r\n\r\n* The examples with `obj` inside of `pluck` were just meant to demonstrate that you could provide an arbitrary predicate in addition to a literal `true` or `false`.  I re-used `obj` because I didn't want to introduce a new variable, but in retrospect it just made the examples confusing.  I wasn't really trying to say anything special there."
  , issueCommentId = 19242270
  }