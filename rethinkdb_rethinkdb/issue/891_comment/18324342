IssueComment
  { issueCommentUpdatedAt = 2013 (-05) (-23) 05 : 40 : 50 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 181337
        , simpleUserLogin = N "pixelspark"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/181337?v=3"
        , simpleUserUrl = "https://api.github.com/users/pixelspark"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/18324342"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/891#issuecomment-18324342"
  , issueCommentCreatedAt = 2013 (-05) (-23) 05 : 40 : 50 UTC
  , issueCommentBody =
      "@mlucy how would your proposal work with nested keys? Will it only iterate over the top-level keys or will it recurse?\r\n\r\nIf it does recurse, it would be nice to have a sort of 'matchesPattern' function that could be used to test a given key(path) against a pattern so one could do e.g. \r\n```javascript\r\ntable.rename(function(key) {\r\n   return r.branch(key.matchesPattern({x:{y:{z:true}}}), \"new name for x.y.z\", key)\r\n})\r\n````\r\n\r\nAnother proposal is to make 'key' an array that contains the 'key path':\r\n```javascript\r\nr.expr({name:{first:\"John\", last:\"Doe\"}}).rename(function(key) {\r\n  // key would be ['name','first'] and ['name','last']. The following renames name.first to 'name.FIRST'\r\n  return r.branch(key.nth(1).eq('first'), 'FIRST', key)\r\n});\r\n```"
  , issueCommentId = 18324342
  }