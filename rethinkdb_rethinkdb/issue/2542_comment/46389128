IssueComment
  { issueCommentUpdatedAt = 2014 (-06) (-18) 02 : 15 : 18 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/46389128"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2542#issuecomment-46389128"
  , issueCommentCreatedAt = 2014 (-06) (-18) 02 : 15 : 18 UTC
  , issueCommentBody =
      "> Or maybe, when x runs on new_val and old_val, and fails on one of them, that entry is null. If it fails on both of them, the document's not part of the changefeed at all. That way, the changefeed can see what enters and removes the given selection. I think this might be what you really want and it seems to generally make sense.\r\n\r\nThat's what I would expect.\r\n\r\n> On that note, it might not be so bad internally -- I think datum_stream_t should have its role replaced in much of query evaluation with selection_t or something that merely describes a table and the operations that have been attached to in in order to form a selection, without that dreadful state related to streaming actual data.\r\n\r\nThis is basically how we do it now.  A `lazy_datum_stream_t` (which is the only kind we'd need to support this on I think) has a `reader_t` which contains an `std::vector<transform_variant_t>`.\r\n\r\n"
  , issueCommentId = 46389128
  }