Issue
  { issueClosedAt = Nothing
  , issueUpdatedAt = 2016 (-09) (-09) 04 : 52 : 24 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/5494/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/5494"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "0052cc"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:ReQL_proposal"
          , labelName = "tp:ReQL_proposal"
          }
      ]
  , issueNumber = 5494
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 33037
        , simpleUserLogin = N "segphault"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/33037?v=3"
        , simpleUserUrl = "https://api.github.com/users/segphault"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "Support JSON Schema validation"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/5494"
  , issueCreatedAt = 2016 (-03) (-08) 22 : 25 : 58 UTC
  , issueBody =
      Just
        "As we've discussed a few times, it'd be really nice for RethinkDB to natively support JSON Schema validation. Possibly, this feature could be exposed through a new ReQL term that could be used in conjunction with others like `r.branch` to make operations conditionally depend on validation.\r\n\r\n## Handling Refs\r\n\r\nOne of the most complex issues to address in JSON Schema implementations is handling references. A reference, signified by the `$ref` key, allows a JSON Schema to point to another document or node that the validator should use in its place. When writing JSON Schemas, you typically [structure it in parts](http://spacetelescope.github.io/understanding-json-schema/structuring.html) that you can reference in order to maximize reuse.\r\n\r\nIn conventional schemas, references either:\r\n\r\n* Point to another node in the same document\r\n* Point to another document entirely, using a URL\r\n  \r\nAssuming that schemas are stored in RethinkDB like any other JSON document, we'd need a way for the documents to reference other documents stored in the database. Ideally, something like the proposed [document reference pseudotype](https://github.com/rethinkdb/rethinkdb/issues/4853) could address this issue.\r\n\r\nIt might be easier, in the short term, to make it so that the schema validation ReQL term can optionally take an anonymous function with a ReQL expression that specifies how to resolve references.\r\n\r\nThere are some major wrinkles that make it difficult to simply walk the tree and replace `$ref` nodes with the content that they specify. Most notably, it's common to use mutually recursive schemas to model a structure with potentially infinite depth. It's important for JSON Schema implementations to support that common pattern without choking.\r\n\r\n## Failure modes\r\n\r\nUsers might want to have the option of enabling some alternate behaviors aside from basic failure when a document doesn't validate against a schema. These are two that come to mind as being particularly useful:\r\n\r\n* Strip properties that don't conform with the schema\r\n* Automatically coerce data types in cases where a property value has the wrong type\r\n\r\n## Programmatic validation rules\r\n\r\nSome popular JSON Schema implementations give users a way to define their own custom validation keywords with programmatic validation rules. Although perhaps not needed in the first pass, it might eventually be nice to support this feature, allowing custom validation functions to be implemented with either ReQL, JavaScript (executed using the same engine as r.js), or both.\r\n\r\n## Valijson\r\n\r\nThe open source [valijson](https://github.com/tristanpenman/valijson) library could be a useful starting point for implementing JSON Schemas in RethinkDB. It is BSD-licensed and supports RapidJSON.\r\n\r\nIn valijson, you can [provide a callback](https://github.com/tristanpenman/valijson/blob/master/tests/test_fetch_document_callback.cpp#L67) that it will use to resolve references, but the feature is still classified as experimental. In order to avoid the recursion trap, it invokes the callback as needed during validation rather than while it is building the schema. As described in the readme, there's a branch where the developer is working on a two-pass schema loader that will hopefully improve the situation."
  , issueState = "open"
  , issueId = Id 139412406
  , issueComments = 32
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 505365
                , simpleUserLogin = N "danielmewes"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/505365?v=3"
                , simpleUserUrl = "https://api.github.com/users/danielmewes"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 86
          , milestoneNumber = 123
          , milestoneClosedIssues = 22
          , milestoneDescription = Just ""
          , milestoneTitle = "2.4-polish"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/123"
          , milestoneCreatedAt = 2016 (-04) (-28) 19 : 25 : 10 UTC
          , milestoneState = "open"
          }
  }