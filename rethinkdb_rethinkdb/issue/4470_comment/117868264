IssueComment
  { issueCommentUpdatedAt = 2015 (-07) (-02) 01 : 22 : 44 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 552910
        , simpleUserLogin = N "Tryneus"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/552910?v=3"
        , simpleUserUrl = "https://api.github.com/users/Tryneus"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/117868264"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4470#issuecomment-117868264"
  , issueCommentCreatedAt = 2015 (-07) (-02) 01 : 22 : 44 UTC
  , issueCommentBody =
      "@rotten: Thanks for access to your machine.  I took a look at `gearservices1` and managed to reproduce the error with a small test program:\r\n\r\n```c++\r\n#include <errno.h>\r\n#include <stddef.h>\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netdb.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nvoid run_for_address_family(int family, const char *name) {\r\n    printf(\"Running for address family: %d\\n\", family);\r\n\r\n    struct addrinfo hint;\r\n    memset(&hint, 0, sizeof(hint));\r\n    hint.ai_family = family;\r\n    hint.ai_socktype = SOCK_STREAM;\r\n    struct addrinfo *result;\r\n    int res = getaddrinfo(name, NULL, &hint, &result);\r\n\r\n    int errno_sv = errno;\r\n    if (res == EAI_SYSTEM) {\r\n        printf(\"error: %d - %s\\n\", errno_sv, strerror(errno_sv));\r\n    } else if (res != 0) {\r\n        printf(\"error: %d - %s\\n\", res, gai_strerror(res));\r\n    } else {\r\n        for (struct addrinfo *item = result; item != NULL; item = item->ai_next) {\r\n            printf(\"Got address for family: %d (sockaddr family: %d):\\n\"\r\n                   \"  ai_flags: %d\\n\"\r\n                   \"  ai_socktype: %d\\n\"\r\n                   \"  ai_protocol: %d\\n\"\r\n                   \"  ai_addrlen: %d\\n\",\r\n                   item->ai_family, item->ai_addr->sa_family, item->ai_flags, item->ai_socktype, item->ai_protocol, item->ai_addrlen);\r\n        }\r\n\r\n        freeaddrinfo(result);\r\n    }\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    if (argc == 2) {\r\n        printf(\"IPv4 family: %d\\nIPv6 family: %d\\n\", AF_INET, AF_INET6);\r\n        run_for_address_family(AF_INET, argv[1]);\r\n        run_for_address_family(AF_INET6, argv[1]);\r\n        run_for_address_family(AF_UNSPEC, argv[1]);\r\n    } else {\r\n        printf(\"Expected a hostname argument\\n\");\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\nThe program runs `getaddrinfo` three times - once for IPv4 addresses, once for IPv6 addresses, and once for any address family.  This works as expected if I run the program for `localhost` or something like `google.com`.  But when I run the test for `gearservices1`, I get a strange result:\r\n\r\n```\r\nIPv4 family: 2\r\nIPv6 family: 10\r\nRunning for address family: 2\r\nGot address for family: 2 (sockaddr family: 2):\r\n  ai_flags: 0\r\n  ai_socktype: 1\r\n  ai_protocol: 6\r\n  ai_addrlen: 16\r\nRunning for address family: 10\r\nGot address for family: 10 (sockaddr family: 10):\r\n  ai_flags: 0\r\n  ai_socktype: 1\r\n  ai_protocol: 6\r\n  ai_addrlen: 28\r\nGot address for family: 24992 (sockaddr family: 24992):\r\n  ai_flags: 0\r\n  ai_socktype: 1\r\n  ai_protocol: 6\r\n  ai_addrlen: 16\r\nRunning for address family: 0\r\nGot address for family: 10 (sockaddr family: 10):\r\n  ai_flags: 0\r\n  ai_socktype: 1\r\n  ai_protocol: 6\r\n  ai_addrlen: 28\r\nGot address for family: 2 (sockaddr family: 2):\r\n  ai_flags: 0\r\n  ai_socktype: 1\r\n  ai_protocol: 6\r\n  ai_addrlen: 16\r\n```\r\n\r\nAs you can see, AF_INET and AF_UNSPEC work as expected, but AF_INET6 gives the valid IPv6 address plus a not-fully-initialized structure.  It appears to have the size of an IPv4 address (which it shouldn't return when we're doing an IPv6 query), and the address family is random garbage (though the address family is set identically in the surrounding `addrinfo` struct and the internal `sockaddr` struct).\r\n\r\nThis leads me to believe this is a bug in the glibc implementation installed on the machine.  The version installed appears to be:\r\n\r\n```\r\n> /lib/x86_64-linux-gnu/libc.so.6\r\nGNU C Library (Ubuntu EGLIBC 2.19-0ubuntu6.6) stable release version 2.19\r\n```\r\n\r\nThere have been some bugs/patches in [EGLIBC](http://www.eglibc.org/home) related to `getaddrinfo` and DNS lookups, so it may help to install a newer version on the machine.  At least one of the bugs was related to `nscd`, which I noticed is running on the server, so it may be worth it to disable that and see if the problem is resolved.  It is also worth noting that EGLIBC has been discontinued and merged into GLIBC.\r\n\r\nLet me know if this helps resolve the problem, or if you have any more questions."
  , issueCommentId = 117868264
  }