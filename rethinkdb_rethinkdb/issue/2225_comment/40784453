IssueComment
  { issueCommentUpdatedAt = 2014 (-04) (-28) 18 : 31 : 42 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 552910
        , simpleUserLogin = N "Tryneus"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/552910?v=3"
        , simpleUserUrl = "https://api.github.com/users/Tryneus"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/40784453"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2225#issuecomment-40784453"
  , issueCommentCreatedAt = 2014 (-04) (-18) 03 : 36 : 17 UTC
  , issueCommentBody =
      "Ok, I've done a good amount of work on the protocol, so I'm putting a partial writeup here in case it's useful.  Could still use some more details and examples.\r\n\r\n## Driver Handshake\r\nThe client should send the following things to the server's driver port (default is `28015`):\r\n* 4-byte version magic number, little-endian, corresponding to VersionDummy::Version::V0_3, for this version of the protocol\r\n* 4-byte length, little-endian, giving the length of the authorization key string (this may be 0 if no authorization key is given)\r\n* authorization key string, in ASCII\r\n* 4-byte wire protocol magic number, little-endian, corresponding to VersionDummy::Protocol::JSON, for this version of the protocol\r\n\r\nThe server will then reply with a NULL-terminated ASCII string regarding the result of the connection attempt.  If the string is \"SUCCESS\", the client may begin sending queries and receive responses, as detailed below.  On an error, the string should contain some description of why the attempt failed, and the TCP connection will be closed.\r\n### Example\r\n#### No authorization key\r\nClient to Server:\r\n\r\n| Version | Auth Length |  Wire Protocol |\r\n|:----:|:----:|:----:|:----:|\r\n| `3e e8 75 5f` | `00 00 00 00` | `c7 70 69 7e` |\r\n| 0x5f75e83e | 0x00000000 | 0x7e6970c7 |\r\n\r\nServer to Client:\r\n\r\n| Response String | NULL |\r\n|:----:|:----:|\r\n| `53 55 43 43 45 53 53` | `00` |\r\n| \"SUCCESS\" | |\r\n\r\n#### Incorrect Authorization Key\r\nClient to Server:\r\n\r\n| Version | Auth Length | Auth Key | Wire Protocol |\r\n|:----:|:----:|:----:|:----:|:----:|\r\n| `3e e8 75 5f` | `07 00 00 00` | `68 75 6e 74 65 72 32` | `c7 70 69 7e` |\r\n| 0x5f75e83e | 0x00000007 | \"hunter2\" | 0x7e6970c7 |\r\n\r\nServer to Client:\r\n\r\n| Response String | NULL |\r\n|:----:|:----:|\r\n| `45 52 52 4f 52 3a 20 49 6e 63 6f 72 72 65 63 74 20 61 75 74 68 6f 72 69 7a 61 74 69 6f 6e 20 6b 65 79 2e` | `00` |\r\n| \"ERROR: Incorrect authorization key.\" | |\r\n\r\n## Queries\r\nThe query format (client to server) is as follows:\r\n* 8-byte token, little-endian, providing a unique ID for the query\r\n* 4-byte length, little-endian, giving the length in bytes of the JSON string following this\r\n* JSON string request, as an array with the following elements:\r\n  * The type of the query, an integer given by Query::QueryType in `ql2.proto`\r\n  * The terms for the query, (see below).  This should only be included for queries with Query::QueryType::START.\r\n  * The global optargs for the query, as a dict (see below).  This should only be included for queries with Query::QueryType::START, and may be omitted if the dict has no entries.\r\n\r\nQuery terms:\r\n*TODO*\r\n\r\nValid global optargs:\r\n* `db` - a string giving the default database to use if no `r.db(...)` is included in the query\r\n* `use_outdated` - a boolean indicating whether outdated reads may be performed\r\n* `noreply` - a boolean telling the server whether to send a response for the query\r\n* `profile` - a boolean telling the server whether to include profiler data in the response\r\n* `durability` - a string telling the server the type of write durability to use, possible values are \"hard\" and \"soft\"\r\n\r\n### Examples\r\n*TODO*\r\n\r\n## Responses\r\nThe response format (server to client) is as follows:\r\n* 8-byte token, little-endian, corresponding to the token given in a previous query\r\n* 4-byte length, little-endian, giving the length in bytes of the JSON string following this\r\n* JSON string response as a dict with the following keys:\r\n  * `t` - required, the type of the response, an integer given by Response::ResponseType in `ql2.proto`\r\n  * `r` - required, the result data from the query, as an array\r\n  * `b` - optional, the backtrace from the query if an error occurred\r\n  * `p` - optional, the profile data from the query if `profile=True` was specified in the global optargs\r\n\r\n### Examples\r\n*TODO*\r\n#### Atom\r\n#### Sequence\r\n#### Error\r\n\r\n## Things to Be Careful About\r\n* Unicode string lengths\r\n  * When passing length-prefixed strings to the server, make sure that the length given is the number of bytes, not the number of characters\r\n* NaN/Infinity\r\n  * NaN and Infinity are not allowed in Datums on the server\r\n  * These values are not valid in JSON, so some libraries might write them as strings\r\n  * The driver should reject NaN and Infinity rather than attempt to send them to the server"
  , issueCommentId = 40784453
  }