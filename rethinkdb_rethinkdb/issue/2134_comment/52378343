IssueComment
  { issueCommentUpdatedAt = 2014 (-08) (-16) 01 : 30 : 01 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 258437
        , simpleUserLogin = N "srh"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/258437?v=3"
        , simpleUserUrl = "https://api.github.com/users/srh"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/52378343"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2134#issuecomment-52378343"
  , issueCommentCreatedAt = 2014 (-08) (-16) 01 : 30 : 01 UTC
  , issueCommentBody =
      "How this will work:\r\n\r\nWe will *NOT* have a long-running snapshot of the main b-tree while post-constructing a secondary index.\r\n\r\nThe important timestamps are in the main b-tree.  Secondary index entries need a different sort of metadata.\r\n\r\n- All new key/value pairs in the main b-tree are timestamped.  Old ones, from version 1.14 and earlier, might not be, and that's OK, because the only question we'll need to answer, when looking at a timestamp, is whether it's before or after the time when the secondary index began post-constructing.  (This differs from the existing implementation, where only some of the newest key/value pairs are timestamped.  We will continue rapidly expiring deletion entries, which are always timestamped.)\r\n\r\nDefine \"old{t0} value\" to mean a value whose timestamp is <= t0.  And \"new{t0} value\" is one that is not old{t0}.\r\n\r\nWhen a post-construction begins with the latest value in the tree having timestamp t0, the post-constructing secondary index's entries will have metadata identifying it as a member of one of the following categories:\r\n  1. An old{t0} value, that was inserted by the post-construction process.\r\n  2. A new{t0} deletion entry.\r\n  3. A new{t0} value: also, a deletion entry should be left behind when the value is removed.\r\n  4. A new{t0} value: also, NO deletion entry should be left behind when the value is removed.\r\n\r\nThe post-construction \"process\" that walks the b-tree does a series of small range traversals that covers the entire key range.  When it comes across an old{t0} key/value pair, it throws it at the secondary index in a separate write transaction.  In that write transaction, if a new{t0} value or deletion entry is present, it is untouched, except to say that if the value is removed, a deletion entry should be left behind.  Otherwise, the old{t0} value gets inserted, if one isn't already present.\r\n\r\nWhen a new write comes in and modifies a value, it (naturally) updates the secondary indexes.  Generally speaking, it has to remove the value from its old location (if an old value existed) and insert a value at the new location (if it's not a deletion).  In a post-constructing index, the old value (which exists if the write is not a fresh insertion) and secondary index might be in one of several states:\r\n  1. An old{t0} value, with no entry present in the secondary index:  The post-construction process has not yet inserted it.  We must leave behind a deletion entry for its key.\r\n  2. An old{t0} value, that was inserted by the post-construction process:  We must replace it with a deletion entry.\r\n  3. A new{t0} value, and the entry says that a deletion entry should be left behind:  We must replace it with a deletion entry.\r\n  4. A new{t0} value, and the entry says that NO deletion entry should be left behind:  We must remove it.\r\n  5. We find a deletion entry already present: Crash, this is impossible.\r\n\r\nIn a post-constructing index, the new value (which exists if the write is not a deletion) is always a new{t0} value.  The secondary index, after removing the old value, might be in one of several states:\r\n  1. Has a deletion entry for that value's key: Replace it with a new{t0} value, with the entry saying that a deletion entry should be left behind.\r\n  2. Has nothing for the value's key: Insert a new{t0} value, with the entry saying that NO deletion entry should be left behind.\r\n\r\nIt is permissible for the post-construction process to accidentally re-scan the same section of the b-tree and reprocess the same key/value pairs.  If the post-construction process walks the b-tree from left to right, we could save the end of the last completed post-construction key range in the secondary index superblock (or somewhere) to allow post-construction to resume after a shutdown and restart."
  , issueCommentId = 52378343
  }