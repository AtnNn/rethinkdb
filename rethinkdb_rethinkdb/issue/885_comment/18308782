IssueComment
  { issueCommentUpdatedAt = 2013 (-05) (-22) 21 : 21 : 05 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/18308782"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/885#issuecomment-18308782"
  , issueCommentCreatedAt = 2013 (-05) (-22) 21 : 21 : 05 UTC
  , issueCommentBody =
      "In general I have a preference for including families of commands with different semantics over flags specifying subtle distinctions in behaviors. Rather than having an \"including_nulls\" flag how about we just have two related commands in the same way we're planning on having a strict field existence command vs. a looser exists and is not null command.\r\n\r\nThe obvious analogy is to the JS `==` vs. `===` operators. Can you imagine having to specify `a (==, strict_equality=true) b`?\r\n\r\n\r\nCould I also ask for some clarity on just what `has_fields` means on a sequence? Are you suggesting the following:\r\n\r\n```python\r\nstream.has_fields('a')\r\n   =>\r\nstream.filter(r.row.has_fields('a'))\r\n```\r\n\r\nThat behavior doesn't seem very intuitive to me. Elsewhere we support such polymorphism the stream version is more or less equivalent to `map(command)`. "
  , issueCommentId = 18308782
  }