IssueComment
  { issueCommentUpdatedAt = 2016 (-04) (-28) 01 : 49 : 20 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/215283644"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5725#issuecomment-215283644"
  , issueCommentCreatedAt = 2016 (-04) (-28) 01 : 49 : 20 UTC
  , issueCommentBody =
      "> So if a symbol isn't defined in the client, we couldn't actually convert a symbol stored in a RethinkDB document back into a client symbol, could we?\r\n\r\nMost dynamic languages let you intern symbols at runtime, but it's usually bad style to do this too much because a lot of languages don't garbage-collect symbols (even Ruby didn't before 2.2).\r\n\r\n---\r\n\r\nWe've pretty much committed to being a JSON store at this point, so if we added Symbols they'd have to be a pseudotype like times.  The benefit would be that JS and Ruby users could store and retrieve objects and have the symbol/string distinction preserved.  I'm not sure how large this benefit is, though -- in Ruby at least people are already used to JSON encoding/decoding turning symbols into strings, and JS users will probably run into the same thing if they're using symbols in their objects and serializing them regularly.  And the downside is pretty large; we'd be adding a new pseudotype to the language that doesn't provide any additional functionality, and it would increase the gap between different clients (people reading data in a language that doesn't have a symbol type would have to preserve the distinction, so they'd be forced to interact with an ugly psuedotype object locally)."
  , issueCommentId = 215283644
  }