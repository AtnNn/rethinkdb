IssueComment
  { issueCommentUpdatedAt = 2014 (-01) (-11) 22 : 01 : 31 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 297060
        , simpleUserLogin = N "nviennot"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/297060?v=3"
        , simpleUserUrl = "https://api.github.com/users/nviennot"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/32108526"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1388#issuecomment-32108526"
  , issueCommentCreatedAt = 2014 (-01) (-11) 22 : 01 : 11 UTC
  , issueCommentBody =
      "> Noreply operations never generate responses to the client, so the client has no chance to keep track on their status.\r\n\r\nThen don't let the database know that you won't listen to the reply? If it's a driver concern, then implementing futures/promises will be awesome.\r\n\r\n> I have a slight preference for calling noreply_wait as part of close and reconnect, simply because I would expect a write (even if it is noreply) followed by properly closing the connection to not be lost. That is the same semantics that one has with files on Unix and probably any other OS that supports files.\r\n\r\nPerhaps on files, but not sockets.\r\n\r\n> But then again if one makes a decision to not handle lost connections, one can always call close/reconnect with the noreply_wait=false argument\r\n\r\nI don't understand.\r\n\r\n> We certainly have to make the semantics of close/reconnect with respect to already closed connections clearer in the documentation.\r\n\r\nBut why document complexity when complexity can be avoided by having the user call noreply_wait at some point if he uses noreply queries?"
  , issueCommentId = 32108526
  }