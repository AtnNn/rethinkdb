IssueComment
  { issueCommentUpdatedAt = 2013 (-09) (-01) 00 : 03 : 53 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/23616280"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1388#issuecomment-23616280"
  , issueCommentCreatedAt = 2013 (-09) (-01) 00 : 03 : 53 UTC
  , issueCommentBody =
      "The point of a noreply write is that you don't care TOO much whether it succeeds or not, but if you're using one connection per write and issuing large or complicated batched writes then our success rate is close to 0% even on otherwise valid writes, which seems really really bad.\r\n\r\nAs a general rule, though, we shouldn't make write queries randomly fail because users did something too soon when we don't give them any way to know when \"too soon\" is.\r\n\r\nIf we aren't comfortable having uninterruptible queries, we could make it so that sending a STOP query with the same token will interrupt the noreply write even though closing the connection doesn't.\r\n\r\n(Also, @coffeemug, I read @underrun's comment completely differently; I think he agrees that we shouldn't kill the write -- \"when my write operation returns i should expect to be able to close the connection without killing what i thought i just did.\")\r\n\r\n(Also also, @coffeemug, I'm pretty sure this should be in 1.9.x, since IMO it's a bug and we should do a point-release for it.)"
  , issueCommentId = 23616280
  }