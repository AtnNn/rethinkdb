IssueComment
  { issueCommentUpdatedAt = 2014 (-01) (-11) 21 : 23 : 10 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 297060
        , simpleUserLogin = N "nviennot"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/297060?v=3"
        , simpleUserUrl = "https://api.github.com/users/nviennot"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/32107541"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1388#issuecomment-32107541"
  , issueCommentCreatedAt = 2014 (-01) (-11) 21 : 23 : 10 UTC
  , issueCommentBody =
      "After failing at fixing ruby threading issue on https://github.com/rethinkdb/rethinkdb/pull/1849 I started thinking about what should the `close` and `reconnect` semantics should be based on the current documentation.\r\nI think having `close` and `reconnect` wait for noreply writes is bad because the semantics become unclear.\r\n\r\nWhen calling `reconnect` on a connection that have been lost, the driver would internally call `noreply_wait`, which would then raise an exception \"connection closed\". So we fixed that with https://github.com/rethinkdb/rethinkdb/pull/1847 which is terrible, because we are just swallowing any exceptions that `noreply_wait` would raise (which made the recursive locking failure silent in https://github.com/rethinkdb/rethinkdb/pull/1849).\r\n\r\nOkay so perhaps a better implementation is to call `noreply_wait` only when the connection is present instead of swallowing errors. But that doesn't solve the issue: What are the semantics of `reconnect/close` when the connection is lost in the middle of `noreply_wait`? I would find it pretty surprising to get a connection close exception when I'm calling `close` (because that's what I'm trying to do in the first place).\r\n\r\nMaybe you could detect the type of the exception if noreply_wait failed because of a connection issue, and in this case there is not much you can do if the user had some buffered (noreply) writes pending. Should you raise an exception? Probably, but only if the user had at least one buffered write pending. In the other case, we should detect that you are getting a connection issue (which is not trivial, c.f. nobrainer: https://github.com/nviennot/nobrainer/blob/next/lib/no_brainer/query_runner/connection.rb#L32-L43) and swallow it when noreply_wait is called from reconnect/close.\r\n\r\nYou can argue that you are no different than the POSIX `close` semantics: http://man7.org/linux/man-pages/man2/close.2.html\r\n\r\n> Not checking the return value of close() is a common but nevertheless\r\n       serious programming error.  It is quite possible that errors on a\r\n       previous write(2) operation are first reported at the final close().\r\n       Not checking the return value when closing the file may lead to\r\n       silent loss of data\r\n\r\nBut when starting to build abstractions on top of that, like in C++, you wouldn't want your destructor to raise if close() was unsuccessful right? Well, you could call some sort of `flush` that could raise, and then destroy your object which doesn't raise.\r\n\r\nSide note: the POSIX `close()` semantics on a socket is to not wait for buffered writes to get flushed. One must call `shutdown(sock, SHUT_WR)` and wait for EOF on the socket to flush the writes.\r\n\r\nSo the pattern here is to really have two API calls to properly close a connection, otherwise you are looking for trouble.\r\n\r\nEven when using a threaded rethinkdb driver, it's not obvious to prevent bugs like:\r\n* thread1 calls close, which internally calls noreply_wait\r\n* thread2 issues a db write right after thread1's noreply_wait is queued on the socket\r\n* thread1 kills the socket once the server acks the noreply_wait\r\n\r\nthread2's write will never be waited for. This could be fixed by having mutexes everywhere to prevent writes to the socket once a close has been initiated (except for the internal noreply wait which will be able to write anyway).\r\nAnyway, this noreply_wait while closing behavior creates really really non trivial behavior, especially when the network is not behaving properly.\r\n\r\n---\r\n\r\nThe whole issue can be avoided by having the user explicitly call noreply_wait before closing the db connection.\r\n\r\nAPI change proposal for `close/reconnect`:\r\n* `close/reconnect` never wait for noreply queries to complete.\r\n* Document that when writing with noreply, the user must call noreply_wait, otherwise you may lose data.\r\n* noreply_wait is responsible to throw an exception if the connection is lost in case of buffered writes.\r\n* As a nice to have, we could emit a warning if one calls close() without having called noreply_wait when at least one noreply write has been performed since the last noreply_wait.\r\n\r\nAlso, I don't understand why the RQL protocol has some noreply_wait types. Why is the database dealing with that? It's a driver concern. The driver should remember all the query tokens and collect their responses when they come in to let the user retrieve the status of these writes asynchronously either with a future/promises pattern, or noreply_wait."
  , issueCommentId = 32107541
  }