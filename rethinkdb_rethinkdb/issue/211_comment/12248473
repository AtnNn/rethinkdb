IssueComment
  { issueCommentUpdatedAt = 2013 (-01) (-15) 00 : 56 : 44 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/12248473"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/211#issuecomment-12248473"
  , issueCommentCreatedAt = 2013 (-01) (-15) 00 : 56 : 44 UTC
  , issueCommentBody =
      "Ahh, I see. I kept thinking, what's the point, we already have errors that propagate like this. The distinction is that bottom is a value propagated up the function composition chain rather than an exception that jumps up the call stack to an error handler. While the behavior is similar it is actually subtly different.\r\n\r\nWhile we don't have `throw` we already support `error` which is a function that simply returns bottom. I suppose the challenge is to document `r.error` and `r.catch` in a way that does not suggest throw catch behavior. That's why I think the current `r.error` is a better name than `r.throw` any why I thought that perhaps `r.default` was a better name than `r.catch`.\r\n\r\nRather than saying that `bottom` is the type returned by `r.error` and one that has special semantics, why not just use the term error? Again we have to explain how errors propagate but in this sense too I think that the term error conveys the meaning we want. While exception would imply short circuiting behavior, the term error I think invokes the notion of a special return value (as in languages like C that don't support exceptions) which is what we mean to imply."
  , issueCommentId = 12248473
  }