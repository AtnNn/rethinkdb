IssueComment
  { issueCommentUpdatedAt = 2014 (-06) (-27) 01 : 00 : 59 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47297973"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2612#issuecomment-47297973"
  , issueCommentCreatedAt = 2014 (-06) (-27) 01 : 00 : 59 UTC
  , issueCommentBody =
      "> Well, the issue is you just don't know in python2 from the type alone. If\r\nyou insert a `str`, it'll just go in as a normal string value, there's\r\nnothing to tell us we need to raise an exception. You might try utf-8\r\nencoding and decoding first and if it fails assume they were trying to do a\r\nbinary, but you'd incur that cost on every string insert which doesn't\r\nsound like a good idea.\r\n\r\nWe have to detect the error at some point on the server when we're decoding the string.  (One could argue we have to detect the error in the client when we serialize the query to JSON because the JSON spec defines a string as a sequence of Unicode characters, so you can't just drop e.g. a null byte in the middle of one.)  Wherever we detect that the string isn't a Unicode string, we should produce an error suggesting `r.binary`.\r\n\r\nI think it would be very bad if `r.binary` threw an error when you passed it a string that doesn't technically need to be encoded as binary data, both because it makes it hard to write code that you know won't throw and because we need some way to let people make binary blobs containing only ASCII characters (to match a schema they have in their head, for example, or because another query branches on the type of a field)."
  , issueCommentId = 47297973
  }