IssueComment
  { issueCommentUpdatedAt = 2014 (-09) (-11) 10 : 03 : 17 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 811701
        , simpleUserLogin = N "robert-zaremba"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/811701?v=3"
        , simpleUserUrl = "https://api.github.com/users/robert-zaremba"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/55243967"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2574#issuecomment-55243967"
  , issueCommentCreatedAt = 2014 (-09) (-11) 10 : 03 : 17 UTC
  , issueCommentBody =
      ":+1: for variadic map. It's a common solution. Maybe having an other function (`mapIdx`, `mapI`, `mapWithIndex`...) with explicit index argument would be a winning solution for both  both performance and clarity reasons.\r\n\r\n`map` transforms a content in a context. `zip` merges a content of few contexts. Those are high level functional operators and should keep the traditional meaning.\r\nIn Haskell there is a very clean solution for this:\r\n\r\n* `containers Data.Sequence.zip` takes two sequences and returns a sequence of corresponding pairs. If one input is short, excess elements are discarded from the right end of the longer\r\n* `containers Data.Sequence.zipWith` generalizes zip by zipping with the function given as the first argument, instead of a tupling function. For example, zipWith (+) is applied to two sequences to take the sequence of corresponding sums. \r\n*  `containers Data.Sequence.mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b`\r\nA generalization of fmap, mapWithIndex takes a mapping function that also depends on the element's index, and applies it to every element in the sequence.\r\n"
  , issueCommentId = 55243967
  }