Issue
  { issueClosedAt = Just 2015 (-08) (-20) 04 : 13 : 20 UTC
  , issueUpdatedAt = 2015 (-08) (-21) 22 : 35 : 02 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/4721/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/4721"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "e10c02"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/pr:high"
          , labelName = "pr:high"
          }
      , IssueLabel
          { labelColor = "e102d8"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:bug"
          , labelName = "tp:bug"
          }
      ]
  , issueNumber = 4721
  , issueAssignee =
      Just
        SimpleUser
          { simpleUserId = Id 552910
          , simpleUserLogin = N "Tryneus"
          , simpleUserAvatarUrl =
              "https://avatars.githubusercontent.com/u/552910?v=3"
          , simpleUserUrl = "https://api.github.com/users/Tryneus"
          , simpleUserType = OwnerUser
          }
  , issueUser =
      SimpleUser
        { simpleUserId = Id 552910
        , simpleUserLogin = N "Tryneus"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/552910?v=3"
        , simpleUserUrl = "https://api.github.com/users/Tryneus"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "Crash in v2.1.1: Branch history is missing pieces"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/4721"
  , issueCreatedAt = 2015 (-08) (-19) 01 : 57 : 11 UTC
  , issueBody =
      Just
        "Testing on a single node, I had a script creating tables inside the database `test`.  Meanwhile, I ran this in the web UI: `r.dbDrop('test')`.  While the server was still dropping the tables inside the database, I killed it.  Upon restart, I ran the same command and killed the server in the middle of it again.  Further attempts to restart the server resulted in this crash:\n\n```\nVersion: rethinkdb 2.1.1-dirty (debug) (GCC 4.6.3)\nerror: Error in ../src/clustering/table_contract/contract_metadata.cc at line 86:\nerror: Branch history is missing pieces\nerror: Backtrace:\nerror: Tue Aug 18 18:52:46 2015\n\n       1: rethinkdb_backtrace(void**, int) at rethinkdb_backtrace.cc:101\n       2: backtrace_t::backtrace_t() at backtrace.cc:203\n       3: lazy_backtrace_formatter_t::lazy_backtrace_formatter_t() at backtrace.cc:283\n       4: format_backtrace(bool) at backtrace.cc:198\n       5: report_fatal_error(char const*, int, char const*, ...) at errors.cc:83\n       6: contract_ack_t::sanity_check(uuid_u const&, uuid_u const&, table_raft_state_t const&) const at contract_metadata.cc:86\n       7: calculate_all_contracts(table_raft_state_t const&, std::map<uuid_u, std::map<uuid_u, contract_ack_t, std::less<uuid_u>, std::allocator<std::pair<uuid_u const, contract_ack_t> > >, std::less<uuid_u>, std::allocator<std::pair<uuid_u const, std::map<uuid_u, contract_ack_t, std::less<uuid_u>, std::allocator<std::pair<uuid_u const, contract_ack_t> > > > > > const&, watchable_map_t<std::pair<uuid_u, uuid_u>, empty_value_t>*, std::set<uuid_u, std::less<uuid_u>, std::allocator<uuid_u> >*, std::map<uuid_u, std::pair<hash_region_t<key_range_t>, contract_t>, std::less<uuid_u>, std::allocator<std::pair<uuid_u const, std::pair<hash_region_t<key_range_t>, contract_t> > > >*, std::map<hash_region_t<key_range_t>, uuid_u, std::less<hash_region_t<key_range_t> >, std::allocator<std::pair<hash_region_t<key_range_t> const, uuid_u> > >*, std::set<uuid_u, std::less<uuid_u>, std::allocator<uuid_u> >*, branch_history_t*) at calculate_contracts.cc:495\n       8: ../build/debug/rethinkdb() [0x1e08a17] at 0x1e08a17 ()\n       9: ../build/debug/rethinkdb() [0x1e0a51d] at 0x1e0a51d ()\n       10: std::function<void (raft_member_t<table_raft_state_t>::state_and_config_t const*)>::operator()(raft_member_t<table_raft_state_t>::state_and_config_t const*) const at functional:2162\n       11: watchable_variable_t<raft_member_t<table_raft_state_t>::state_and_config_t>::apply_read(std::function<void (raft_member_t<table_raft_state_t>::state_and_config_t const*)> const&) at watchable.hpp:232\n       12: watchable_variable_t<raft_member_t<table_raft_state_t>::state_and_config_t>::w_t::apply_read(std::function<void (raft_member_t<table_raft_state_t>::state_and_config_t const*)> const&) at watchable.hpp:264\n       13: contract_coordinator_t::pump_contracts(signal_t*) at coordinator.cc:165\n       14: std::_Mem_fn<void (contract_coordinator_t::*)(signal_t*)>::operator()(contract_coordinator_t*, signal_t*) const at functional:551\n       15: void std::_Bind<std::_Mem_fn<void (contract_coordinator_t::*)(signal_t*)> (contract_coordinator_t*, std::_Placeholder<1>)>::__call<void, signal_t*&&, 0, 1>(std::tuple<signal_t*&&>&&, std::_Index_tuple<0, 1>) at functional:1147\n       16: void std::_Bind<std::_Mem_fn<void (contract_coordinator_t::*)(signal_t*)> (contract_coordinator_t*, std::_Placeholder<1>)>::operator()<signal_t*, void>(signal_t*&&) at functional:1206\n       17: std::_Function_handler<void (signal_t*), std::_Bind<std::_Mem_fn<void (contract_coordinator_t::*)(signal_t*)> (contract_coordinator_t*, std::_Placeholder<1>)> >::_M_invoke(std::_Any_data const&, signal_t*) at functional:1780\n       18: std::function<void (signal_t*)>::operator()(signal_t*) const at functional:2162\n       19: pump_coro_t::run(auto_drainer_t::lock_t) at pump_coro.cc:95\n       20: std::_Mem_fn<void (pump_coro_t::*)(auto_drainer_t::lock_t)>::operator()(pump_coro_t*, auto_drainer_t::lock_t) const at functional:551\n       21: void std::_Bind<std::_Mem_fn<void (pump_coro_t::*)(auto_drainer_t::lock_t)> (pump_coro_t*, auto_drainer_t::lock_t)>::__call<void, , 0, 1>(std::tuple<>&&, std::_Index_tuple<0, 1>) at functional:1146\n       22: void std::_Bind<std::_Mem_fn<void (pump_coro_t::*)(auto_drainer_t::lock_t)> (pump_coro_t*, auto_drainer_t::lock_t)>::operator()<, void>() at functional:1206\n       23: callable_action_instance_t<std::_Bind<std::_Mem_fn<void (pump_coro_t::*)(auto_drainer_t::lock_t)> (pump_coro_t*, auto_drainer_t::lock_t)> >::run_action() at callable_action.hpp:31\n       24: callable_action_wrapper_t::run() at runtime_utils.cc:43\n       25: coro_t::run() at coroutines.cc:207\n       26: coro_t* coro_t::spawn_sometime<std::_Bind<std::_Mem_fn<void (pump_coro_t::*)(auto_drainer_t::lock_t)> (pump_coro_t*, auto_drainer_t::lock_t)> >(std::_Bind<std::_Mem_fn<void (pump_coro_t::*)(auto_drainer_t::lock_t)> (pump_coro_t*, auto_drainer_t::lock_t)>&&) at coroutines.hpp:58\n       27: pump_coro_t::notify() at pump_coro.cc:32\n       28: contract_coordinator_t::contract_coordinator_t(raft_member_t<table_raft_state_t>*, watchable_map_t<std::pair<uuid_u, uuid_u>, contract_ack_t>*, watchable_map_t<std::pair<uuid_u, uuid_u>, empty_value_t>*) at coordinator.cc:31\n       29: table_manager_t::leader_t::leader_t(table_manager_t*) at table_manager.cc:171\n       30: ../build/debug/rethinkdb() [0x1e68a42] at 0x1e68a42 ()\n       31: ../build/debug/rethinkdb() [0x1e7017e] at 0x1e7017e ()\n       32: callable_action_wrapper_t::run() at runtime_utils.cc:43\n       33: coro_t::run() at coroutines.cc:207\n       34: ../build/debug/rethinkdb() [0x1e6910b] at 0x1e6910b ()\n       35: table_manager_t::on_raft_readiness_change() at table_manager.cc:262\n       36: std::_Mem_fn<void (table_manager_t::*)()>::operator()(table_manager_t*) const at functional:551\n       37: void std::_Bind<std::_Mem_fn<void (table_manager_t::*)()> (table_manager_t*)>::__call<void, , 0>(std::tuple<>&&, std::_Index_tuple<0>) at functional:1147\n       38: void std::_Bind<std::_Mem_fn<void (table_manager_t::*)()> (table_manager_t*)>::operator()<, void>() at functional:1206\n       39: std::_Function_handler<void (), std::_Bind<std::_Mem_fn<void (table_manager_t::*)()> (table_manager_t*)> >::_M_invoke(std::_Any_data const&) at functional:1780\n       40: std::function<void ()>::operator()() const at functional:2162\n       41: call_function(std::function<void ()> const&) at watchable.hpp:185\n       42: void publisher_controller_t<std::function<void ()> >::publish<void (*)(std::function<void ()> const&)>(void (* const&)(std::function<void ()> const&)) at pubsub.hpp:139\n       43: watchable_variable_t<bool>::set_value(bool const&) at watchable.hpp:203\n       44: raft_member_t<table_raft_state_t>::update_readiness_for_change() at raft_core.tcc:1215\n       45: raft_member_t<table_raft_state_t>::candidate_and_leader_coro(new_mutex_acq_t*, auto_drainer_t::lock_t) at raft_core.tcc:1325\n       46: std::_Mem_fn<void (raft_member_t<table_raft_state_t>::*)(new_mutex_acq_t*, auto_drainer_t::lock_t)>::operator()(raft_member_t<table_raft_state_t>*, new_mutex_acq_t*, auto_drainer_t::lock_t) const at functional:551\n       47: void std::_Bind<std::_Mem_fn<void (raft_member_t<table_raft_state_t>::*)(new_mutex_acq_t*, auto_drainer_t::lock_t)> (raft_member_t<table_raft_state_t>*, new_mutex_acq_t*, auto_drainer_t::lock_t)>::__call<void, , 0, 1, 2>(std::tuple<>&&, std::_Index_tuple<0, 1, 2>) at functional:1146\n       48: void std::_Bind<std::_Mem_fn<void (raft_member_t<table_raft_state_t>::*)(new_mutex_acq_t*, auto_drainer_t::lock_t)> (raft_member_t<table_raft_state_t>*, new_mutex_acq_t*, auto_drainer_t::lock_t)>::operator()<, void>() at functional:1206\n       49: callable_action_instance_t<std::_Bind<std::_Mem_fn<void (raft_member_t<table_raft_state_t>::*)(new_mutex_acq_t*, auto_drainer_t::lock_t)> (raft_member_t<table_raft_state_t>*, new_mutex_acq_t*, auto_drainer_t::lock_t)> >::run_action() at callable_action.hpp:31\n       50: callable_action_wrapper_t::run() at runtime_utils.cc:43\n       51: coro_t::run() at coroutines.cc:207\n       52: coro_t* coro_t::spawn_sometime<std::_Bind<std::_Mem_fn<void (raft_member_t<table_raft_state_t>::*)(new_mutex_acq_t*, auto_drainer_t::lock_t)> (raft_member_t<table_raft_state_t>*, new_mutex_acq_t*, auto_drainer_t::lock_t)> >(std::_Bind<std::_Mem_fn<void (raft_member_t<table_raft_state_t>::*)(new_mutex_acq_t*, auto_drainer_t::lock_t)> (raft_member_t<table_raft_state_t>*, new_mutex_acq_t*, auto_drainer_t::lock_t)>&&) at coroutines.hpp:58\n       53: ../build/debug/rethinkdb() [0x1e6cbb0] at 0x1e6cbb0 ()\n       54: callable_action_instance_t<raft_member_t<table_raft_state_t>::on_watchdog()::{lambda()#1}>::run_action() at callable_action.hpp:31\n       55: callable_action_wrapper_t::run() at runtime_utils.cc:43\n       56: coro_t::run() at coroutines.cc:207\n       57: coro_t* coro_t::spawn_sometime<raft_member_t<table_raft_state_t>::on_watchdog()::{lambda()#1}>(raft_member_t<table_raft_state_t>::on_watchdog()::{lambda()#1}&&) at coroutines.hpp:58\n       58: raft_member_t<table_raft_state_t>::on_watchdog() at raft_core.tcc:1008\n       59: ../build/debug/rethinkdb() [0x1e6a17d] at 0x1e6a17d ()\n       60: std::_Function_handler<void (), raft_member_t<table_raft_state_t>::raft_member_t(raft_member_id_t const&, raft_storage_interface_t<table_raft_state_t>*, raft_network_interface_t<table_raft_state_t>*, std::string const&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) at functional:1780\n       61: std::function<void ()>::operator()() const at functional:2162\n       62: watchdog_timer_t::run(auto_drainer_t::lock_t) at watchdog_timer.cc:58\n       63: std::_Mem_fn<void (watchdog_timer_t::*)(auto_drainer_t::lock_t)>::operator()(watchdog_timer_t*, auto_drainer_t::lock_t) const at functional:551\n       64: void std::_Bind<std::_Mem_fn<void (watchdog_timer_t::*)(auto_drainer_t::lock_t)> (watchdog_timer_t*, auto_drainer_t::lock_t)>::__call<void, , 0, 1>(std::tuple<>&&, std::_Index_tuple<0, 1>) at functional:1146\n       65: void std::_Bind<std::_Mem_fn<void (watchdog_timer_t::*)(auto_drainer_t::lock_t)> (watchdog_timer_t*, auto_drainer_t::lock_t)>::operator()<, void>() at functional:1206\n       66: callable_action_instance_t<std::_Bind<std::_Mem_fn<void (watchdog_timer_t::*)(auto_drainer_t::lock_t)> (watchdog_timer_t*, auto_drainer_t::lock_t)> >::run_action() at callable_action.hpp:31\n       67: callable_action_wrapper_t::run() at runtime_utils.cc:43\n       68: coro_t::run() at coroutines.cc:207\n       69: coro_t* coro_t::spawn_sometime<std::_Bind<std::_Mem_fn<void (watchdog_timer_t::*)(auto_drainer_t::lock_t)> (watchdog_timer_t*, auto_drainer_t::lock_t)> >(std::_Bind<std::_Mem_fn<void (watchdog_timer_t::*)(auto_drainer_t::lock_t)> (watchdog_timer_t*, auto_drainer_t::lock_t)>&&) at coroutines.hpp:58\n       70: watchdog_timer_t::watchdog_timer_t(int, int, std::function<void ()> const&, watchdog_timer_t::state_t) at watchdog_timer.cc:32\n       71: raft_member_t<table_raft_state_t>::raft_member_t(raft_member_id_t const&, raft_storage_interface_t<table_raft_state_t>*, raft_network_interface_t<table_raft_state_t>*, std::string const&) at raft_core.tcc:98\n       72: raft_networked_member_t<table_raft_state_t>::raft_networked_member_t(raft_member_id_t const&, mailbox_manager_t*, watchable_map_t<raft_member_id_t, raft_business_card_t<table_raft_state_t> >*, raft_storage_interface_t<table_raft_state_t>*, std::string const&) at raft_network.tcc:24\n       73: table_manager_t::table_manager_t(uuid_u const&, mailbox_manager_t*, server_config_client_t*, watchable_map_t<std::pair<peer_id_t, uuid_u>, table_manager_bcard_t>*, backfill_throttler_t*, watchable_map_t<std::pair<uuid_u, uuid_u>, empty_value_t>*, base_path_t const&, io_backender_t*, uuid_u const&, multi_table_manager_timestamp_t::epoch_t const&, raft_member_id_t const&, raft_storage_interface_t<table_raft_state_t>*, multistore_ptr_t*, perfmon_collection_t*) at table_manager.cc:67\n       74: multi_table_manager_t::active_table_t::active_table_t(multi_table_manager_t*, multi_table_manager_t::table_t*, uuid_u const&, multi_table_manager_timestamp_t::epoch_t const&, raft_member_id_t const&, raft_storage_interface_t<table_raft_state_t>*, multistore_ptr_t*, perfmon_collection_t*) at multi_table_manager.cc:136\n       75: scoped_ptr_t<multi_table_manager_t::active_table_t> make_scoped<multi_table_manager_t::active_table_t, multi_table_manager_t*, multi_table_manager_t::table_t*&, uuid_u const&, multi_table_manager_timestamp_t::epoch_t const&, raft_member_id_t const&, raft_storage_interface_t<table_raft_state_t>*&, multistore_ptr_t*, perfmon_collection_t*>(multi_table_manager_t*&&, multi_table_manager_t::table_t*&, uuid_u const&, multi_table_manager_timestamp_t::epoch_t const&, raft_member_id_t const&, raft_storage_interface_t<table_raft_state_t>*&, multistore_ptr_t*&&, perfmon_collection_t*&&) at scoped.hpp:122\n       76: ../build/debug/rethinkdb() [0x1e3deff] at 0x1e3deff ()\n       77: ../build/debug/rethinkdb() [0x1e42fbb] at 0x1e42fbb ()\n       78: std::function<void (uuid_u const&, table_active_persistent_state_t const&, raft_storage_interface_t<table_raft_state_t>*, metadata_file_t::read_txn_t*)>::operator()(uuid_u const&, table_active_persistent_state_t const&, raft_storage_interface_t<table_raft_state_t>*, metadata_file_t::read_txn_t*) const at functional:2162\n       79: real_table_persistence_interface_t::read_all_metadata(std::function<void (uuid_u const&, table_active_persistent_state_t const&, raft_storage_interface_t<table_raft_state_t>*, metadata_file_t::read_txn_t*)> const&, std::function<void (uuid_u const&, table_inactive_persistent_state_t const&, metadata_file_t::read_txn_t*)> const&, signal_t*) at table_interface.cc:201\n       80: multi_table_manager_t::multi_table_manager_t(uuid_u const&, mailbox_manager_t*, server_config_client_t*, watchable_map_t<peer_id_t, multi_table_manager_bcard_t>*, watchable_map_t<std::pair<peer_id_t, uuid_u>, table_manager_bcard_t>*, watchable_map_t<std::pair<uuid_u, uuid_u>, empty_value_t>*, table_persistence_interface_t*, base_path_t const&, io_backender_t*, perfmon_collection_repo_t*) at multi_table_manager.cc:66\n       81: do_serve(io_backender_t*, bool, base_path_t const&, metadata_file_t*, serve_info_t const&, os_signal_cond_t*) at serve.cc:299\n       82: serve(io_backender_t*, base_path_t const&, metadata_file_t*, serve_info_t const&, os_signal_cond_t*) at serve.cc:640\n       83: run_rethinkdb_serve(base_path_t const&, serve_info_t*, file_direct_io_mode_t, int, boost::optional<boost::optional<unsigned long> > const&, uuid_u const*, server_config_versioned_t const*, cluster_semilattice_metadata_t const*, directory_lock_t*, bool*) at command_line.cc:807\n       84: run_rethinkdb_porcelain(base_path_t const&, name_string_t const&, std::set<name_string_t, std::less<name_string_t>, std::allocator<name_string_t> > const&, file_direct_io_mode_t, int, boost::optional<boost::optional<unsigned long> > const&, bool, serve_info_t*, directory_lock_t*, bool*) at command_line.cc:872\n       85: void std::_Bind<void (*(base_path_t, name_string_t, std::set<name_string_t, std::less<name_string_t>, std::allocator<name_string_t> >, file_direct_io_mode_t, int, boost::optional<boost::optional<unsigned long> >, bool, serve_info_t*, directory_lock_t*, bool*))(base_path_t const&, name_string_t const&, std::set<name_string_t, std::less<name_string_t>, std::allocator<name_string_t> > const&, file_direct_io_mode_t, int, boost::optional<boost::optional<unsigned long> > const&, bool, serve_info_t*, directory_lock_t*, bool*)>::__call<void, , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9>(std::tuple<>&&, std::_Index_tuple<0, 1, 2, 3, 4, 5, 6, 7, 8, 9>) at functional:1147\n       86: void std::_Bind<void (*(base_path_t, name_string_t, std::set<name_string_t, std::less<name_string_t>, std::allocator<name_string_t> >, file_direct_io_mode_t, int, boost::optional<boost::optional<unsigned long> >, bool, serve_info_t*, directory_lock_t*, bool*))(base_path_t const&, name_string_t const&, std::set<name_string_t, std::less<name_string_t>, std::allocator<name_string_t> > const&, file_direct_io_mode_t, int, boost::optional<boost::optional<unsigned long> > const&, bool, serve_info_t*, directory_lock_t*, bool*)>::operator()<, void>() at functional:1206\n       87: std::_Function_handler<void (), std::_Bind<void (*(base_path_t, name_string_t, std::set<name_string_t, std::less<name_string_t>, std::allocator<name_string_t> >, file_direct_io_mode_t, int, boost::optional<boost::optional<unsigned long> >, bool, serve_info_t*, directory_lock_t*, bool*))(base_path_t const&, name_string_t const&, std::set<name_string_t, std::less<name_string_t>, std::allocator<name_string_t> > const&, file_direct_io_mode_t, int, boost::optional<boost::optional<unsigned long> > const&, bool, serve_info_t*, directory_lock_t*, bool*)> >::_M_invoke(std::_Any_data const&) at functional:1780\n       88: std::function<void ()>::operator()() const at functional:2162\n       89: starter_t::run_wrapper(std::function<void ()> const&) at runtime.cc:61\n```\n"
  , issueState = "closed"
  , issueId = Id 101789013
  , issueComments = 2
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 505365
                , simpleUserLogin = N "danielmewes"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/505365?v=3"
                , simpleUserUrl = "https://api.github.com/users/danielmewes"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 0
          , milestoneNumber = 106
          , milestoneClosedIssues = 18
          , milestoneDescription = Just ""
          , milestoneTitle = "2.1.2"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/106"
          , milestoneCreatedAt = 2015 (-08) (-21) 22 : 34 : 48 UTC
          , milestoneState = "closed"
          }
  }