IssueComment
  { issueCommentUpdatedAt = 2013 (-11) (-06) 01 : 50 : 23 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/27833364"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1389#issuecomment-27833364"
  , issueCommentCreatedAt = 2013 (-11) (-06) 01 : 50 : 23 UTC
  , issueCommentBody =
      "Ok, with the mentioned regression out of the way, I managed to get a database file where a block is deleted as soon as I start the server and the very same block is accessed right afterwards.\r\n\r\nThe block is deleted here:\r\n```\r\n       5: mc_buf_lock_t::mark_deleted() at mirrored.cc:899\r\n       6: scc_buf_lock_t<mc_cache_t>::mark_deleted() at semantic_checking.tcc:60\r\n       7: blob_t::remove_level(scc_transaction_t<mc_cache_t>*, int*) at blob.cc:801\r\n       8: blob_t::unappend_region(scc_transaction_t<mc_cache_t>*, long) at blob.cc:462\r\n       9: blob_t::clear(scc_transaction_t<mc_cache_t>*) at blob.cc:504\r\n       10: kv_location_set(keyvalue_location_t<rdb_value_t>*, store_key_t const&, std::vector<char, std::allocator<char> > const&, btree_slice_t*, repli_timestamp_t, scc_transaction_t<mc_cache_t>*) at btree.cc:171\r\n       11: rdb_update_single_sindex(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t) at btree.cc:1117\r\n       12: void boost::_bi::list4<boost::_bi::value<btree_store_t<rdb_protocol_t>::sindex_access_t const*>, boost::_bi::value<rdb_modification_report_t const*>, boost::_bi::value<scc_transaction_t<mc_cache_t>*>, boost::_bi::value<auto_drainer_t::lock_t> >::operator()<void (*)(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t), boost::_bi::list0>(boost::_bi::type<void>, void (*&)(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t), boost::_bi::list0&, int) at bind.hpp:457\r\n       13: boost::_bi::bind_t<void, void (*)(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t), boost::_bi::list4<boost::_bi::value<btree_store_t<rdb_protocol_t>::sindex_access_t const*>, boost::_bi::value<rdb_modification_report_t const*>, boost::_bi::value<scc_transaction_t<mc_cache_t>*>, boost::_bi::value<auto_drainer_t::lock_t> > >::operator()() at bind_template.hpp:21\r\n       14: callable_action_instance_t<boost::_bi::bind_t<void, void (*)(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t), boost::_bi::list4<boost::_bi::value<btree_store_t<rdb_protocol_t>::sindex_access_t const*>, boost::_bi::value<rdb_modification_report_t const*>, boost::_bi::value<scc_transaction_t<mc_cache_t>*>, boost::_bi::value<auto_drainer_t::lock_t> > > >::run_action() at callable_action.hpp:28\r\n       15: callable_action_wrapper_t::run() at runtime_utils.cc:67\r\n       16: coro_t::run() at coroutines.cc:178\r\n```\r\n\r\nand subsequently accessed here:\r\n```\r\n       5: mc_buf_lock_t::mc_buf_lock_t(mc_transaction_t*, unsigned long, access_t, buffer_cache_order_mode_t, lock_in_line_callback_t*) at mirrored.cc:523\r\n       6: scc_buf_lock_t<mc_cache_t>::scc_buf_lock_t(scc_transaction_t<mc_cache_t>*, unsigned long, access_t, buffer_cache_order_mode_t, lock_in_line_callback_t*) at semantic_checking.tcc:145\r\n       7: blob_t::remove_level(scc_transaction_t<mc_cache_t>*, int*) at blob.cc:789\r\n       8: blob_t::unappend_region(scc_transaction_t<mc_cache_t>*, long) at blob.cc:462\r\n       9: blob_t::clear(scc_transaction_t<mc_cache_t>*) at blob.cc:504\r\n       10: kv_location_set(keyvalue_location_t<rdb_value_t>*, store_key_t const&, std::vector<char, std::allocator<char> > const&, btree_slice_t*, repli_timestamp_t, scc_transaction_t<mc_cache_t>*) at btree.cc:171\r\n       11: rdb_update_single_sindex(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t) at btree.cc:1117\r\n       12: void boost::_bi::list4<boost::_bi::value<btree_store_t<rdb_protocol_t>::sindex_access_t const*>, boost::_bi::value<rdb_modification_report_t const*>, boost::_bi::value<scc_transaction_t<mc_cache_t>*>, boost::_bi::value<auto_drainer_t::lock_t> >::operator()<void (*)(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t), boost::_bi::list0>(boost::_bi::type<void>, void (*&)(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t), boost::_bi::list0&, int) at bind.hpp:457\r\n       13: boost::_bi::bind_t<void, void (*)(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t), boost::_bi::list4<boost::_bi::value<btree_store_t<rdb_protocol_t>::sindex_access_t const*>, boost::_bi::value<rdb_modification_report_t const*>, boost::_bi::value<scc_transaction_t<mc_cache_t>*>, boost::_bi::value<auto_drainer_t::lock_t> > >::operator()() at bind_template.hpp:21\r\n       14: callable_action_instance_t<boost::_bi::bind_t<void, void (*)(btree_store_t<rdb_protocol_t>::sindex_access_t const*, rdb_modification_report_t const*, scc_transaction_t<mc_cache_t>*, auto_drainer_t::lock_t), boost::_bi::list4<boost::_bi::value<btree_store_t<rdb_protocol_t>::sindex_access_t const*>, boost::_bi::value<rdb_modification_report_t const*>, boost::_bi::value<scc_transaction_t<mc_cache_t>*>, boost::_bi::value<auto_drainer_t::lock_t> > > >::run_action() at callable_action.hpp:28\r\n       15: callable_action_wrapper_t::run() at runtime_utils.cc:67\r\n       16: coro_t::run() at coroutines.cc:178\r\n```\r\n\r\nNo new block with the same id is created in between.\r\n\r\nNow this could just be a side-effect of some data corruption having happened a while before this of course..."
  , issueCommentId = 27833364
  }