IssueComment
  { issueCommentUpdatedAt = 2015 (-02) (-03) 23 : 58 : 04 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/72763153"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3719#issuecomment-72763153"
  , issueCommentCreatedAt = 2015 (-02) (-03) 23 : 58 : 04 UTC
  , issueCommentBody =
      "This generally sounds like a good idea to me.\r\n\r\nAn open question is what exactly the changefeed should return when the data changes.\r\nAssuming an `orderBy(...).limit(...)` changefeed, it could have `old_val` and `new_val` be arrays with all the documents in the right order.\r\nIn that case we should probably send the initial values in the same format, that is as a single document `{new_val: [val1, val2, val3, ...]}`.\r\n\r\nI think for now the only query that this would work on is `orderBy.limit`?\r\nEven if we support `return_initial` for other multi-document changefeeds (like `r.table().changes()` or `r.table().between().changes()`) later, I don't think we could easily (let alone efficiently) support this opt arg for those types of changefeeds, could we?\r\nThis makes this solution seem a bit specific, and I wonder wonder if there's a more generic solution to the problem. Though I cannot think of any."
  , issueCommentId = 72763153
  }