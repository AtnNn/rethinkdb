Issue
  { issueClosedAt = Nothing
  , issueUpdatedAt = 2016 (-02) (-08) 21 : 06 : 59 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/1863/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/1863"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "0052cc"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:ReQL_proposal"
          , labelName = "tp:ReQL_proposal"
          }
      ]
  , issueNumber = 1863
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 297060
        , simpleUserLogin = N "nviennot"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/297060?v=3"
        , simpleUserUrl = "https://api.github.com/users/nviennot"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "2PC Mechanisms, r.eval() and r.rql() proposal"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/1863"
  , issueCreatedAt = 2014 (-01) (-14) 10 : 24 : 13 UTC
  , issueBody =
      Just
        "While we don't support any ACID transactions, it would still be desirable to support some easy ways to perform two phase commits.\n\nA simple example is to consider an game application with players. players are stored in a single table. Each player have a money attribute. I wish to implement a transfer money feature with the following requirements:\n- A player can send money to another player as long as his available balance remains positive.\n- After performing a money transfert of amount X, eventually the sender should have his balance decreased by X, and the receiver should gain X.\n\nThese requirements have to withstand any sort of application server crash, or network failure, or slow network, or slow application servers.\n\nIntuitively, we want to perform atomically:\n- Check if the balance of Sender is positive\n- If yes, decrement his balance, and increment the balance of Receiver.\n\nUsing a separate lock server like ZooKeeper would not work, because my application server could be arbitrarily slow or loose the connection with the lock server, so the app server could could lose the lock while performing the decrement/increment.\n\nOkay, so that leaves us with the atomic operations of rethinkdb.\n\nWe can decrement the balance so that the positive balance invariant is always respected, but then if the app server dies right after that, the Receiver account will never be incremented.\nWell, that's fixable, if we remember that we need to do an increment on the receiver account in a pending_sends set. Let's pick a some random xid to denote the money transaction id. So the update is now \"if balance > X, decrement balance by X, and add to pending_sends set the pair [xid, receiver_id, X]\". This way, if the app server dies, we remembered that we have to increment receiver_id's balance X amount of money. We still have the problem of having incrementing the receiver's account by X, and removing the xid from the sender's pending_sends array to prevent giving the receiver too much money. That's fixable too, we can add a pending_receives set on the receiver side, and add [xid, X] to the set. Once done, we can safely remove the xid from the pending_sends. And once done we can atomically increment the sender's account and remove the xid from his pending_receives.\n\nThat's pretty complicated. What happens if we want to do a transaction with N players, and what if we also want to create and delete documents along the way.\n\nWe need some ways to do a 2PC in an elegant manner. Considering only update operations does not lose generalization as creates/deletes operations can be emulated by shadowing documents on the app side with a \"visible\" attribute that gets updated.\n---\n\nIdeally, we want something like `r.transaction(write_opertions)` to enqueue all of our writes. If one of them cannot be performed, don't perform any of them. if they can all be performed, do them all. We obviously don't care about isolation (readers can see some of the writes already done, some not yet done).\n\nWith the players example we would do something like:\n\n``` ruby\nr.transaction(\n  r.table('players').get('sender_id').update { |doc|\n    r.branch(doc[:balance] > X,\n             doc[:balance] = doc[:balance] - X,\n             r.error('no enough money'))\n  },\n  r.table('players').get('receiver_id').update { |doc|\n    doc[:balance] = doc[:balance] + X\n  }\n)\n```\n\nWell, we can't have this, otherwise specifying an invariant \"doc[:balance] > X\" in both queries would necessitate to take a lock on the two documents which would be a bad idea.\n---\n\nWe could get away with it by providing `r.eval()` and `r.rql()` commands to let the application specify its mechanism:\n- `r.rql(rql_expr)` leaves the rql expression as is and doesn't evaluate it. It's just a wrapper for rql_expr.to_pb at the end of the day (but performed server side). For example:\n\n``` ruby\nr.table('players').get('sender_id').update(:todo =>\n  r.rql(r.table('players').get('receiver_id').update(:stuff => '123')))\n```\n\nThis would store the protobuf of the rql expression in the todo attribute (it's just a wrapper on `.to_pb`, but it's a bit nicer).\n- `r.eval(rql_expr)` runs the rql_expr on the server. For example:\n\n``` ruby\nr.table('players').get('sender_id').eval(:todo)\nr.do(r.table('players').get('sender_id')) { |doc| r.eval(doc[:todo]) }\n```\n\n`r.eval` would have security implications, so perhaps it's better to only allow eval on a special type. Similarly with how dates are stored with `$reql_type$`, we could to do the same with the type of `r.rql()`. It somewhat solves the problem if only the database can write this special type to documents (to avoid a user passing a fancy hash as a value with this rql type).\n\nHere is how it would work to do a 2pc:\n\n``` ruby\ndef prepare_2pc(doc_updates)\n  # doc_updates is a hash of rql selectors to rql updates.\n  # e.g. { r.table('player').get('123') => r.do(unbound) { |doc| doc[:money] = doc[:money] + 1 } }\n\n  # A transaction is identified with a xid.\n  xid = UUID.generate\n\n  # We saved all the document selectors involved in the 2pc first, because\n  # as soon as we write to the database, we need to be able to rollback\n  # the 2pc. This also gives us a table of transactions and the ability to\n  # rollback pending transactions. We save all the updates to be performed\n  # so we can commit the transaction later in time.\n  r.table('transactions').insert(\n    :id => xid,\n    :state => 'prepare',\n    :created_at => Time.now,\n    :doc_selectors => doc_updates.keys.map { |s| r.rql(s) },\n    :doc_updates => doc_updates.values.map { |s| r.rql(s) }\n  ).run\n\n  # Locking the documents in place, so concurrent transactions will fail.\n  # current_xid can be namespaced to allow different transactions that\n  # operates on different fields to occur. it could be current_balance_xid\n  # for example.\n  docs_selector.update { |doc|\n    r.branch(doc[:current_xid],\n             r.error('document is already in a transaction'),\n             { doc[:current_xid] => xid })\n  }.run\n\n  return xid\nrescue\n  # Some document might have been involved in a transaction, we are out.\n  rollback_2pc(xid)\n  return nil\nend\n\ndef rollback_2pc(xid)\n  r.table('transactions').get(xid).update { |transaction|\n    r.branch(transaction[:state].ne('commit'),\n             {:state => 'rollback'},\n             r.error(\"Cannot rollback, the transaction is committed\"))\n  }.run\n\n  # We remove all the current_xid from the documents to unlock them\n  r.do(r.table('transactions').get(xid)) { |transaction|\n    transaction[:doc_selectors].map { |selector|\n      r.eval(selector).update { |doc|\n        r.branch(doc[:current_xid].eq(xid),\n                 doc[:current_xid].update(:current_xid => nil),\n                 { })\n      }\n    }\n  }.run\n\n  # And we finally remove the transaction\n  r.table('transactions').get(xid).delete.run\nend\n\ndef commit_2pc(xid)\n  r.table('transactions').get(xid).update { |transaction|\n    r.branch(transaction[:state].ne('rollback'),\n             {:state => 'commit'},\n             r.error(\"Cannot commit, the transaction is rollbacked\"))\n  }.run\n\n  r.do(r.table('transactions').get(xid)) { |transaction|\n    {:left => transaction[:doc_selectors],\n     :right => transaction[:doc_updates]}.zip { |selector, update|\n      r.eval(selector).update { |doc|\n        r.branch(doc[:current_xid].eq(xid),        \n                r.expr([doc[:current_xid] = nil, r.eval(update, doc)]),\n                { })\n      }\n    }\n  }.run\n\n  r.table('transactions').get(xid).delete.run\nend\n```\n\n``` ruby\nxid = prepare_2pc(\n  r.table('player').get('sender_id')   => r.do(unbound) { |doc| doc[:money] = doc[:money] - X },\n  r.table('player').get('receiver_id') => r.do(unbound) { |doc| doc[:money] = doc[:money] + X }\n)\n\nif r.table('player').get('sender_id').run['money'] > X\n  commit_2pc(xid)\nelse\n  rollback_2pc(xid)\nend\n```\n---\n\nThere are some issue where we need to call `r.do(unbound) { |doc| ... }` to pass a lambda with an argument to the db that can be serialized. That's because we need to be able to call `r.eval(serialized_rql, the_bindings)` at some point.\n\nIn short, `r.eval()` is pure awesomeness, because now we are able to completely abstract the 2pc mechanism easily. As a sys admin, I can come in and list the transactions in progress in the transactions table. I can also always finish a transaction safely (by committing if the transaction was already committed, or by doing a rollback) (there is a small race when preparing the transaction, but that could be easily avoided with an additional state), and this without knowing what the actual commit operations were, because there are stored in the transaction object in RQL.\n\nNot that it would be impossible to call `.to_pb` manually, and parsing back the RQL putting some glue everywhere and recompiling it to some sane RQL, it feels much more natural to have it part RQL.\nThe 2pc implementation demonstrates the power of `r.eval()`, but I'm sure other use cases can leverage `r.eval()` to do interesting things.\n"
  , issueState = "open"
  , issueId = Id 25564559
  , issueComments = 9
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 48436
                , simpleUserLogin = N "coffeemug"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/48436?v=3"
                , simpleUserUrl = "https://api.github.com/users/coffeemug"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 882
          , milestoneNumber = 2
          , milestoneClosedIssues = 0
          , milestoneDescription =
              Just
                "Issues in this milestone are not an immediate priority, and will be periodically revisited. When we decide to work on an issue in backlog, we'll move it to next."
          , milestoneTitle = "backlog"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/2"
          , milestoneCreatedAt = 2012 (-11) (-11) 14 : 16 : 11 UTC
          , milestoneState = "open"
          }
  }