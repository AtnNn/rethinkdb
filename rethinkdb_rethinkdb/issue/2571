Issue
  { issueClosedAt = Just 2014 (-08) (-11) 21 : 56 : 05 UTC
  , issueUpdatedAt = 2014 (-11) (-20) 19 : 34 : 15 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/2571/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/2571"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "007575"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:API_settled"
          , labelName = "tp:API_settled"
          }
      , IssueLabel
          { labelColor = "0052cc"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/tp:ReQL_proposal"
          , labelName = "tp:ReQL_proposal"
          }
      ]
  , issueNumber = 2571
  , issueAssignee =
      Just
        SimpleUser
          { simpleUserId = Id 505365
          , simpleUserLogin = N "danielmewes"
          , simpleUserAvatarUrl =
              "https://avatars.githubusercontent.com/u/505365?v=3"
          , simpleUserUrl = "https://api.github.com/users/danielmewes"
          , simpleUserType = OwnerUser
          }
  , issueUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "ReQL proposal: Geospatial support"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/2571"
  , issueCreatedAt = 2014 (-06) (-19) 00 : 41 : 24 UTC
  , issueBody =
      Just
        "#### Edit: Note the updated proposal below https://github.com/rethinkdb/rethinkdb/issues/2571#issuecomment-47298184\n\nIn contrast to #1158, I would like to use this issue solely to track the ReQL API side of things.\n\nThis proposal is limited to two-dimensional geodesic geometry (geometry on the earth's surface). We can add support for Euclidean geometry later if necessary.\n#### Geospatial data representation\n- Support at least Points, LineStrings and Polygons compatible to GeoJSON ([Wikipedia](http://en.wikipedia.org/wiki/GeoJSON), [full specs](http://geojson.org/geojson-spec.html) ). I think MultiPoint, MultiLineString and MultiPolygon are less important. Once we add them we could support operations such as addition (union) and subtraction on geometry, but I'm going to skip them for now.\n- Define a new ReQL geometry pseudo-type\n- Provide two functions to convert from/to GeoJSON:\n  - `r.geoJSON(object) : object -> geometry` converts from the GeoJSON object `object` to the geometry pseudo type\n  - `r.geoJSON(string) : string -> geometry` (optional): equivalent to `r.geoJSON(r.json(string))`\n  - `geometry.toGeoJSON() : geometry -> object` does the opposite of `r.geoJSON(object)`\n- Provide constructors:\n  - `r.geoPoint(x, y) : float, float -> geometry`\n  - `r.geoLine(p1, p2, ...) : geometry, geometry, ... -> geometry` where the input arguments must be points\n  - `r.geoLine([x1, y1], [x2, y2], ...) : [float, float], [float, float], ... -> geometry`\n  - `r.geoPolygon(p1, p2, ...) : geometry, geometry, ... -> geometry` where the input arguments must be points\n  - `r.geoPolygon([x1, y1], [x2, y2], ...) : [float, float], [float, float], ... -> geometry`\n  - `polygon1.sub(polygon2) : geometry, geometry -> geometry` subtracts polygon2 from polygon1. For now, we should make the following requirement: polygon2 must be completely inside of polygon1. This allows to construct polygons with holes in them.\n  - For convenience: `r.geoCircle(center, radius) : geometry, float -> geometry`, `r.geoRectangle(bottomLeft, upperRight) : geometry, geometry -> geometry` create a line describing the corresponding shape. Can be combined with `fill()` (see Misc) to get spheres / filled rectangles.\n#### Creating a geospatial index\n- Any secondary index can store geospatial data. There is no distinction between geospatial and other indexes. If we index field `a` of a table, some documents in the table can have geometry in `a` and others can have strings, numbers or whatever.\n- We can later add special opt args to `indexCreate()` when we want to support different types of geometry.\n- (Internally geometry objects will probably be indexed similar to arrays in a multi index, where e.g. a polygon is \"expanded\" to a set of grid cells that it intersects with. We will probably want to limit the number of how many geometry objects can be stored in a composite index. Otherwise if for example we expand each polygon to ~10 grid cells, insert a document into a composite index that has three polygons as the composite index keys, we would end up with 10^3 index entries. Will have to determine later how we fail in such cases.)\n#### Misc\n- `p1.distance(p2) : geometry, geometry -> float` computes the minimal geodesic distance between points p1 and p2. Let's ignore distances to/between polygons and lines for now. Other geometries can be supported through opt args later.\n- `l.fill() : geometry -> geometry` Takes a line, makes it the outline of a polygon. The line has to be closed (and possibly must not intersect with itself, not sure about that yet).\n- `geometry.isContained(polygon) : geometry, geometry -> bool` tests whether geometry is completely contained in polygon\n- `geometry1.intersects(geometry2) : geometry, geometry -> bool` tests whether geometry1 and geometry2 intersect\n- Bonus: `set1.isContained(set2) : array, array -> bool` `isContained()` for two arrays. Tests whether all elements of set1 are found in set2.\n- Bonus: `set1.intersects(set2) : array, array -> bool` `intersects()` for two arrays.\n#### Querying\n- Ideally, we would provide a predicate function to `table.getAll()` such as `table.getAll(function (x) { return x('position').isContained(polygon); } )` or `table.getAll(function (x) { return x('position').distance(center).le(5.0); } )` and have an optimizer automatically make use of an index. However to avoid having to analyze the function, I propose introducing simplified predicates for getAll that can use secondary indexes (comparable to `r.desc()` and `r.asc()` for `orderBy()`):\n  - `table.getAll(geometry, {index: ...})`\n  - `table.getAll(r.intersects(polygon), {index: ...})`\n  - `table.getAll(r.isContained(polygon), {index: ...})`\n  - `table.getAll(r.withinDistance(center, radius), {index: ...})` (sugar for `r.intersects(r.geoCircle(center, radius).fill())`, except that we might want to restrict it to points)\n  - Bonus: `table.getAll(r.isBetween(left, right))` as an alternative to `r.between()`\n- The predicates can also be combined for querying composite indexes: `table.getAll([pred1, pred2, ...])`. Note that such a query wouldn't always be efficient, and might have to rely heavily on post-filtering (or alternatively trigger a lot of smaller index lookups). Consider the example of `table.getAll([r.isBetween(-inf, +inf), \"foo\"])` to see why this is the case. Not sure if we want to support this for the first version.\n- I would prefer restricting the previous composite query to having a non-equality predicate only as the final entry in the array. E.g. `table.getAll([\"foo\", r.isBetween(-inf, +inf)])` would be legal, while the previously mentioned `table.getAll([r.isBetween(-inf, +inf), \"foo\"])` would not be allowed. Such queries would always be efficient, and much easier to implement.\n- `r.orderBy(r.distance(p), {index: ...})` (note that this is a single-argument `p.distance()` variant)\n#### Open questions:\n- Can we support querying by whether an entry in the index contains a given query geometry, rather than the other way around? Something like `table.getAll(r.contains(geometry))`?\n- Should we prefix _all_ geo operations by `geo`? E.g. should we call `intersects()` `geoIntersects()` instead? This has the advantage that we can provide a reversed variant of `isContained()` called `geoContains()` without clashing with the existing `object.contains(fieldNames)` term.\n- For the first implementation, we might want to skip support for composite geospatial indexes altogether. I think it would be immensely useful though, and we should support it soon.\n"
  , issueState = "closed"
  , issueId = Id 36040887
  , issueComments = 145
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 1777134
                , simpleUserLogin = N "mlucy"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/1777134?v=3"
                , simpleUserUrl = "https://api.github.com/users/mlucy"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 0
          , milestoneNumber = 76
          , milestoneClosedIssues = 60
          , milestoneDescription = Just ""
          , milestoneTitle = "1.15"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/76"
          , milestoneCreatedAt = 2014 (-07) (-30) 21 : 42 : 02 UTC
          , milestoneState = "closed"
          }
  }