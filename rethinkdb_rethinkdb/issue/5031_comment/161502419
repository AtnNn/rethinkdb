IssueComment
  { issueCommentUpdatedAt = 2015 (-12) (-03) 03 : 05 : 45 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1461947
        , simpleUserLogin = N "neumino"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1461947?v=3"
        , simpleUserUrl = "https://api.github.com/users/neumino"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/161502419"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5031#issuecomment-161502419"
  , issueCommentCreatedAt = 2015 (-12) (-03) 03 : 05 : 30 UTC
  , issueCommentBody =
      "Hum, I don't think observables are that perfect for the drivers. You typically have to close your connection when you are done with a cursor. Meaning that all the examples returning a cursor end up becoming something like:\r\n\r\n```\r\nr.connect({}).then(function(connection) {\r\n  query().run().subscribe({\r\n    function next(row) { console.log(row) },\r\n    function error(err) { console.log(err) },\r\n    function complete() { connection.close() }\r\n  })\r\n})\r\n```\r\nWhen `next` is biggish, it makes a ugly-ish syntax.\r\n\r\nYou may not need the complete method if you return one unique value, but that means people need to know if the query returns an array or a cursor.\r\n\r\nUsing streams seems more appropriate to me, and in this case you get the benefit of not having to handle errors in multiple places and you can just pipe them in your sockjs/socket.io connections.\r\n\r\n```\r\nquery.toStream().pipe(socketio).error(function(err) {\r\n  // handle all errors\r\n});\r\n```"
  , issueCommentId = 161502419
  }