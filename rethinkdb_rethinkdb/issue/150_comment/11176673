IssueComment
  { issueCommentUpdatedAt = 2012 (-12) (-09) 22 : 00 : 30 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 646357
        , simpleUserLogin = N "wmrowan"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/646357?v=3"
        , simpleUserUrl = "https://api.github.com/users/wmrowan"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/11176673"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/150#issuecomment-11176673"
  , issueCommentCreatedAt = 2012 (-12) (-09) 21 : 58 : 29 UTC
  , issueCommentBody =
      "This shouldn't be too hard to support. I think we can do it by reserving a special symbol value for the current row (say symbol 0 and then begin counting for other symbols at 1) to which `r.row` is bound. Any time the function constructor gets a bare RQL value (and not a python lambda function) it can wrap it in a function that binds its first argument to symbol 0. This wouldn't require any support on the server.\r\n\r\nOf course, there is still the problem of nesting operations that use the `row` variable but of course we've always had this problem. In the case that the user does do this nesting, they would expect the `row` variable to be shadowed in the nested expression. I don't know how RQL variables are handled on the server but this should be the behavior when symbol names are reused anyway and thus the user will get the expected behavior."
  , issueCommentId = 11176673
  }