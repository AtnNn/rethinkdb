IssueComment
  { issueCommentUpdatedAt = 2016 (-08) (-26) 20 : 09 : 41 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/242838521"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/6075#issuecomment-242838521"
  , issueCommentCreatedAt = 2016 (-08) (-26) 20 : 09 : 41 UTC
  , issueCommentBody =
      "> Another thing is in rethink, is there any strong guarantee like JVM's \"happens-before\" rules that promises the event order will be held from the perspective of all threads, in this case, all reads from different clients.\r\n\r\nThere is not. The only ordering guarantee that you have is that after a write has been acknowledged, any subsequent operation issued against the database will see the effect of that write.\r\nHowever it might also see the effects of a write that has not been acknowledged yet. This also doesn't do anything for operations that have been started before a write was acknowledged, as is the case with the read cursor in your use case."
  , issueCommentId = 242838521
  }