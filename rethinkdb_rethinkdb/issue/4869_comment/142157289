IssueComment
  { issueCommentUpdatedAt = 2015 (-09) (-22) 01 : 49 : 22 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 201442
        , simpleUserLogin = N "Wardrop"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/201442?v=3"
        , simpleUserUrl = "https://api.github.com/users/Wardrop"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/142157289"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4869#issuecomment-142157289"
  , issueCommentCreatedAt = 2015 (-09) (-22) 01 : 49 : 22 UTC
  , issueCommentBody =
      "Thanks for the explanation. I'm only new to RethinkDB so I can only assume there's all sorts of considerations that have gone into the unusual driver design. I wasn't aware of the ability to use two RQL instances as part of a single query like that either. \r\n\r\nAt the moment, what I'm thinking of doing in my application is having an object instance that contains a reference to a RethinkDB connection. This object would contain a `run` method that takes a block, like so...\r\n\r\n``` ruby\r\npeople.run { |x| x.limit(2) } #=> [{...}, {...}]\r\n```\r\n\r\nSomething else I toyed with was creating a sub-class of RQL, which would allow me to change the default connection of that sub-class without affecting the global RQL class, but this doesn't work. I believe that's because class variables aren't resolved dynamically, and hence if the method that references the class variable is defined in the parent class, it would like at the class variable of the parent."
  , issueCommentId = 142157289
  }