IssueComment
  { issueCommentUpdatedAt = 2015 (-08) (-28) 17 : 30 : 27 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/135839821"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4669#issuecomment-135839821"
  , issueCommentCreatedAt = 2015 (-08) (-28) 17 : 30 : 27 UTC
  , issueCommentBody =
      "I really don't think the cost of adding a new exception type is that high, and the distinction seems important to me.\r\n\r\nI also disagree that exception types only exist to allow for programmatic handling of different errors: types are for humans as well as machines.  But even if we accepted that premise, there are probably about as many reasons to distinguish ReQL driver errors from ReQL server errors as there are to distinguish ReQL compilation errors from ReQL runtime errors.  For example, you may want to log them at different priority levels, or send an email to your DBAs for one class of error or to whoever maintains your app deployment for the other (since one class of error can be caused by RethinkDB being out of date and the other can be caused by your driver being out of date).  For another example, you may be generating queries based on user input, where compilation errors on the server can be caused by the user making a mistake but driver errors (like misuse of infix operators) can only be caused by your program being wrong.  (Assuming we change things so that arity errors aren't detected by the client.)"
  , issueCommentId = 135839821
  }