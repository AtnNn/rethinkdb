IssueComment
  { issueCommentUpdatedAt = 2015 (-08) (-28) 18 : 23 : 59 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1366
        , simpleUserLogin = N "deontologician"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1366?v=3"
        , simpleUserUrl = "https://api.github.com/users/deontologician"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/135853248"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4669#issuecomment-135853248"
  , issueCommentCreatedAt = 2015 (-08) (-28) 18 : 23 : 08 UTC
  , issueCommentBody =
      "Of your suggested use-cases above, which of those can't be used to justify the creation of *any* new exception class? For example, splitting `ArityError` from `NullLambdaReturnValue`?\r\n\r\nI'm not saying no one will ever need these distinctions, but the classes should be along the lines of things people commonly want distinguished programmatically. I think a good way of determining what these cases are is to wait for people to ask to distinguish them, rather than speculate beforehand, adding complexity to the protocol in the process (albeit a small amount).\r\n\r\nGiven that compilation errors are going to mostly be encountered during initial coding of the app, not as much during running it, I don't think they warrant this level of granularity."
  , issueCommentId = 135853248
  }