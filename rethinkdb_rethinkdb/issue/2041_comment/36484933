IssueComment
  { issueCommentUpdatedAt = 2014 (-03) (-03) 06 : 37 : 39 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 139396
        , simpleUserLogin = N "wojons"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/139396?v=3"
        , simpleUserUrl = "https://api.github.com/users/wojons"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/36484933"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2041#issuecomment-36484933"
  , issueCommentCreatedAt = 2014 (-03) (-03) 06 : 37 : 39 UTC
  , issueCommentBody =
      "@danielmewes yeah the idea behind this is that you can then take this symlink system and then wrap it into a view system that would than in return \"resolve\" the symlinks. By default if you call the symlink doc it wont return the data on the other table. If you then have a r.resolve() function it would resolve all links, you can pass a function or an array to tell it which to resolve the way i have my php code setup for it i can also do skips and limits if its is a list o docs being resolved in a single doc. Now if you have views you can apply a full query for mega filtering and then you can have the resolve written inside the view. Which would make people querying the view be able to easily access the data. Finally you add a cache to views so that it does not always have to re-resolve assuming there is cache also mains \"useoutofdate\" stuff but again can give great perfomance great flexablity and amazing ness. Also to allow indexing on view i know that sounds werid but its could be done.\r\n\r\nIf this is done all views would need to be \"async\" in the sense that when docs get written its not pushed to the view right away"
  , issueCommentId = 36484933
  }