IssueComment
  { issueCommentUpdatedAt = 2015 (-09) (-17) 05 : 36 : 49 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 690517
        , simpleUserLogin = N "mike-marcacci"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/690517?v=3"
        , simpleUserUrl = "https://api.github.com/users/mike-marcacci"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/139689354"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4598#issuecomment-139689354"
  , issueCommentCreatedAt = 2015 (-09) (-11) 23 : 52 : 58 UTC
  , issueCommentBody =
      "Hey there, I've been trying to think through this for some time, and have discovered that getting the RQL semantics right for transactions is extremely difficult, even when ignoring the actual implementation details. In particular, RQL (and all functional languages) are built for parallism, and have rather poor ergonomics when dealing with sequence. I'm going to just record some of my thoughts here to get the conversation moving, and possibly save somebody else the trouble of getting at least this far.\r\n\r\nTo start off, I'll make one assumption: **rethinkdb transactions should be confined to a single query**. Because RQL is so expressive, I don't think we need to take on the complexity of SQL's multi-query, connection-scoped transaction model. The SQL model would put cluster performance at the mercy of whatever else happens in the app during the transaction, and it would be difficult to implement on multiplexed rethinkdb connections. Furthermore, distributed locks are so easy for an application to implement these days (I had [node-redlock](https://github.com/mike-marcacci/node-redlock) in production the same day I started it) that rethinkdb can focus on query atomicity instead of worrying about application-level concurrency tools.\r\n\r\nMy following examples can be assumed to begin with:\r\n\r\n```js\r\n'use strict';\r\n\r\nvar sender_id   = 'mike';\r\nvar receiver_id = 'james';\r\nvar amount      = 500.00;\r\n\r\n// ...\r\n```\r\n\r\n\r\n\r\n\r\nTransactions Wrappers\r\n---------------------\r\nThis is probably what most people think about when coming from the SQL world, where a set of update requests are wrapped in a \"transaction\" block:\r\n\r\n```js\r\nr.transaction(function(tx) {\r\n\tvar sender   = r.table('accounts').get(sender_id);\r\n\tvar receiver = r.table('accounts').get(receiver_id);\r\n\r\n\treturn r.table('transfers').insert({\r\n\t\tsender_id: sender_id,\r\n\t\treceiver_id: receiver_id,\r\n\t\tamount: amount\r\n\t})\r\n\t.do(function(transfer) {\r\n\t\t// ...sub amount from sender\r\n\t\t// ...add amount to receiver\r\n\r\n\t\t// update the transfer?\r\n\t})\r\n\r\n});\r\n```\r\n\r\n### Problem: Ambiguity\r\nThis looks really simple at first, but quickly breaks down as you realize that the variables `sender` and `receiver` are stateless queries, not the tables themselves. Under MVCC, it's unclear what happens in the following scenario:\r\n\r\n1. get the sender (state A)\r\n2. update the sender (state B)\r\n3. reference the sender object <-- does this return state A or B?\r\n\r\nBecause the transaction has not been committed, an argument can be made for serving state A; because you're inside the same transaction, an equally valid argument can be made for serving state B.\r\n\r\n\r\n### Problem: Multiple Writes\r\nIt's unclear if the transfer object could be updated after it is inserted.\r\n\r\n\r\n\r\nExplicit Locks\r\n--------------\r\nThis feels much more clean to me, and alleviates some of the ambiguity of Problem #1: just like `.update()` RQL function, the returned tables are atomic records, not queries. In the following example, it's clear that `last_sender_balance` will use the starting balance of the sender.\r\n\r\n```js\r\nr.lock(r.table('accounts').get(sender_id), r.table('accounts').get(receiver_id), function(sender, receiver) {\r\n\treturn {\r\n\t\tsender: sender.update({ balance: sender('balance').sub(amount) }),\r\n\t\treceiver: receiver.update({\r\n\t\t\tbalance: receiver('balance').add(amount),\r\n\t\t\tlast_sender_balance: sender('balance')    // <-- this will be the starting balance\r\n\t\t})\r\n\t};\r\n});\r\n```\r\n\r\n### Problem: Write Order\r\nBoth models allow for something like this:\r\n\r\n```js\r\nr.lock(r.table('accounts').get(sender_id), r.table('accounts').get(receiver_id), function(sender, receiver) {\r\n\treturn {\r\n\t\tsender_tx_one: sender.update({ balance: 10 }),\r\n\t\tsender_tx_two: sender.update({ balance: 5 })\r\n\t};\r\n});\r\n```\r\n\r\nWill the sender's balance be 10 or 5? Because there is no key order guarantee to JSON, there is no consistent answer. While this example doesn't make any sense, this situation is bound to be encountered. This could probably be detected, and an error thrown.\r\n\r\n\r\n\r\nAborting, Recovering & Nesting\r\n------------------------------\r\nRegardless of the transaction creation syntax, we will need a way to \"rollback\" or \"abort\" the current transaction. Because rethinkdb is so flexible, there will innevitably be requests to detect aborted transactions, and this could open the door to nested locks (if that's even theoretically possible, not sure yet).\r\n\r\n### r.attempt\r\nExpanding on `r.branch` for transactions:\r\n\r\n```js\r\nr.attempt(\r\n\tr.transaction(function() {\r\n\t\t//...\r\n\t}),\r\n\tfunction(result) { return 'it succeeded'; },\r\n\tfunction(error) { return 'it failed'; }\r\n);\r\n```\r\n\r\n\r\n### .catch\r\nPerhaps a more generic form of `.default` could work here:\r\n\r\n```js\r\n\tr.lock(r.table('accounts').get(sender_id), r.table('accounts').get(receiver_id), function(sender, receiver) {\r\n\t\t//...\r\n\t}).catch(function(error) {\r\n\t\treturn 'it failed';\r\n\t})\r\n```\r\n\r\n-----\r\n\r\nAfter many hours thinking this through, I'm still pretty much undecided at every level. I think that the biggest challenge here is designing the language to be intuitive and consistent, and I think understanding everybody's use cases is the place to start. RQL is so versatile that it risks becoming very general purpose... which may or may not be a good thing.\r\n"
  , issueCommentId = 139689354
  }