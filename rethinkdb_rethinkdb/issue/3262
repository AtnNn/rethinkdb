Issue
  { issueClosedAt = Just 2015 (-04) (-20) 18 : 04 : 17 UTC
  , issueUpdatedAt = 2015 (-04) (-20) 18 : 04 : 17 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/3262/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/3262"
  , issueClosedBy = Nothing
  , issueLabels = []
  , issueNumber = 3262
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueTitle =
      "Consider making \"permanently remove\" not permanent"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/3262"
  , issueCreatedAt = 2014 (-10) (-30) 04 : 12 : 21 UTC
  , issueBody =
      Just
        "One of the worst problems with the UI for permanently removing servers is that it's irreversible. What if we instead made it reversible? If the server reconnects to the cluster, it simply declares itself alive again. If the server is carrying some data, the data becomes accessible again. \"Server ghost\" issues would cease to exist.\n\nCurrently we declare servers dead by replacing their metadata entry with a tombstone. Instead, we would have a `versioned_t<bool> alive` in their metadata entry; if the server ever saw this was set to `false`, it would flip it to `true` again.\n\nOne disadvantage of this is that it would make data divergence possible. If the user declares a server dead, then they will be able to issue writes without it; if it later comes back, there will be two divergent versions of the data in existence. We would need to design the `reactor_t` to handle this. I propose the following solution: If a server is in the `reactor_be_nothing()` state; it sees a divergent version of the data; the divergent version is on a server that the blueprint lists as a primary or replica; and it sees that the server is not transitioning to the `reactor_be_nothing()` state; then it deletes its own data. In practice this means that if a server reconnects, it will usually delete its own data.\n\nIf there are two divergent versions of the data and either both servers or neither server are listed as replicas in the config, then the system will deadlock. The user would have to resolve the deadlock by changing the configuration so that it contained servers from one side of the deadlock but not the other. We would show the user an issue, but it would be tricky to make it comprehensible.\n\nThis is probably a week or two of work. @coffeemug, do you think the usability benefits make it worth doing this before we ship `reql_admin`?\n"
  , issueState = "closed"
  , issueId = Id 47231833
  , issueComments = 4
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 316661
                , simpleUserLogin = N "timmaxw"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/316661?v=3"
                , simpleUserUrl = "https://api.github.com/users/timmaxw"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 0
          , milestoneNumber = 95
          , milestoneClosedIssues = 217
          , milestoneDescription =
              Just "To-do list before shipping auto-failover"
          , milestoneTitle = "2.1"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/95"
          , milestoneCreatedAt = 2015 (-03) (-04) 21 : 09 : 42 UTC
          , milestoneState = "closed"
          }
  }