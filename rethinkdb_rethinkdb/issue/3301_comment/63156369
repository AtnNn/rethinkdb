IssueComment
  { issueCommentUpdatedAt = 2014 (-11) (-15) 02 : 24 : 11 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 17789
        , simpleUserLogin = N "gchpaco"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/17789?v=3"
        , simpleUserUrl = "https://api.github.com/users/gchpaco"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/63156369"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3301#issuecomment-63156369"
  , issueCommentCreatedAt = 2014 (-11) (-15) 02 : 23 : 59 UTC
  , issueCommentBody =
      "@VeXocide points out that the ECMA standard for JSON is online as [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf) and a competing standard is [RFC-7159](http://tools.ietf.org/html/rfc7159).  ECMA-404 defines the language on Unicode code points, specifically on ISO 10646:2012,  RFC-7159 defines the language on hexadecimal bit patterns, which happen to correspond to UTF-8 (and, as it happens, only UTF-8).  Both standards otherwise agree, save the following bit of madness from ECMA-404:\r\n> To escape a code point that is not in the Basic Multilingual Plane, the character is represented as a twelve- character sequence, encoding the UTF-16 surrogate pair. So for example, a string containing only the G clef character (U+1D11E) may be represented as \"\\uD834\\uDD1E\".\r\n\r\nWhich is to be frank, horrible, but that's life.\r\n\r\nRFC-7159 specifies the following as far as character encoding, after having defined everything with hex digits.\r\n> JSON text SHALL be encoded in UTF-8, UTF-16, or UTF-32.  The default encoding is UTF-8, and JSON texts that are encoded in UTF-8 are interoperable in the sense that they will be read successfully by the maximum number of implementations; there are many implementations that cannot successfully read texts in other encodings (such as UTF-16 and UTF-32).\r\n> Implementations MUST NOT add a byte order mark to the beginning of a JSON text.  In the interests of interoperability, implementations that parse JSON texts MAY ignore the presence of a byte order mark rather than treating it as an error.\r\n\r\nI interpret this as an implicit acceptance of UTF-8 as the required standard; we *may* be able to support UTF-16 or UTF-32 if we go crazy, but UTF-8 is the only required one, and thus the only one I suggest we bother with."
  , issueCommentId = 63156369
  }