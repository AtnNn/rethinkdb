IssueComment
  { issueCommentUpdatedAt = 2014 (-11) (-18) 04 : 14 : 13 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 706854
        , simpleUserLogin = N "AtnNn"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/706854?v=3"
        , simpleUserUrl = "https://api.github.com/users/AtnNn"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/63420394"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3301#issuecomment-63420394"
  , issueCommentCreatedAt = 2014 (-11) (-18) 04 : 14 : 13 UTC
  , issueCommentBody =
      "> We should never emit denormalized strings and we should always normalize strings on input\r\n\r\nI'm not convinced we should do this.\r\n\r\n1. It would mean users would get out data that was different than the one they put in. This behaviour might be appropriate in other libraries or applications, but I think it is questionable whether a database should be modifying the data stored into it. As far as I can tell, most other databases do not normalize Unicode strings.\r\n\r\n2. OS X's file system normalizes file names to NFD. This has caused bugs in [bzr](https://bugs.launchpad.net/bzr/+bug/172383), [bash](http://lists.gnu.org/archive/html/bug-bash/2008-06/msg00035.html), [python](http://bugs.python.org/issue10209) and other projects.\r\n\r\n3. In all languages we have drivers for, canonical-equivalent character sequences are not considered equal. [Here are some examples](https://gist.github.com/AtnNn/e4c520e519de31580c0e). It would be very difficult for users writing applications in these languages to correctly handle non-normalised strings.\r\n\r\nHowever\r\n\r\n1. This is already the case for numbers, which get rounded to the nearest double\r\n\r\n2. If we had comprehensive Unicode support we could help users avoid a different category of bugs.\r\n\r\n3. The Unicode standard allows rewriting Unicode strings to other canonical-equivalent representations and says applications should not rely on canonical-equivalent strings being treated as distinct by other libraries."
  , issueCommentId = 63420394
  }