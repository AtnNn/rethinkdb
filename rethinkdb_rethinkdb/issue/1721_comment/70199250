IssueComment
  { issueCommentUpdatedAt = 2015 (-01) (-16) 02 : 23 : 58 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 48436
        , simpleUserLogin = N "coffeemug"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/48436?v=3"
        , simpleUserUrl = "https://api.github.com/users/coffeemug"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/70199250"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1721#issuecomment-70199250"
  , issueCommentCreatedAt = 2015 (-01) (-16) 02 : 23 : 58 UTC
  , issueCommentBody =
      "> Since JS is by far the largest language to implement something like `undefined` (and also a language that a lot of our users are familiar with), I would lean toward mimicking its behavior for `undefined` even if there was another one that was obviously better.\r\n\r\nThere is also SQL, which is about as big, and arguably more relevant. I think we should consider closely mimicking SQL's semantics for non-existence, unless there is a compelling reason not to.\r\n\r\n> However this leads to `branch(~unknown, x, y) => y`.\r\n\r\nIncidentally, SQL and JavaScript treat this differently. In SQL:\r\n\r\n```sql\r\nSELECT CASE WHEN NULL THEN 1 ELSE 2 END;\r\n2\r\n\r\nSELECT CASE WHEN NOT NULL THEN 1 ELSE 2 END;\r\n2\r\n```\r\n\r\nIn JavaScript:\r\n\r\n```js\r\nif (undefined) {console.log(1)} else {console.log(2)}\r\n2\r\n\r\nif (!undefined) {console.log(1)} else {console.log(2)}\r\n1\r\n```\r\n\r\nIt's very unclear to me which semantics are the most convenient for the user :disappointed: "
  , issueCommentId = 70199250
  }