IssueComment
  { issueCommentUpdatedAt = 2013 (-07) (-03) 23 : 14 : 33 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 78930
        , simpleUserLogin = N "apendleton"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/78930?v=3"
        , simpleUserUrl = "https://api.github.com/users/apendleton"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/20450959"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1118#issuecomment-20450959"
  , issueCommentCreatedAt = 2013 (-07) (-03) 23 : 14 : 33 UTC
  , issueCommentBody =
      "@jdoliner yeah, that all sounds awesome.  We have a currently-Postgres database that I think I want to eventually replace with something-not-Postgres TBD, and we build aggregates on a whole bunch of tables that are very expensive to compute, and currently recompute everything from scratch on updates (additions, deletions, and changes of records).  There's occasionally inter-table stuff, but 90% or more is probably single-table, and if we could change records and get new aggregates without recomputing everything from scratch, that would be a huge boon.  I think you're absolutely right, too, that that use case is probably much more common than a complicated multi-table MR situation, and that in the interest of 80%-20% solutions, getting the single-table case out the door early would be totally worthwhile."
  , issueCommentId = 20450959
  }