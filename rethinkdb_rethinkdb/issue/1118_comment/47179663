IssueComment
  { issueCommentUpdatedAt = 2014 (-06) (-26) 01 : 44 : 51 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47179663"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1118#issuecomment-47179663"
  , issueCommentCreatedAt = 2014 (-06) (-26) 01 : 44 : 51 UTC
  , issueCommentBody =
      "> For filters, when do documents enter the change feed? When only the new value passes the filter, only the old value, both, or either?\r\n\r\nIf the old value doesn't match the filter and the new value does, `old_val` is `nil` and `new_val` is the new value.  The opposite is true if the old value matches the filter and the new value doesn't.  If they both match the filter, you get both `old_val` and `new_val`.  If neither matches the filter, you don't get a message.\r\n\r\n> What's the API for saying stream.group(...).avg(...).changes()\r\n\r\nForgot to specify that.  I think you should get a stream of objects such that shallow-merging the original result of the `group` call with those objects produces the updated `group` value.  For example, if you have `r.table('test').group('a').sum('b').changes()`, and the initial value is `{foo: 10, bar: 20}`, and you update a document `{foo: 1}` to be `{baz: 12}`, you get the document `{foo: 9, baz: 12}` (the two groups that changed, but not the group `bar`).\r\n\r\n(When I say \"object\", I mean \"whatever the driver turns the `group` pseudotype into\".)"
  , issueCommentId = 47179663
  }