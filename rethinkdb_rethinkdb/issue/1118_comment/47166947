IssueComment
  { issueCommentUpdatedAt = 2014 (-06) (-25) 22 : 24 : 39 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/47166947"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1118#issuecomment-47166947"
  , issueCommentCreatedAt = 2014 (-06) (-25) 22 : 24 : 39 UTC
  , issueCommentBody =
      "> It also seems like it's not necessarily O(n) storage; there are various decisions you could make about whether to store the results of all intermediate maps and reduces, or only some or all of the reduces, at the expense of having to do a bit more recomputation upon change (e.g., rerunning the map operation on the leaves of the subtree that changed). But I think you could end up with O(log n) storage depending on what you decided there.\r\n\r\nYou'd have to do O(n/log(n)) work to recompute the root node if you used O(log(n)) storage, which would be too slow.\r\n\r\nThere are definitely advantages to not doing reversible map/reduce.\r\n\r\n(Also, there's no reason we can't have both long-term -- we can do reversible map/reduce when possible, and fall back to tree-rebuilding if no reverse function is provided.  That still leaves the question of which to implement first, though.)"
  , issueCommentId = 47166947
  }