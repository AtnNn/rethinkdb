Issue
  { issueClosedAt = Just 2015 (-08) (-03) 20 : 51 : 09 UTC
  , issueUpdatedAt = 2015 (-08) (-03) 20 : 51 : 42 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/1913/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/rethinkdb/issues/1913"
  , issueClosedBy = Nothing
  , issueLabels =
      [ IssueLabel
          { labelColor = "207de5"
          , labelUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/labels/cp:clustering"
          , labelName = "cp:clustering"
          }
      ]
  , issueNumber = 1913
  , issueAssignee = Nothing
  , issueUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueTitle =
      "Proposal: allow external programs to bypass/replace cluster administration code"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/1913"
  , issueCreatedAt = 2014 (-01) (-28) 01 : 57 : 54 UTC
  , issueBody =
      Just
        "Here's a wild suggestion: make it possible for external programs to bypass/replace the C++ cluster administration code.\r\n\r\nBy \"C++ cluster administration code\" I mean the goals, the suggester, the automatic failover code (that doesn't exist yet), and the entire notion of declaring a machine dead, among other things. The boundary between cluster administration code and the rest is just above `reactor_t`; external programs should be able to feed blueprints directly to the `reactor_t` of a specific machine.\r\n\r\nIf such an interface existed, a lot of the issues in #1911 could be addressed by an external program. In particular: #1900, #1876, #223 (except lossless rebalance), #1792, and #1905. So, if the normal RethinkDB high-level clustering code didn't handle a particular use case properly, then third parties could write an external program to replace it. Exposing this interface would be a fairly easy feature to implement, and it would allow RethinkDB to be greatly extensible. The official RethinkDB cluster administration code probably won't \"get right\" clustering administration once and for all; there are too many corner cases, unusual use cases, and potential trade-offs. By decoupling the cluster administration from the core engine, we can allow third parties to fill in the gaps or integrate RethinkDB with their favorite tool like Zookeeper or etcd.\r\n\r\nThis idea could also be taken a lot further by moving the existing cluster administration code, including the web UI, out of the C++ executable and into an official external program written and maintained by the RethinkDB team. The external program would probably be written in Python. If we did this, the Python program would \"wrap\" the C++ engine, so users would run the Python program which would in turn run the C++ program. (Perhaps they would talk over stdin/stdout.) Then we could move the porcelain command-line argument parsing from C++ to Python.\r\n\r\nThe advantages of having a separate Python component are:\r\n\r\n* Python is nicer than C++ for high-level code that doesn't need to run fast. Right now the C++ code isn't too bad, but we're likely to want to add a lot more features as we go along. For example, suppose that we want to email a sysadmin when there's a problem. That's much easier in Python than in C++.\r\n\r\n* It's easier for third parties to write plug-ins for a Python program than for a C++ program. If people want just one feature that the existing code doesn't offer, but they don't want to write their own full-featured cluster administration logic from scratch, then such a plug-in interface would be very valuable.\r\n\r\n* If the engine crashes, the Python component will stay up, because they aren't in the same process. This gives us more crash recovery options. (We could potentially take this even further by having e.g. one RethinkDB process per namespace. But then there are issues with setting up network connections, so that's probably a bad idea.)\r\n\r\n* Decoupling the engine from the administration code is elegant.\r\n\r\nOf course, the problem is that we would have to actually port the C++ logic to Python; this would take time and introduce bugs.\r\n"
  , issueState = "closed"
  , issueId = Id 26411274
  , issueComments = 8
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 706854
                , simpleUserLogin = N "AtnNn"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/706854?v=3"
                , simpleUserUrl = "https://api.github.com/users/AtnNn"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 1
          , milestoneNumber = 18
          , milestoneClosedIssues = 180
          , milestoneDescription =
              Just
                "These feature requests, bugs and pull requests have been acknowledged, but will not be fixed."
          , milestoneTitle = "wontfix"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/rethinkdb/milestones/18"
          , milestoneCreatedAt = 2013 (-03) (-29) 20 : 23 : 24 UTC
          , milestoneState = "closed"
          }
  }