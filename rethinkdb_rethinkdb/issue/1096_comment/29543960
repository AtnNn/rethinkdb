IssueComment
  { issueCommentUpdatedAt = 2013 (-11) (-30) 02 : 02 : 27 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1777134
        , simpleUserLogin = N "mlucy"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1777134?v=3"
        , simpleUserUrl = "https://api.github.com/users/mlucy"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/29543960"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1096#issuecomment-29543960"
  , issueCommentCreatedAt = 2013 (-11) (-30) 02 : 02 : 27 UTC
  , issueCommentBody =
      "* Now that I know that Python can't hash arrays, the argument for representing `grouped_atoms` differently in the different drivers seems less strong.  Before it would have been \"we do the natural thing in every language except JS which has this weird restriction\", now it would be \"we do something different in every driver\".\r\n* I agree on making `sum` etc. take lambdas.\r\n* I like `GROUPING<STREAM>` and `GROUPING<DATUM>`.\r\n* We can let people name their group and reduction fields with optargs to `group`.\r\n* If we let people include members of a group, we could do it by adding an optarg `group_members => n` to `group`, where we return at most `n` members of the group with each group.  This would let people use the feature safely.\r\n\r\nI think we should do multi-reduction by implementing stream splitting, like so:\r\n```ruby\r\nr.table('test').map{|x| x[:id]}.split{|ids| [ids.count, ids.reduce{...}]}\r\n```\r\nThis would work for normal streams as well as grouped streams.  It would be tricky to implement on the server, but not impossible."
  , issueCommentId = 29543960
  }