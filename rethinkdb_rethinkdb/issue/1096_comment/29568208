IssueComment
  { issueCommentUpdatedAt = 2013 (-12) (-01) 06 : 16 : 28 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 1461947
        , simpleUserLogin = N "neumino"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/1461947?v=3"
        , simpleUserUrl = "https://api.github.com/users/neumino"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/29568208"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/1096#issuecomment-29568208"
  , issueCommentCreatedAt = 2013 (-12) (-01) 06 : 16 : 28 UTC
  , issueCommentBody =
      "Are we going to have a new method to convert a `grouped<streams>` and `grouped<atoms>` to an array?\r\n\r\nFor example, suppose I want to chain this query to map the groups (and not the stream)\r\n```js\r\nr.table(\"foo\").group(...).coerceTo(\"ARRAY\")\r\n// returns something like [\r\n// { group: 1, stream: [...] },\r\n// { group: 2, stream: [...] },\r\n// ]\r\n```\r\nHow can I do it?\r\n\r\n\r\nCan `r.table(\"posts\").group(\"author\")` returns all the distinct authors? So it would be some sugar for something like\r\n```js\r\nr.table(\"posts\").map( r,expr([r.row(\"author\"), true]).coerceTo(\"OBJECT\") )\r\n    .reduce( function(left, right) { return left.merge(right) })\r\n    .keys()\r\n```\r\nThat is to say grouped<streams> could be returned to the user in the form.\r\n\r\n\r\n\r\nI am also not sure that having `sum`, `avg` etc. take a lambda functon/field name is a good idea.\r\nIt's just going to make things more confusing for users I think. They will do a group().reduce() without a map and will think of `reduce` as a simple `fold`. That's a little out of the scope of the issue, but I think that may be something we want to keep in mind.\r\n"
  , issueCommentId = 29568208
  }