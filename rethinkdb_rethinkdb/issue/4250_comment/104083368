IssueComment
  { issueCommentUpdatedAt = 2015 (-05) (-21) 02 : 34 : 49 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 616428
        , simpleUserLogin = N "Timer"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/616428?v=3"
        , simpleUserUrl = "https://api.github.com/users/Timer"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/104083368"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/4250#issuecomment-104083368"
  , issueCommentCreatedAt = 2015 (-05) (-21) 00 : 52 : 34 UTC
  , issueCommentBody =
      "@deontologician I've saved you the trouble and tracked down the issue.\r\n\r\nBasically, due to the asynchronous nature of the code, calling a second close on the connection before the [nodejs/iojs] event loop has a chance to loop results in it registering a duplicate event listener.\r\n```javascript\r\n          if (_this.rawSocket != null) {\r\n            _this.rawSocket.once(\"close\", function() {\r\n              closeCb();\r\n              _this.rawSocket.removeAllListeners();\r\n              return _this.rawSocket = null;\r\n            });\r\n            return _this.rawSocket.end();\r\n          } else {\r\n            return process.nextTick(closeCb);\r\n          }\r\n```\r\nThe first event listener invokes a method on the rawSocket, then nulls it. Then the second (duplicate) listener then attempts to perform the same actions, but finds itself with a null object! I've presented three solutions, choose which you prefer.\r\n\r\n## Null check (simple patch fix) ##\r\n###### Solves the problem by simply checking if the socket was already cleaned (by us). Callback is still called as expected. ######\r\n```diff\r\ndiff --git a/drivers/javascript/net.coffee b/drivers/javascript/net.coffee\r\nindex 540735b..6f07365 100644\r\n--- a/drivers/javascript/net.coffee\r\n+++ b/drivers/javascript/net.coffee\r\n@@ -1133,7 +1133,8 @@ class TcpConnection extends Connection\r\n                         # called in response to the rawSocket 'close'\r\n                         # event, we need to additionally clean up the\r\n                         # rawSocket.\r\n-                        @rawSocket.removeAllListeners()\r\n+                        if @rawSocket?\r\n+                          @rawSocket.removeAllListeners()\r\n                         @rawSocket = null\r\n                     )\r\n                     @rawSocket.end()\r\n```\r\n\r\n## Using stream state ##\r\n###### Solves the issue by checking if end() was already called on the socket. ######\r\n```diff\r\ndiff --git a/drivers/javascript/net.coffee b/drivers/javascript/net.coffee\r\nindex 540735b..17fe685 100644\r\n--- a/drivers/javascript/net.coffee\r\n+++ b/drivers/javascript/net.coffee\r\n@@ -1126,7 +1126,7 @@ class TcpConnection extends Connection\r\n                         reject error\r\n                     else\r\n                         resolve result\r\n-                if @rawSocket?\r\n+                if @rawSocket? and not @rawSocket._writableState.ending\r\n                     @rawSocket.once(\"close\", =>\r\n                         closeCb()\r\n                         # In the case where we're actually being\r\n```\r\n#### A more round-about way of fixing the problem ####\r\n###### Ensures the socket can only be ended once. ######\r\n```diff\r\ndiff --git a/drivers/javascript/net.coffee b/drivers/javascript/net.coffee\r\nindex 540735b..8b86c9a 100644\r\n--- a/drivers/javascript/net.coffee\r\n+++ b/drivers/javascript/net.coffee\r\n@@ -1127,16 +1127,18 @@ class TcpConnection extends Connection\r\n                     else\r\n                         resolve result\r\n                 if @rawSocket?\r\n-                    @rawSocket.once(\"close\", =>\r\n+                    localSocket = @rawSocket\r\n+                    @rawSocket = null\r\n+                    localSocket.once(\"close\", =>\r\n                         closeCb()\r\n                         # In the case where we're actually being\r\n                         # called in response to the rawSocket 'close'\r\n                         # event, we need to additionally clean up the\r\n                         # rawSocket.\r\n-                        @rawSocket.removeAllListeners()\r\n-                        @rawSocket = null\r\n+                        localSocket.removeAllListeners()\r\n+                        return\r\n                     )\r\n-                    @rawSocket.end()\r\n+                    localSocket.end()\r\n                 else\r\n                     # If the rawSocket is already closed, there's no\r\n                     # reason to wait for a 'close' event that will\r\n```"
  , issueCommentId = 104083368
  }