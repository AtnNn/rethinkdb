IssueComment
  { issueCommentUpdatedAt = 2014 (-08) (-18) 22 : 07 : 33 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/52562565"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/2856#issuecomment-52562565"
  , issueCommentCreatedAt = 2014 (-08) (-18) 22 : 07 : 33 UTC
  , issueCommentBody =
      "> In the case I described earlier, the only way to add a replica on B is to request one more replica on default?\r\n\r\nNo, that's not the only way; they can also use the low-level API. In the scenario you're describing, it sounds like the user wants fine-grained control over exactly where their replicas end up, so they would probably be using the low-level API anyway.\r\n\r\n> If yes, this is extremely confusing.\r\n\r\nWhich part do you find confusing? The rule that you're not allowed to specify replication requirements for two overlapping tags?\r\n\r\n> Suppose I have a table A that requires 1 replica on tag1 and 1 replica on tag2. Suppose that I have just one machine with both tags (after killing a machine that let's say had just the tag tag1).\r\n\r\nThis is why we have the rule that you can't specify replication requirements for two overlapping tags. It excludes this scenario.\r\n\r\n(Also, why is this specific to auto-failover? It seems like you have an equivalent problem when the user manually calls `table.reconfigure()`.)"
  , issueCommentId = 52562565
  }