IssueComment
  { issueCommentUpdatedAt = 2016 (-05) (-27) 22 : 20 : 23 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/222265576"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/5799#issuecomment-222265576"
  , issueCommentCreatedAt = 2016 (-05) (-27) 22 : 19 : 08 UTC
  , issueCommentBody =
      "On the current `v2.3.x`, this work-around based on the generic rewrite described in https://github.com/rethinkdb/rethinkdb/issues/1118#issuecomment-222234293 can be used.\r\n\r\nJust set `input_stream` to whatever you want to have the count changefeed on, and set `II` and `IS` to `true` or `false` depending on whether you want to have initial results (`includeInitial`) and states (`includeStates`) respectively.\r\n\r\n```js\r\nvar input_stream = r.table('t1');\r\nvar II = true;\r\nvar IS = true;\r\n\r\nvar f_BASE = 0;\r\nvar f_APPLY = function(acc, el) { return acc.add(1); };\r\nvar f_UNAPPLY = function(acc, el) { return acc.sub(1); };\r\nvar f_EMIT = function(acc) { return acc; };\r\n\r\ninput_stream.changes({includeInitial: true, includeStates: true}).fold(\r\n  {f_acc: f_BASE, is_initialized: false},\r\n  function(acc, el) {\r\n    var f_acc = acc('f_acc');\r\n    var new_f_acc = r.branch(el.hasFields(\"old_val\"), f_UNAPPLY(f_acc, el('old_val')), f_acc).do(function(un_f_acc) {\r\n        return r.branch(el.hasFields(\"new_val\"), f_APPLY(un_f_acc, el('new_val')), un_f_acc);\r\n      });\r\n    var new_is_initialized = acc('is_initialized').or(el.hasFields('state').and(el('state').eq('ready')));\r\n    return {f_acc: new_f_acc, is_initialized: new_is_initialized};\r\n  },\r\n  {emit: function(old_acc, el, new_acc) {\r\n    var old_f_acc = old_acc('f_acc');\r\n    var new_f_acc = new_acc('f_acc');\r\n    var old_val = f_EMIT(old_f_acc);\r\n    var new_val = f_EMIT(new_f_acc);\r\n    // We handle the 'ready' state separately below\r\n    var emit_state = r.expr(IS).and(el.hasFields('state')).and(r.expr(II).not().or(el('state').ne('ready')));\r\n    var emit_update = old_acc('is_initialized').and(old_val.ne(new_val));\r\n    var emit_initial = r.expr(II).and(old_acc('is_initialized').not().and(new_acc('is_initialized')));\r\n    return r.branch(\r\n      emit_state, [el],\r\n      emit_update, [{'old_val': old_val, 'new_val': new_val}],\r\n      emit_initial, r.branch(IS, [{'new_val': new_val}, {state: \"ready\"}], [{'new_val': new_val}]),\r\n      []\r\n    );\r\n  }})\r\n```\r\n\r\nNote that this query does not yet work with the currently released version 2.3.2 because of https://github.com/rethinkdb/rethinkdb/issues/5800 ."
  , issueCommentId = 222265576
  }