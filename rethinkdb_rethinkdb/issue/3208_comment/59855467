IssueComment
  { issueCommentUpdatedAt = 2014 (-10) (-20) 23 : 17 : 21 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 167416
        , simpleUserLogin = N "VeXocide"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/167416?v=3"
        , simpleUserUrl = "https://api.github.com/users/VeXocide"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/rethinkdb/issues/comments/59855467"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/rethinkdb/issues/3208#issuecomment-59855467"
  , issueCommentCreatedAt = 2014 (-10) (-20) 23 : 15 : 21 UTC
  , issueCommentBody =
      "I've tested `boost::shared_ptr`, `std::shared_ptr`, and @gchpaco's branch of `counted_t` in both atomic and non-atomic variations using Clang 3.6.0 and GCC 4.9.1 with optimisation level `-DNDEBUG -O3` on my mid-2010 MacBook Pro with the following results. Note that there's no non-atomic version of `std::shared_ptr` thus those are omitted, for the non-atomic version of `boost::shared_ptr` compilation is performed using `-DBOOST_SP_DISABLE_THREADS`. The object here is an empty struct, though there are no notable differences when using an object with relatively large -- in the order of a hundred bytes -- string.\r\n\r\nAtomic on Clang:\r\n```\r\nboost::shared_ptr: 2535\r\n48513024\r\nstd::shared_ptr: 3621\r\n22040576\r\ncounted_t: 2532\r\n53473280\r\n```\r\n\r\nAtomic on GCC:\r\n```\r\nboost::shared_ptr: 2542\r\n48521216\r\nstd::shared_ptr: 1262\r\n22044672\r\ncounted_t: 2551\r\n40951808\r\n```\r\n\r\nNon-atomic on Clang:\r\n```\r\nboost::shared_ptr: 384\r\n64774144\r\ncounted_t: 391\r\n54554624\r\n```\r\n\r\nNon-atomic on GCC:\r\n```\r\nboost::shared_ptr: 261\r\n64790528\r\ncounted_t: 578\r\n39854080\r\n```\r\n\r\nHacky code used:\r\n```cpp\r\n#include <mach/mach.h>\r\n\r\n#include <chrono>\r\n#include <iostream>\r\n#include <thread>\r\n#include <vector>\r\n\r\n#include \"boost/shared_ptr.hpp\"\r\n#include \"boost/make_shared.hpp\"\r\n#include \"containers/counted.hpp\"\r\n\r\nclass test_string\r\n{\r\npublic:\r\n    test_string(std::string const & string)\r\n//       : _string(string)\r\n    {\r\n    }\r\n\r\nprivate:\r\n//    std::string _string;\r\n};\r\n\r\nclass test_countable_string\r\n#ifdef BOOST_SP_DISABLE_THREADS\r\n  : public single_threaded_countable_t<test_countable_string>\r\n#else\r\n  : public slow_atomic_countable_t<test_countable_string>\r\n#endif\r\n{\r\npublic:\r\n    test_countable_string(std::string const & string)\r\n//       : _string(string)\r\n    {\r\n    }\r\n\r\nprivate:\r\n//    std::string _string;\r\n};\r\n\r\nstd::size_t get_resident_size()\r\n{\r\n    struct mach_task_basic_info info;\r\n    mach_msg_type_number_t infoCount = MACH_TASK_BASIC_INFO_COUNT;\r\n    if (task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &infoCount) != KERN_SUCCESS)\r\n        return 0;\r\n    return info.resident_size;\r\n}\r\n\r\nint main()\r\n{\r\n    std::thread thread([]{\r\n        // std::this_thread::sleep_for(std::chrono::seconds(20));\r\n        uint64_t j = 0;\r\n        while (true)\r\n        {\r\n            j++;\r\n        }\r\n    });\r\n\r\n    {\r\n        const auto start_time = std::chrono::steady_clock::now();\r\n\r\n        boost::shared_ptr<test_string> outer_ptr =\r\n            boost::make_shared<test_string>(\"Enjoy an intuitive query language, automatically parallelized queries, and simple administration.\");\r\n        for (uint64_t i = 0; i < 100000000; ++i)\r\n        {\r\n            boost::shared_ptr<test_string> inner_ptr = outer_ptr;\r\n            outer_ptr = inner_ptr;\r\n        }\r\n\r\n        std::cout << \"boost::shared_ptr: \" << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time).count() << std::endl;\r\n    }\r\n\r\n    {\r\n        std::size_t start_resident = get_resident_size();\r\n\r\n        std::vector<boost::shared_ptr<test_string> > vector;\r\n        vector.reserve(1000000);\r\n        for (uint64_t i = 0; i < 1000000; ++i)\r\n        {\r\n            vector.push_back(boost::make_shared<test_string>(\"Enjoy an intuitive query language, automatically parallelized queries, and simple administration.\"));\r\n        }\r\n\r\n        std::cout << get_resident_size() - start_resident << std::endl;\r\n    }\r\n\r\n#ifndef BOOST_SP_DISABLE_THREADS\r\n    {\r\n        const auto start_time = std::chrono::steady_clock::now();\r\n\r\n        std::shared_ptr<test_string> outer_ptr =\r\n            std::make_shared<test_string>(\"Enjoy an intuitive query language, automatically parallelized queries, and simple administration.\");\r\n        for (uint64_t i = 0; i < 100000000; ++i)\r\n        {\r\n            std::shared_ptr<test_string> inner_ptr = outer_ptr;\r\n            outer_ptr = inner_ptr;\r\n        }\r\n\r\n        std::cout << \"std::shared_ptr: \" << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time).count() << std::endl;\r\n    }\r\n\r\n    {\r\n        std::size_t start_resident = get_resident_size();\r\n\r\n        std::vector<std::shared_ptr<test_string> > vector;\r\n        vector.reserve(1000000);\r\n        for (uint64_t i = 0; i < 1000000; ++i)\r\n        {\r\n            vector.push_back(std::make_shared<test_string>(\"Enjoy an intuitive query language, automatically parallelized queries, and simple administration.\"));\r\n        }\r\n\r\n        std::cout << get_resident_size() - start_resident << std::endl;\r\n    }\r\n#endif\r\n\r\n    {\r\n        const auto start_time = std::chrono::steady_clock::now();\r\n\r\n        counted_t<test_countable_string> outer_counted(new test_countable_string(\"Enjoy an intuitive query language, automatically parallelized queries, and simple administration.\"));\r\n            // make_counted<test_countable_string>(\"Enjoy an intuitive query language, automatically parallelized queries, and simple administration.\");\r\n        for (uint64_t i = 0; i < 100000000; ++i)\r\n        {\r\n            counted_t<test_countable_string> inner_counted = outer_counted;\r\n            outer_counted = inner_counted;\r\n        }\r\n\r\n        std::cout << \"counted_t: \" << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time).count() << std::endl;\r\n    }\r\n\r\n    {\r\n        std::size_t start_resident = get_resident_size();\r\n\r\n        std::vector<counted_t<test_countable_string> > vector;\r\n        vector.reserve(1000000);\r\n        for (uint64_t i = 0; i < 1000000; ++i)\r\n        {\r\n            vector.push_back(make_counted<test_countable_string>(\"Enjoy an intuitive query language, automatically parallelized queries, and simple administration.\"));\r\n        }\r\n\r\n        std::cout << get_resident_size() - start_resident << std::endl;\r\n    }\r\n\r\n    // thread.join();\r\n    thread.detach();\r\n}\r\n```"
  , issueCommentId = 59855467
  }